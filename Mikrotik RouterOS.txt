

    Creado por Artūrs C., actualizado por última vez por Oskars K. el dic 16, 2024 8 min de lectura

Overview

Layer Two Tunneling Protocol "L2TP" extends the PPP model by allowing the L2 and PPP endpoints to reside on different devices interconnected by a packet-switched network.  L2TP includes PPP authentication and accounting for each L2TP connection. Full authentication and accounting of each connection may be done through a RADIUS client or locally. L2TP traffic uses UDP protocol for both control and data packets. UDP port 1701 is used only for link establishment, further traffic is using any available UDP port (which may or may not be 1701). This means that L2TP can be used with most firewalls and routers (even with NAT) by enabling UDP traffic to be routed through the firewall or router.  L2TP standard is defined in RFC 2661. The L2TPv3 support added in 7.1 version. Support IPv4, IPv6.
Introduction

It may be useful to use L2TP just as any other tunneling protocol with or without encryption. The L2TP standard says that the most secure way to encrypt data is using L2TP over IPsec (Note that it is the default mode for Microsoft L2TP client) as all L2TP control and data packets for a particular tunnel appear as homogeneous UDP/IP data packets to the IPsec system. 

Multilink PPP (MP) is supported in order to provide MRRU (the ability to transmit full-sized 1500 and larger packets) and bridging over PPP links (using Bridge Control Protocol (BCP) that allows sending raw Ethernet frames over PPP links). This way it is possible to setup bridging without EoIP. The bridge should either have an administratively set MAC address or an Ethernet-like interface in it, as PPP links do not have MAC addresses.

L2TP does not provide encryption mechanisms for tunneled traffic. IPsec can be used for additional security layers.
L2TP Client
Properties
add-default-route (yes | no; Default: no)	Whether to add L2TP remote address as a default route.
allow (mschap2 | mschap1 | chap | pap; Default: mschap2, mschap1, chap, pap)	Allowed authentication methods.
connect-to (IP|IPv6; Default: )	

Remote address of L2TP server (if the address is in VRF table,  VRF should be specified)
/interface l2tp-client
add connect-to=192.168.88.1@vrf1 name=l2tp-out1 user=l2tp-client)


comment (string; Default: )	Short description of the tunnel.
default-route-distance (byte; Default: )	Since v6.2, sets distance value applied to auto created default route, if add-default-route is also selected
dial-on-demand (yes | no; Default: no)	connects only when outbound traffic is generated. If selected, then route with gateway address from 10.112.112.0/24 network will be added while connection is not established.
disabled (yes | no; Default: yes)	Enables/disables tunnel.
keepalive-timeout (integer [1..4294967295]; Default: 60s)	Since v6.0rc13, tunnel keepalive timeout in seconds.
max-mru (integer; Default: 1450)	Maximum Receive Unit. Max packet size that L2TP interface will be able to receive without packet fragmentation.
max-mtu (integer; Default: 1450)	Maximum Transmission Unit. Max packet size that L2TP interface will be able to send without packet fragmentation.
mrru (disabled | integer; Default: disabled)	Maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
name (string; Default: )	Descriptive name of the interface.
password (string; Default: "")	Password used for authentication.
profile (name; Default: default-encryption)	Specifies which PPP profile configuration will be used when establishing the tunnel.
user (string; Default: )	User name used for authentication.
use-ipsec (yes | no; Default: no)	

When this option is enabled, dynamic IPSec peer configuration and policy (transport mode) is added to encapsulate L2TP connection into IPSec tunnel. 

Multiple L2tp/ipsec clients behind the same NAT will not work in this mode. To achieve such scenario, disable use-ipsec and set static policies for clients with enabled tunnel=yes, level=unique settings. 


allow-fast-path (yes | no; Default: )	

Allow to forward packets without additional processing in the Linux kernel.
l2tp-proto-version ( l2tpv2 | l2tpv3-ip | l2tpv3-udp | l2tpv; Default:  l2tpv2 )	

Specify protocol version.
l2tpv3-cookie-length ( 0 | 4-bytes | 8-bytes ; Default:  0 )	

Configures an L2TPv3 pseudowire static session cookie.
l2tpv3-digest-hash (md5 | none | sha1 ; Default: md5 )	

Specifies which hash function to be used.
use-peer-dns (yes | no | exclusively; Default:  no  )	

To use peer dns.
copy-from	

To copy created peer.
src-address	

Specify source address.
l2tpv3-circuit-id 	

Set the virtual circuit identifier to bind the one end of the L2TPv3 control channel.
ipsec-secret (string; Default: )	

Preshared key used when use-ipsec is enabled.
L2TP Server

An interface is created for each tunnel established to the given server. There are two types of interfaces in the L2TP server's configuration

    Static interfaces are added administratively if there is a need to reference the particular interface name (in firewall rules or elsewhere) created for the particular user;
    Dynamic interfaces are added to this list automatically whenever a user is connected and its username does not match any existing static entry (or in case the entry is active already, as there can not be two separate tunnel interfaces referenced by the same name);

Dynamic interfaces appear when a user connects and disappear once the user disconnects, so it is impossible to reference the tunnel created for that use in router configuration (for example, in firewall), so if you need persistent rules for that user, create a static entry for him/her. Otherwise, it is safe to use a dynamic configuration.

in both cases PPP users must be configured properly - static entries do not replace PPP configuration.
Properties
authentication (pap | chap | mschap1 | mschap2; Default: mschap1,mschap2)	Authentication methods that server will accept.
default-profile (name; Default: default-encryption)	default profile to use
enabled (yes | no; Default: no)	Defines whether L2TP server is enabled or not.
max-mru (integer; Default: 1450)	Maximum Receive Unit. Max packet size that L2TP interface will be able to receive without packet fragmentation.
keepalive-timeout (integer; Default: 30)	If server during keepalive-timeout period does not receive any packets, it will send keepalive packets every second, five times. If the server still does not receive any response from the client, then the client will be disconnected after 5 seconds. Logs will show 5x "LCP missed echo reply" messages and then disconnect.
max-mtu (integer; Default: 1450)	Maximum Transmission Unit. Max packet size that L2TP interface will be able to send without packet fragmentation.
use-ipsec (no | yes | require; Default: no)	When this option is enabled, dynamic IPSec peer configuration is added to suite most of the L2TP road-warrior setups. When require is selected server will accept only those L2TP connection attempts that were encapsulated in the IPSec tunnel.
ipsec-secret (string; Default: )	Preshared key used when use-ipsec is enabled
accept-proto-version ( all |  l2tpv2 |  l2tpv3; Default: all ) cli-only	Specify protocol version.
accept-pseudowire-type ( all | ether | ppp; Default: all )	Set the pseudowire signaling protocol for specific pseudowire type.
allow-fast-path (no | yes; Default: no )	To forward packets without additional processing in the Linux kernel.
caller-id-type ( ip-address | number; Default: ip-address)	If same source IP address is used for multiple clients set id type to number.
max-sessions ( unlimited / number; Default: unlimited )	Set number of needed sessions.
one-session-per-host  ( no | yes | ; Default: no )	To allow one session per host.
l2tpv3-circuit-id (Default: )	Set the virtual circuit identifier to bind the one end of the L2TPv3 control channel.
l2tpv3-cookie-length (0 | 4-bytes | 8-bytes; Default: 0 )	Configures an L2TP pseudowire static session cookie.
l2tpv3-digest-hash ( md5 | none | sha1; Default: md5 )	Specifies which hash function to be used.
l2tpv3-ether-interface-list (Default: )	Set your interface list for example the default ones- all, dynamic, none, static.
mrru (disabled | integer; Default: disabled)	Maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
Quick Example

L2TP Server

On the servers side we will enable L2TP-server and create a PPP profile for a particular user:
[admin@MikroTik] > /interface l2tp-server server set enabled=yes
[admin@MikroTik] > /ppp secret add local-address=10.0.0.2 name=MT-User password=StrongPass profile=default-encryption remote-address=10.0.0.1 service=l2tp
L2TP Client

L2TP client setup in the RouterOS is very simple.  In the following example, we already have a preconfigured 3 unit setup. We will take a look more detailed on how to set up L2TP client with username "MT-User", password "StrongPass" and server 192.168.51.3:
[admin@MikroTik] > /interface l2tp-client \
add connect-to=192.168.51.3 disabled=no name=MT-User password=StrongPass user=MT-User
[admin@MikroTik] > /interface l2tp-client print 
Flags: X - disabled, R - running 
0 R name="MT-User" max-mtu=1450 max-mru=1450 mrru=disabled connect-to=192.168.51.3 user="MT-User" 
password="StrongPass" profile=default-encryption keepalive-timeout=60 use-ipsec=no ipsec-secret="" 
allow-fast-path=no add-default-route=no dial-on-demand=no allow=pap,chap,mschap1,mschap2
L2TP Ether
Overview

Layer 2 Tunnel Protocol Version 3 (L2TPv3) is a draft from the Internet Engineering Task Force (IETF) working group. It introduces various improvements to the original L2TP, allowing the encapsulation of Layer 2 (L2) payloads within L2TP. More precisely, L2TPv3 outlines the protocol for tunnelling Layer 2 payloads across an IP core network using L2 virtual private networks (VPNs).
Properties
connect-to ( IP; Default: )	

Remote address of L2TP server.
comment ( string; Default: )	Short description of the tunnel.
disabled ( yes | no; Default: yes)	Enables/disables tunnel.
mac-address ( string; Default: auto)	Set desired mac address of interface.
unmanaged-mode ( yes | no; Default: no)	Set unmanaged mode active, the configuration for additional settings will be possible, such as: peer-cookie, send-cookie, local-tunnel-id, local-session-id, remote-tunnel-id, remote-session-id, local-address.
local-tunnel-id ( string; Default: disabled)	Set value for local-tunnel-id, an integer required.
local-session-id ( string; Default: disabled)	Set value for local-session-id, an integer required.
remote-tunnel-id ( string; Default: disabled)	Set value for remote-tunnel-id, an integer required.
remote-session-id ( string; Default: disabled)	Set value for remote-session-id, an integer required.
peer-cookie ( string; Default: disabled)	Sets optional peer cookie. To enable cookie enter remote cookie value (8 or 16 character hex string value expected) to disable leave empty.
send-cookie ( string; Default: disabled)	Sets optional cookie. To enable cookie enter remote cookie value (8 or 16 character hex string value expected) to disable leave empty.
mtu (auto; Default: 1420)	Maximum Transmission Unit. Max packet size that L2TP interface will be able to send without packet fragmentation.
name (string; Default: )	Descriptive name of the interface.
local-address (IP address; Default: )	Set local address for unmanaged mode.
use-ipsec (yes | no; Default: no)	When this option is enabled, dynamic IPSec peer configuration and policy is added to encapsulate L2TP connection into IPSec tunnel.
allow-fast-path (yes | no; Default: no )	

Allow to forward packets without additional processing in the Linux kernel.
l2tp-proto-version (  l2tpv3-ip | l2tpv3-udp | ; Default: l2tpv3-udp )	

Specify protocol version.
cookie-length ( 0 | 4-bytes | 8-bytes ; Default:  0 )	

Configures an L2TPv3 pseudowire static session cookie.
digest-hash (md5 | none | sha1 ; Default: md5 )	

Specifies which hash function to be used.
use-l2-specific-sublayer ( yes | no; Default: no)	

Specify source address.
circuit-id 	

Set the virtual circuit identifier to bind the one end of the L2TPv3 control channel, this works as identifier for each redundant pseudowire.
ipsec-secret (string; Default: )	

Preshared key used when use-ipsec is enabled.




    Creado por Māris B., actualizado por última vez por Usuario desconocido (emils) el jun 14, 2022 3 min de lectura

    Overview
    Configuration
        Client
        LAC
        LNS
    Status Check
    Session Establishment

Overview

LAC/LNS setup or otherwise known as Virtual Private DialUp Network (VPDN) allows long-distance point-to-point connection between remote dial-up users and private networks.

Dial-up client uses PPPOE to connect to a L2TP access concentrator (LAC), LAC determines that session should be forwarded through a IP network to the L2TP Network Server (LNS), creates L2TP tunnel and forwards PPP frames to the server where client is authenticated and session established (see diagram below).



At the time of writing this article RouterOS cannot be used in LAC role. For this reason article will demonstrate how to set up very basic network with RouterOS as LNS and Cisco router as LAC.
Configuration

We will be using simple configuration to demonstrate very basics of VPDN setup. Lets assume that LAC will forward to the LNS clients with FQDN name containing mt.lv domain.
Client

For the sake of simplicity lets assume that client is RouterOS router:
/interface pppoe-client add interface=ether1 user=good_worker@mt.lv password=strongpass
LAC

Lets assume that client is connected to the GigabitEthernet1 port and IP address of the LNS server is 10.155.101.231
aaa new-model
!
aaa authentication ppp default local
!
vpdn enable
vpdn aaa attribute nas-ip-address vpdn-nas
vpdn search-order domain dnis 
!
vpdn-group LAC
 request-dialin
  protocol l2tp
  domain mt.lv
 initiate-to ip 10.155.101.231
 source-ip 10.155.101.216
 local name LAC
 l2tp tunnel password 0 tunnelpass
!
bba-group pppoe MAIN-BBA
 virtual-template 1
!
interface GigabitEthernet1
 pppoe enable group MAIN-BBA
!
interface Virtual-Template1
 description pppoe MAIN-BBA
 no ip address
 no peer default ip address
 ppp mtu adaptive
 ppp authentication chap
!

Note that this setup does not authenticate client nor locally nor via RADIUS, does not actually check domain name, does not control L2 access for the sake of simplicity. If you want to use those features refer to Cisco configuration manuals.
LNS

On the LNS we need to enable L2TP server and set up method to authenticate the L2TP connection from the LAC.
/interface l2tp-server server
set enabled=yes
/ppp l2tp-secret
add address=10.155.101.216/32 secret=tunnelpass

Now the actual user authentication. In this case we will be using local authentication method for the sake of simplicity.
/ip pool
add name=pool0 ranges=192.168.99.2-192.168.99.99
/ppp profile
set default local-address=192.168.99.1 remote-address=pool0
/ppp secret
add name=good_worker@mt.lv password=strongpass
Status Check

On the LNS you can see all successfully connected clients by checking l2tp server interfaces or checking active ppp connections:
[admin@CHR_v6_bgp] /interface l2tp-server> print
Flags: X - disabled, D - dynamic, R - running
# NAME USER MTU CLIENT-ADDRESS UPTIME ENCODING
0 DR <l2tp-... good_worker@mt.lv 1450 10.155.101.216 6h13m49s

[admin@CHR_v6_bgp] /ppp active> print
Flags: R - radius
# NAME SERVICE CALLER-ID ADDRESS UPTIME ENCODING
0 good_worker@mt.lv l2tp 10.155.101.216 192.168.99.2 6h15m57s 

On the LAC we can also see active client sessions and active L2TP tunnel between LAC and LNS:
csrLAC#show vpdn

L2TP Tunnel and Session Information Total tunnels 1 sessions 1

LocTunID RemTunID Remote Name State Remote Address Sessn L2TP Class/
Count VPDN Group
26090 11 CHR_v6_bgp est 10.155.101.231 50 LAC

LocID RemID TunID Username, Intf/ State Last Chg Uniq ID
Vcid, Circuit
18521 16 26090 good_worker@mt.lv, Gi1 est 06:17:07 571

Session Establishment

Lets look closely on how clients sessions gets authenticated and established over the LAC.

    Client initiates PPPoE call
    LAC and Client begins LCP negotiation
    after CHAP has been negotiated, LAC sends CHAP challenge
    Client sends CHAP response
    LAC checks whether client session should be forwarded to the LNS based on received domain name. Check can be done locally or using RADIUS server. Client also can be authenticated here before forwarding session.
    LAC brings up an L2TP tunnel
    LNS checks if the LAC is allowed to open a tunnel and run the authentication process. The Tunnel is up and ready to forward VPDN sessions.
    LAC forwards negotiated with the client LCP options, username and password to the LNS
    LNS authenticates the client locally or using RADIUS and sends CHAP response
    IP Control Protocol (IPCP) phase is performed, IP addresses and routes are installed. At this point sessions is considered established.
	
	
	

    Creado por Artūrs C., actualizado por última vez por Oskars K. el mar 11, 2025 7 min de lectura

    Overview
    Introduction
    Limitations
    OVPN Client
    Tls-crypt, tls-crypt v2
    OVPN Server
        Server Configuration
            Properties
    Example
        Setup Overview
        Creating Certificates
        Server Config
        Client Config
        Push Route
        VRF support 

Overview

The OpenVPN security model is based on SSL, the industry standard for secure communications via the internet. OpenVPN implements OSI layer 2 or 3 secure network extensions using the SSL/TLS protocol. Support IPv4, IPv6.
Introduction

OpenVPN has been ported to various platforms, including Linux and Windows, and its configuration is likewise on each of these systems, so it makes it easier to support and maintain. OpenVPN can run over User Datagram Protocol (UDP) or Transmission Control Protocol (TCP) transports, multiplexing created SSL tunnels on a single TCP/UDP port. OpenVPN is one of the few VPN protocols that can make use of a proxy, which might be handy sometimes.
Limitations

ROS has its own ovpn implementation , not all ovpn features are supported and not all unsupported are listed. Currently, noteable unsupported OpenVPN features:

    LZO compression.
    NCP autonegotiation, cipher has to been specified in .ovpn file when connecting to an ROS ovpn server. 

OpenVPN username is limited to 27 characters and the password to 233 characters. Password cap increased in 7.18_ab253 to 1000 characters.
OVPN Client
add-default-route (yes | no; Default: no)	Whether to add OVPN remote address as a default route.
auth (md5 | sha1 | null | sha256 | sha512; Default: sha1)	Allowed authentication methods.
certificate (string | none; Default: none)	Name of the client certificate
cipher (null | aes128-cbc | aes128-gcm | aes192-cbc | aes192-gcm | aes256-cbc | aes256-gcm | blowfish128; Default: blowfish128)	Allowed ciphers. In order to use GCM type ciphers, the "auth" parameter must be set to "null", because GCM cipher is also responsible for "auth", if used.
comment (string; Default: )	Descriptive name of an item
connect-to (IP|IPv6; Default: )	Remote address of the OVPN server.
disabled (yes | no; Default: yes)	Whether the interface is disabled or not. By default it is disabled.
mac-address (MAC; Default: )	Mac address of OVPN interface. Will be automatically generated if not specified.
max-mtu (integer; Default: 1500)	Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.
mode (ip | ethernet; Default: ip)	Layer3 or layer2 tunnel mode (alternatively tun, tap)
name (string; Default: )	Descriptive name of the interface.
password (string; Default: "")	Password used for authentication. Value of password should not be longer than 1000 chars.
port (integer; Default: 1194)	Port to connect to.
profile (name; Default: default)	Specifies which PPP profile configuration will be used when establishing the tunnel.
protocol (tcp | udp; Default: tcp)	indicates the protocol to use when connecting with the remote endpoint.
verify-server-certificate (yes | no; Default: no)	

Checks the certificates CN or SAN against the "connect-to" parameter. The IP or hostname must be present in the server's certificate.
tls-version (any | only-1.2; Default: any)	Specifies which TLS versions to allow
use-peer-dns (yes | no; Default: no)	Whether to add DNS servers provided by the OVPN server to IP/DNS configuration.

route-nopull (yes | no; Default: no)
	Specifies whether to allow the OVPN server to add routes to the OVPN client instance routing table.
user (string; Default: )	User name used for authentication.

Also, it is possible to import the OVPN client configuration from a .ovpn configuration file. Such a file usually is provided from the OVPN server side and already includes configuration so you need to worry only about a few parameters.
/interface/ovpn-client/import-ovpn-configuration ovpn-password=securepassword \
key-passphrase=certificatekeypassphrase ovpn-user=myuserid skip-cert-import=no 

OVPN client supports tls authentication. The configuration of tls-auth can be added only by importing .ovpn configuration file. Using tls-auth requires that you generate a shared-secret key, this key should be added to the client configuration file .ovpn.

Note* ROS client requires user name and password. Authentication is managed by server side, if its supports tls, then user name will be ignored.
key-direction 1
<tls-auth>
#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
-----END OpenVPN Static key V1-----
</tls-auth>
7.17beta5 added support to allow non-null auth in gcm mode.
Tls-crypt, tls-crypt v2

To improve TLS auth, Tls-crypt is added in version 7.17rc3. 

Tls-crypt, tls-crypt v2 is suppoorted only for ovpn client with following settings:

“auth SHA256” and no key-direction in server configuration,

“auth SHA256” and “key-direction 1” in client configuration is needed for authentication to work. 

Example configuration files:

client-1.ovpn

server-1.conf
OVPN Server
/interface ovpn-server

An interface is created for each tunnel established to the given server. There are two types of interfaces in the OVPN server's configuration

    Static interfaces are added administratively if there is a need to reference the particular interface name (in firewall rules or elsewhere) created for the particular user.
    Dynamic interfaces are added to this list automatically whenever a user is connected and its username does not match any existing static entry (or in case the entry is active already, as there can not be two separate tunnel interfaces referenced by the same name).

Dynamic interfaces appear when a user connects and disappear once the user disconnects, so it is impossible to reference the tunnel created for that use in router configuration (for example, in the firewall), so if you need a persistent rule for that user, create a static entry for him/her. Otherwise, it is safe to use dynamic configuration.

After upgrade to 7.17 version ovpn server will receive its configuration, due to multiple server support. 

An disabled ovpn server with added mac will appear in configuration: 
/interface ovpn-server server add mac-address=99:99:99:99:99:99 name=ovpn-server1

In both cases PPP users must be configured properly - static entries do not replace PPP configuration.
Server Configuration
Properties
auth (md5 | sha1 | null | sha256 | sha512; Default: sha1,md5,sha256,sha512)	Authentication methods that the server will accept.
certificate (name | none; Default: none)	Name of the certificate that the OVPN server will use.
cipher (null | aes128-cbc | aes128-gcm | aes192-cbc | aes192-gcm | aes256-cbc | aes256-gcm | blowfish128; Default: aes128-cbc,blowfish128)	Allowed ciphers.
default-profile (name; Default: default)	Default profile to use.
disabled (yes | no; Default: yes)	Defines whether the OVPN server is enabled or not.
protocol (tcp | udp; Default: tcp)	Indicates the protocol to use when connecting with the remote endpoint.
keepalive-timeout (integer | disabled; Default: 60)	Defines the time period (in seconds) after which the router is starting to send keepalive packets every second. If no traffic and no keepalive responses have come for that period of time (i.e. 2 * keepalive-timeout), not responding client is proclaimed disconnected
mac-address (MAC; Default: )	Automatically generated MAC address of the server.
max-mtu (integer; Default: 1500)	Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.
mode (ip | ethernet; Default: ip)	Layer3 or layer2 tunnel mode (alternatively tun, tap)
name (string)
	Name of the server
netmask (integer; Default: 24)	Subnet mask to be applied to the client.
port (integer; Default: 1194)	Port to run the server on.
require-client-certificate (yes | no; Default: no)	If set to yes, then the server checks whether the client's certificate belongs to the same certificate chain.
redirect-gateway (def1 | disabled | ipv6; Default: disabled) 	

Specifies what kind of routes the OVPN client must add to the routing table. 

def1 – Use this flag to override the default gateway by using 0.0.0.0/1 and 128.0.0.0/1 rather than 0.0.0.0/0. This has the benefit of overriding but not wiping out the original default gateway.
disabled - Do not send redirect-gateway flags to the OVPN client.
ipv6 - Redirect IPv6 routing into the tunnel on the client side. This works similarly to the def1 flag, that is, more specific IPv6 routes are added (2000::/4 and 3000::/4), covering the whole IPv6 unicast space.
enable-tun-ipv6 (yes | no; Default: no)	

Specifies if IPv6 IP tunneling mode should be possible with this OVPN server.
ipv6-prefix-len (integer; Default: 64)	

Length of IPv6 prefix for IPv6 address which will be used when generating OVPN interface on the server side.
reneg-sec  (integer; Default: 3600)	

Key renegotiate seconds, the time the server periodically renegotiates the secret key for the data channel.
push-routes (string; Default: )	

Push route support are added in 7.14, the maximum of possible input is limited to 1400 characters. 
tls-version (any | only-1.2 ; Default: any )	

TLS protocol setting.
tun-server-ipv6 (IPv6 prefix; Default: ::)	

IPv6 prefix address which will be used when generating the OVPN interface on the server side.
user-auth-method (mschap2 | pap ; Default pap)	

By the default pap authentication method is used, if preferred server authentication with chap challenge set mschap2 in server settings.
vrf ()
	

VRF in which listen for connection attempts

Also, it is possible to prepare a .ovpn file for the OVPN client which can be easily imported on the end device. Server need to have option enabled - required client certificate to export work. 
interface/ovpn-server/server/export-client-configuration ca-certificate=ca.crt  client-certificate=cert_e
xport_rw-client.crt  client-cert-key=cert_export_rw-client.key server-address=1.1.1.1 server=ovpn-server1 

It is very important that the date on the router is within the range of the installed certificate's date of expiration. To overcome any certificate verification problems, enable NTP date synchronization on both the server and the client.
Example
Setup Overview

Assume that Office public IP address is 2.2.2.2 and we want two remote OVPN clients to have access to 10.5.8.20 and 192.168.55.0/24 networks behind the office gateway. 
Creating Certificates

All certificates can be created on the RouterOS server using the certificate manager. See example >>.

For the simplest setup, you need only an OVPN server certificate.
Server Config

The first step is to create an IP pool from which client addresses will be assigned and some users.
/ip pool add name=ovpn-pool range=192.168.77.2-192.168.77.254

/ppp profile add name=ovpn local-address=192.168.77.1 remote-address=ovpn-pool
/ppp secret
add name=client1 password=123 profile=ovpn
add name=client2 password=234 profile=ovpn

Assume that the server certificate is already created and named "server" 
/interface ovpn-server server add disabled=no certificate=server name=myServer
Client Config

Add manually which networks you want to access over the tunnel. 
/interface ovpn-client
add name=ovpn-client1 connect-to=2.2.2.2 user=client1 password=123 disabled=no
/ip route 
add dst-address=10.5.8.20 gateway=ovpn-client1
add dst-address=192.168.55.0/24 gateway=ovpn-client1
/ip firewall nat add chain=srcnat action=masquerade out-interface=ovpn-client1
Push Route

Push route support are added in 7.14, the maximum of possible input is limited to 1400 characters. 
example: route network/IP [netmask] [gateway] [metric].
/interface ovpn-server server set myServer push-routes="192.168.102.0 255.255.255.0 192.168.109.1 9"
VRF support 

Support starting from 7.17 version is added, and couple changes introduced in configuration, if you use latest version, please refer to this example:

Server side configuration:
      /interface ovpn-server server
        add disabled=no certificate=yourcert auth=sha1 cipher=aes128-cbc require-client-certificate=yes protocol=tcp name=ovpn-server1 vrf=main
		
		
		

    Creado por Artūrs C., actualizado por última vez por Edgars P. el abr 08, 2025 10 min de lectura

    Overview
    Introduction
    PPPoE Operation
        Discovery phase
        Session phase
    MTU
    PPPoE Client
        Properties
        Status
        Scanner
    PPPoE Server
        Access concentrator 
            Properties
    Quick Example
        PPPoE Client
        PPPoE Server

Overview


Point to Point over Ethernet (PPPoE) is simply a method of encapsulating PPP packets into Ethernet frames. PPPoE is an extension of the standard Point to Point Protocol (PPP) and it the successor of PPPoA. PPPoE standard is defined in RFC 2516. The PPPoE client and server work over any Layer2 Ethernet level interface on the router, for example, Wireless, Ethernet, EoIP, etc. Generally speaking, PPPoE is used to hand out IP addresses to clients based on authentication by username (and also if required, by workstation) as opposed to workstation only authentication where static IP addresses or DHCP are used. It is advised not to use static IP addresses or DHCP on the same interfaces as PPPoE for obvious security reasons.
Introduction

PPPoE provides the ability to connect a network of hosts over a simple bridging access device to a remote Access Concentrator.  

Supported connections:

    MikroTik RouterOS PPPoE client to any PPPoE server;
    MikroTik RouterOS server (access concentrator) to multiple PPPoE clients (clients are available for almost all operating systems and most routers);

PPPoE Operation

PPPoE has two distinct stages(phases):

    Discovery phase;
    Session phase;

Discovery phase

There are four steps to the Discovery stage. When it completes, both peers know the PPPoE SESSION_ID and the peer's Ethernet address, which together define the PPPoE session uniquely:

     PPPoE Active Discovery Initialization (PADI) - The PPPoE client sends out a PADI packet to the broadcast address. This packet can also populate the "service-name" field if a service name has been entered in the dial-up networking properties of the PPPoE client. If a service name has not been entered, this field is not populated
    PPPoE Active Discovery Offer (PADO) - The PPPoE server, or Access Concentrator, should respond to the PADI with a PADO if the Access Concentrator is able to service the "service-name" field that had been listed in the PADI packet. If no "service-name" field had been listed, the Access Concentrator will respond with a PADO packet that has the "service-name" field populated with the service names that the Access Concentrator can service. The PADO packet is sent to the unicast address of the PPPoE client
    PPPoE Active Discovery Request (PADR) - When a PADO packet is received, the PPPoE client responds with a PADR packet. This packet is sent to the unicast address of the Access Concentrator. The client may receive multiple PADO packets, but the client responds to the first valid PADO that the client received. If the initial PADI packet had a blank "service-name" field filed, the client populates the "service-name" field of the PADR packet with the first service name that had been returned in the PADO packet.

    PPPoE Active Discovery Session Confirmation (PADS) - When the PADR is received, the Access Concentrator generates a unique session identification (ID) for the Point-to-Point Protocol (PPP) session and returns this ID to the PPPoE client in the PADS packet. This packet is sent to the unicast address of the client.

PPPoE session termination:

    PPPoE Active Discovery Terminate (PADT) - Can be sent anytime after a session is established to indicate that a PPPoE session terminated. It can be sent by either server or client.

Session phase

When the discovery stage is completed, both peers know PPPoE Session ID and other peer's Ethernet (MAC) address which together defines the PPPoE session. PPP frames are encapsulated in PPPoE session frames, which have Ethernet frame type 0x8864.
When a server sends confirmation and a client receives it, PPP Session is started that consists of the following stages:

    LCP negotiation stage
    Authentication (CHAP/PAP) stage
    IPCP negotiation stage - where the client is assigned an IP address.

If any process fails, the LCP negotiation establishment phase is started again.


PPPoE server sends Echo-Request packets to the client to determine the state of the session, otherwise, the server will not be able to determine that session is terminated in cases when a client terminates session without sending Terminate-Request packet.
MTU

Typically, the largest Ethernet frame that can be transmitted without fragmentation is 1500 bytes. PPPoE adds another 6 bytes of overhead and the PPP field adds two more bytes, leaving 1492 bytes for IP datagram. Therefore max PPPoE MRU and MTU values must not be larger than 1492.

TCP stacks try to avoid fragmentation, so they use an MSS (Maximum Segment Size). By default, MSS is chosen as MTU of the outgoing interface minus the usual size of the TCP and IP headers (40 bytes), which results in 1460 bytes for an Ethernet interface. Unfortunately, there may be intermediate links with lower MTU which will cause fragmentation. In such a case TCP stack performs path MTU discovery. Routers that cannot forward the datagram without fragmentation are supposed to drop the packet and send ICMP-Fragmentation-Required to originating host. When a host receives such an ICMP packet, it tries to lower the MTU. This should work in the ideal world, however in the real world many routers do not generate fragmentation-required datagrams, also many firewalls drop all ICMP datagrams.

The workaround for this problem is to adjust MSS if it is too big. 
PPPoE Client
Properties
ac-name (string; Default: "")	Access Concentrator name, this may be left blank and the client will connect to any access concentrator on the broadcast domain
add-default-route (yes|no; Default: no)	Enable/Disable whether to add default route automatically
allow (mschap2|mschap1|chap|pap; Default: mschap2,mschap1,chap,pap)	allowed authentication methods, by default all methods are allowed
default-route-distance (byte [0..255]; Default:1)	sets distance value applied to auto created default route, if add-default-route is also selected
dial-on-demand (yes|no; Default: no)	connects to AC only when outbound traffic is generated. If selected, then route with gateway address from 10.112.112.0/24 network will be added while connection is not established.
interface (string; Default: )	interface name on which client will run
keepalive-timeout (integer; Default:60)	Sets keepalive timeout in seconds.
max-mru (integer; Default: 1460)	Maximum Receive Unit
max-mtu (integer; Default: 1460)	Maximum Transmission Unit
mrru (integer: 512..65535|disabled; Default: disabled)	maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
name (string; Default: pppoe-out[i])	name of the PPPoE interface, generated by RouterOS if not specified
password (string; Default: )	password used to authenticate
profile (string; Default: default)	Specifies which PPP profile configuration will be used when establishing the tunnel.
service-name (string; Default: "")	specifies the service name set on the access concentrator, can be left blank to connect to any PPPoE server
use-peer-dns (yes|no; Default: no)	enable/disable getting DNS settings from the peer
user (string; Default: "")	

username used for authentication
Status

Command /interface pppoe-client monitor will display current PPPoE status.

Available read only properties:
ac-mac (MAC address)	MAC address of the access concentrator (AC) the client is connected to
ac-name (string)	name of the Access Concentrator
active-links (integer)	Number of bonded MLPPP connections, ('1' if not using MLPPP)
encoding (string)	encryption and encoding (if asymmetric, separated with '/') being used in this connection
local-address (IP Address)	IP Address allocated to client
remote-address (IP Address)	Remote IP Address allocated to server (ie gateway address)
mru (integer)	effective MRU of the link
mtu (integer)	effective MTU of the link
service-name (string)	used service name
status (string)	current link status. Available values are:

    dialing,
    verifying password...,
    connected,
    disconnected.

uptime (time)	connection time displayed in days, hours, minutes and seconds
Scanner

PPPoE Scanner allows scanning all active PPPoE servers in the layer2 broadcast domain. Command to run scanner is as follows:
/interface pppoe-client scan [interface]

Available read only properties: 
service (string)	Service name configured on server
mac-address (MAC)	Mac address of detected server
ac-name (string)	name of the Access Concentrator

For Windows, some connection instructions may use the form where the "phone number", such as "MikroTik_AC\mt1", is specified to indicate that "MikroTik_AC" is the access concentrator name and "mt1" is the service name.

Specifying MRRU means enabling MP (Multilink PPP) over a single link. This protocol is used to split big packets into smaller ones. Under Windows, it can be enabled in the Networking tab, Settings button, "Negotiate multi-link for single link connections". MRRU is hardcoded to 1614 on Windows. This setting is useful to overcome PathMTU discovery failures. The MP setting should be enabled on both peers.
PPPoE Server

There are two types of interface (tunnel) items in PPPoE server configuration - static users and dynamic connections. An interface is created for each tunnel established to the given server. Static interfaces are added administratively if there is a need to reference the particular interface name (in firewall rules or elsewhere) created for the particular user. Dynamic interfaces are added to this list automatically whenever a user is connected and its username does not match any existing static entry (or in case the entry is active already, as there can not be two separate tunnel interfaces referenced by the same name - set one-session-per-host value if this is a problem). Dynamic interfaces appear when a user connects and disappear once the user disconnects, so it is impossible to reference the tunnel created for that use in router configuration (for example, in firewall), so if you need a persistent rule for that user, create a static entry for him/her. Otherwise, it is safe to use a dynamic configuration. 

In both cases PPP users must be configured properly - static entries do not replace PPP configuration.
Access concentrator 
/interface pppoe-server server
Properties
accept-untagged (yes | no; Default: yes)	This setting controls whether the PPPoE server will accept untagged (non-VLAN) PPPoE packets on its interface. By default, untagged PPPoE packets are accepted. If you are using the pppoe-over-vlan-range property (which enabled PPPoE over 802.1Q VLANs), this option lets you decide whether to still allow untagged clients on the same interface. If you are not using the pppoe-over-vlan-range, this setting do not have any effect.
authentication ( mschap2 | mschap1 | chap | pap; Default: "mschap2, mschap1, chap, pap")	Authentication algorithm.
default-profile (string; Default: "default")	
interface (string; Default: "")	Interface that the clients are connected to.
keepalive-timeout (time; Default: "10")	Defines the time period (in seconds) after which the router is starting to send keepalive packets every second. If there is no traffic and no keepalive responses arrive for that period of time (i.e. 2 * keepalive-timeout), the non responding client is proclaimed disconnected.
max-mru (integer; Default: "1480")	Maximum Receive Unit. The optimal value is the MTU of the interface the tunnel is working over reduced by 20 (so, for 1500-byte Ethernet link, set the MTU to 1480 to avoid fragmentation of packets)
max-mtu (integer; Default: "1480")	Maximum Transmission Unit. The optimal value is the MTU of the interface the tunnel is working over reduced by 20 (so, for 1500-byte Ethernet link, set the MTU to 1480 to avoid fragmentation of packets)
max-sessions (integer; Default: "0")	Maximum number of clients that the AC can serve. '0' = no limitations.
mrru (integer: 512..65535 | disabled; Default: "disabled")	Maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
one-session-per-host (yes | no; Default: "no")	Allow only one session per host (determined by MAC address). If a host tries to establish a new session, the old one will be closed.
pppoe-over-vlan-range (integer 1..4094; Default: "")	

This setting allows a PPPoE server to operate over 802.1Q VLANs. By default, a PPPoE server only accepts untagged packets on its interface. However, in scenarios where clients are on separate VLANs, instead of creating multiple 802.1Q VLAN interfaces and bridging them together or configuring individual PPPoE servers for each VLAN, you can specify the necessary VLANs directly in the PPPoE server settings.

When you specify the VLAN IDs, the PPPoE server will accept 802.1Q tagged packets from clients, and it will reply using the same VLAN. You then have an option to accept or drop untagged PPoE clients on the same interface using the accept-untagged property.

The pppoe-over-vlan-range setting can be applied to both CVLAN and SVLAN interfaces, enabling the QinQ setups as well. See the use-service-tag=yes option on a VLAN interface. But keep in mind that the inner VLAN tag should be 802.1Q.

The setting supports a range of VLAN IDs, as well as individual VLANs specified using comma-separated values. For example: pppoe-over-vlan-range=100-115,120,122,128-130.
service-name (string; Default: "")	The PPPoE service name. Server will accept clients which sends PADI message with service-names that matches this setting or if service-name field in PADI message is not set.

The PPPoE server (access concentrator) supports multiple servers for each interface - with differing service names. The access concentrator name and PPPoE service name are used by clients to identify the access concentrator to register with. The access concentrator name is the same as the identity of the router displayed before the command prompt. The identity may be set within the /system identity submenu.

Do not assign an IP address to the interface you will be receiving the PPPoE requests on.


Specifying MRRU means enabling MP (Multilink PPP) over a single link. This protocol is used to split big packets into smaller ones.  Their MRRU is hardcoded to 1614. This setting is useful to overcome PathMTU discovery failures. The MP setting should be enabled on both peers.

The default keepalive-timeout value of 10s is OK in most cases. If you set it to 0, the router will not disconnect clients until they explicitly log out or the router is restarted. To resolve this problem, the one-session-per-host property can be used.
Quick Example

PPPoE Client

To configure MikroTik RouterOS to be a PPPoE client, just add a PPPoE-client with the following parameters as in the example:
[admin@MikroTik] > interface pppoe-client add interface=ether2 password=StrongPass service-name=pppoeservice name=PPPoE-Out disabled=no user=MT-User
[admin@MikroTik] > interface pppoe-client print
Flags: X - disabled, I - invalid, R - running 
 0  R name="PPPoE-Out" max-mtu=auto max-mru=auto mrru=disabled interface=ether2 user="MT-User" 
      password="StrongPass" profile=default keepalive-timeout=10 service-name="pppoeservice" ac-name="" 
      add-default-route=no dial-on-demand=no use-peer-dns=no allow=pap,chap,mschap1,mschap2
PPPoE Server

To configure MikroTik RouterOS to be an Access Concentrator (PPPoE Server):

    add an IP address pool for the clients from 10.0.0.2-10.0.0.5;
    add PPP profile;
    add PPP secret (username/password);
    add the PPPoE server itself;

[admin@MikroTik] > /ip pool
add name=pppoe-pool ranges=10.0.0.2-10.0.0.5
[admin@MikroTik] > /ppp profile
add local-address=10.0.0.1 name=for-pppoe remote-address=pppoe-pool
[admin@MikroTik] > /ppp secret
add name=MT-User password=StrongPass profile=for-pppoe service=pppoe
[admin@MikroTik] > /interface pppoe-server server
add default-profile=for-pppoe disabled=no interface=ether3 service-name=pppoeservice




    Creado por Usuario desconocido (emils) el jun 15, 2022 1 min de lectura

    Summary
        Configuration
        Server
        Client
        Testing status

Summary

This example demonstrates how to set up PPPoE server and client to use IPv6 Prefix Delegation.

IPv6 Prefixes can be delegated over PPP interfaces. When client connects, PPP will automatically add dynamic DHCPv6-PD server. This allows to run DHCPv6 client on PPP interfaces.
Configuration
Server

dhcpv6-pd-pool parameter under PPP Profiles is used to enable PPP-PD. PPP will use specified IPv6 pool to create a dynamic DHCP server.

So first step is to add IPv6 pool:
/ipv6 pool
add name=myPool prefix=2001:db8:7501:ff00::/60 prefix-length=62

Now we can configure PPP profile and add PPPoE server
/ppp profile set default dhcpv6-pd-pool=myPool

/interface pppoe-server server 
add service-name=test interface=ether1
Client

On client side we need to set up PPPoE client interface and run DHCP client on it.
/interface pppoe-client
add name=client-test interface=ether1 user=a1 service-name=test

/ipv6 dhcp-client 
add interface=client-test pool-name=ppp-test pool-prefix-length=64
Testing status

On server side check if dynamic DHCP server is added and prefix is bound to specific client:
[admin@RB1100] /ipv6 dhcp-server> print 
Flags: D - dynamic, X - disabled, I - invalid 
 #    NAME              INTERFACE            ADDRESS-POOL            LEASE-TIME
 0 D  <pppoe-a1>        <pppoe-a1>           myPool                  3d        

[admin@RB1100] /ipv6 dhcp-server binding> print 
Flags: X - disabled, D - dynamic 
 #   ADDRESS                                        DU       IAID SER.. STATUS 
 1 D 2001:db8:7501:ff04::/62                                  247 <pp.. bound  
 

On client side, check if DHCP client is bound and pool is added:
[admin@x86-test] /ipv6 dhcp-client> print 
Flags: D - dynamic, X - disabled, I - invalid 
 #    INTERFACE           STATUS        PREFIX                            EXPIRES-AFTER  
0    client-test          bound         2001:db8:7501:ff04::/62           2d23h18m17s  

[admin@x86-test] /ipv6 pool> print 
Flags: D - dynamic 
 #   NAME                        PREFIX                                   PREFIX-LENGTH
 0 D ppp-test                    2001:db8:7501:ff04::/62                             64






    Creado por Usuario desconocido (emils), actualizado por última vez el jul 08, 2022 3 min de lectura

    Summary
    MLPPP over single link
        Configuration Example
    MLPPP over multiple links
        Configuration Example

Summary

Standards: RFC 1990

Multi-Link Point to Point Protocol (MP, Multi-Link PPP, MultiPPP or MLPPP) is a method of splitting, recombining, and sequencing data across multiple logical data links.

In a situation where we have multiple DSL links a pair of devices, performance by “widening the pipe” between two devices can be increased by using Multi-Link PPP, without going to a newer, more expensive technology.

Large packets are actually split into bits and sent evenly over ALL logical data links. This is done instantaneously with NO loss of bandwidth. It is important to understand that other end of the link needs to use the same protocol to recombine your data.

Multilink is based on an LCP option negotiation that allows to indicate to its peer that it is capable of combining multiple physical links.
MLPPP over single link

Typically size of the packet sent over PPP link is reduced due to overhead. MP can be used to transmit and receive full frame over single ppp link. To make it work the Multilink Protocol uses additional LCP configuration options Multilink Maximum Received Reconstructed Unit (MRRU)

To enable Multi-link PPP over single link you must specify MRRU (Maximum Receive Reconstructed Unit) option. If both sides support this feature there are no need for MSS adjustment (in firewall mangle). Study shows that MRRU is less CPU expensive that 2 mangle rules per client. MRRU allows to divide packet to multiple channels therefore increasing possible MTU and MRU (up to 65535 bytes)

Under Windows it can be enabled in Networking tag, Settings button, "Negotiate multi-link for single link connections". Their MRRU is hard coded to 1614.

MTU will be reduced by 4 bytes to work properly when MPPE encryption is enabled
Configuration Example

Let's configure pppoe server compatible with Windows clients and MRRU enabled.
[admin@RB800] /interface pppoe-server server> add service-name=myPPP interface=ether1 mrru=1614
[admin@RB800] /interface pppoe-server server> print 
Flags: X - disabled 
 0   service-name="myPPP" interface=ether1 max-mtu=1480 max-mru=1480 mrru=1614 
     authentication=pap,chap,mschap1,mschap2 keepalive-timeout=10 one-session-per-host=no 
     max-sessions=0 default-profile=default 
 

In short - standard PPP link - just specify MRRU in both sides.
MLPPP over multiple links

MLPPP over multiple links allow to create a single PPP link over multiple physical connections. All PPP links must come from the same server (server must have MLPPP over multiple links support) and all PPP links must have same user name and password.

And to enable MLPPP you just need to create PPP client and specify multiple interfaces instead of single interface. RouterOS has MLPPP client support only. Presently there are no MLPPP server support available.
Configuration Example

ISP gives to its client two physical links (DSL lines) 1Mbps each. To get aggregated 2Mbps pipe we have to set up MLPPP. Consider ISP router is pre-configured to support MLPPP.

Configuration on router (R1) is:
/interface pppoe-client 
   add service-name=ISP interface=ether1,ether2 user=xxx password=yyy disabled=no \
   add-default-route=yes use-peer-dns=yes
[admin@RB800] /interface pppoe-client> print 
Flags: X - disabled, R - running 
 0    name="pppoe-out1" max-mtu=1480 max-mru=1480 mrru=disabled interface=ether1,ether2 
      user="xxx" password="yyy" profile=default service-name="ISP" ac-name="" add-default-route=yes
      dial-on-demand=no use-peer-dns=yes allow=pap,chap,mschap1,mschap2  

Now when PPPoE client is connected we can set up rest of configuration, local network address, enable DNS requests, set up masquerade and firewall
/ip address add address=192.168.88.1/24 interface=local

/ip dns set allow-remote-request=yes

/ip firewall nat
add chain=src-nat action=masquerade out-interface=pppoe-out1

/ip firewall filter
add chain=input connection-state=invalid action=drop \
	comment="Drop Invalid connections"  
add chain=input connection-state=established action=accept \
	comment="Allow Established connections"  
add chain=input protocol=icmp action=accept \
	comment="Allow ICMP" 
add chain=input src-address=192.168.88.0/24 action=accept \
	in-interface=!pppoe-out1
add chain=input action=drop comment="Drop everything else"   

For more advanced router and customer protection check firewall examples.




    Creado por Artūrs C., actualizado por última vez por Oskars K. el dic 19, 2024 4 min de lectura

Overview

PPTP has many known security issues and we do not recommend using it. However, this protocol is integrated into common operating systems, and it is easy to set it up. PPTP can be useful in networks where security is not of concern.

IPv6 is not supported on this protocol.

PPTP traffic uses TCP port 1723 and IP protocol GRE (Generic Routing Encapsulation, IP protocol ID 47), as assigned by the Internet Assigned Numbers Authority (IANA). PPTP can be used with most firewalls and routers by enabling traffic destined for TCP port 1723 and protocol 47 traffic to be routed through the firewall or router.  PPTP includes PPP authentication and accounting for each PPTP connection. Full authentication and accounting of each connection may be done through a RADIUS client or locally.
PPTP Client
Properties
add-default-route (yes | no; Default: no)	Whether to add PPTP remote address as a default route.
allow (mschap2 | mschap1 | chap | pap; Default: mschap2, mschap1, chap, pap)	Allowed authentication methods.
connect-to (IP; Default: )	Remote address of PPTP server
default-route-distance (byte [0..255]; Default: 1)	sets distance value applied to auto created default route, if add-default-route is also selected
dial-on-demand (yes | no; Default: no)	connects to PPTP server only when outbound traffic is generated. If selected, then route with gateway address from 10.112.112.0/24 network will be added while connection is not established.
disabled (yes | no; Default: yes)	Whether interface is disabled or not. By default it is disabled
keepalive-timeout (integer; Default: 60)	Sets keepalive timeout in seconds.
max-mru (integer; Default: 1450)	Maximum Receive Unit. Max packet size that PPTP interface will be able to receive without packet fragmentation.
max-mtu (integer; Default: 1450)	Maximum Transmission Unit. Max packet size that PPTP interface will be able to send without packet fragmentation.
mrru (disabled | integer; Default: disabled)	Maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
name (string; Default: )	Descriptive name of the interface.
password (string; Default: "")	Password used for authentication.
profile (name; Default: default-encryption)	
user (string; Default: )	User name used for authentication.
PPTP Server
/interface pptp-server

An interface is created for each tunnel established to the given server. There are two types of interfaces in the PPTP server's configuration:

    Static interfaces are added administratively if there is a need to reference the particular interface name (in firewall rules or elsewhere) created for the particular user;
    Dynamic interfaces are added to this list automatically whenever a user is connected and its username does not match any existing static entry (or in case the entry is active already, as there can not be two separate tunnel interfaces referenced by the same name);

Dynamic interfaces appear when a user connects and disappear once the user disconnects, so it is impossible to reference the tunnel created for that use in router configuration (for example, in firewall), so if you need persistent rules for that user, create a static entry for him/her. Otherwise, it is safe to use a dynamic configuration.
In both cases PPP users must be configured properly - static entries do not replace PPP configuration.
Properties
authentication (pap | chap | mschap1 | mschap2; Default: mschap1,mschap2)	Authentication methods that server will accept.
default-profile (name; Default: default-encryption)	
enabled (yes | no; Default: no)	Defines whether PPTP server is enabled or not.
keepalive-timeout (time; Default: 30)	If server during keepalive period does not receive any packet, it will send keepalive packets every second five times. If the server does not receives response from the client, then disconnect after 5 seconds. Logs will show 5x "LCP missed echo reply" messages and then disconnect.
max-mru (integer; Default: 1450)	Maximum Receive Unit. Max packet size that PPTP interface will be able to receive without packet fragmentation.
max-mtu (integer; Default: 1450)	Maximum Transmission Unit. Max packet size that PPTP interface will be able to send without packet fragmentation.
mrru (disabled | integer; Default: disabled)	Maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
Example

PPTP Client

The following example demonstrates how to set up a PPTP client with username "MT-User", password "StrongPass" and server 192.168.62.2:


[admin@MikroTik] > interface pptp-client add connect-to=192.168.62.2 disabled=no name=pptp-out1 password=StrongPass user=MT-User
[admin@MikroTik] > interface pptp-client print 
Flags: X - disabled; R - running 
 0  R name="pptp-out1" max-mtu=1450 max-mru=1450 mrru=disabled connect-to=192.168.62.2 user="MT-User" 
      password="StrongPass" profile=default-encryption keepalive-timeout=60 add-default-route=no 
      dial-on-demand=no allow=pap,chap,mschap1,mschap2 
PPTP Server

On the other side we simply enable the PPTP server and create a PPP secret for a particular user:
[admin@MikroTik] >  interface pptp-server server set enabled=yes
[admin@MikroTik] >  ppp secret add local-address=10.0.0.1 name=MT-User password=StrongPass profile=default-encryption remote-address=10.0.0.5 service=pptp
[admin@MikroTik] >  interface pptp-server print
Flags: D - dynamic; R - running
Columns: NAME, USER, MTU, CLIENT-ADDRESS, UPTIME, ENCODING
#      NAME            USER     MTU  CLIENT-ADDRESS  UPTIM  ENCODING         
0  DR  <pptp-MT-User>  MT-User  1450  192.168.51.3   44m8s  MPPE128 stateless






    Creado por Artūrs C., actualizado por última vez por Oskars K. el ene 08, 2025 6 min de lectura

    Overview
    Introduction
    SSTP Client
        Properties
    SSTP Server
        Properties
    Certificates
        Certificate Error Messages
    Quick Example
        SSTP Client
        SSTP Server

Overview

Secure Socket Tunneling Protocol (SSTP) transports a PPP tunnel over a TLS channel. The use of TLS over TCP port 443 allows SSTP to pass through virtually all firewalls and proxy servers.
Introduction

Let's take a look at the SSTP connection mechanism:


    A TCP connection is established from client to server (by default on port 443);
    SSL validates the server certificate. If a certificate is valid, a connection is established otherwise the connection is turned down. (But see note below);
    The client sends SSTP control packets within the HTTPS session which establishes the SSTP state machine on both sides;
    PPP negotiation over SSTP. The client authenticates to the server and binds IP addresses to the SSTP interface;

SSTP tunnel is now established and packet encapsulation can begin;

Starting from v5.0beta2 SSTP does not require certificates to operate and can use any available authentication type. This feature will work only between two MikroTik routers, as it is not in accordance with Microsoft standards. Otherwise to establish secure tunnels mschap authentication and client/server certificates from the same chain should be used.

TLS SNI support has been added starting with 7.15beta10 version, Extension will be added to client hello packets if "Add SNI" checkbox is checked or set in CLI:

interface/sstp-client/set add-sni=yes
SSTP Client
Properties
authentication (chap, mschap1, mschap2, pap; Default: "all")	Allowed authentication methods, by default all methods are allowed.
disabled (yes | no; Default: yes)	Enables/disables tunnel.
add-default-route (yes | no; Default: no)	Whether to add L2TP remote address as a default route.
default-route-distance (byte; Default: )	Sets distance value applied to auto created default route, if add-default-route is also selected.
mrru (integer: 512..65535|disabled; Default: disabled)	maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
proxy-port (string; Default: 443 )	Sets proxy port.
add-sni (yes | no; Default: no)	Enables/disables service.
dial-on-demand (yes | no; Default: no)	Connects only when outbound traffic is generated. If selected, then route with gateway address from 10.112.112.0/24 network will be added while connection is not established.
name (string; Default: )	Descriptive name of the interface.
tls-version (any | only-1.2; Default: any)	Specifies which TLS version to allow.
numbers (integer;)	Sets number for an tunnel in ROS.
user (string; Default: )	User name used for authentication.
certificate (string | none; Default: none)	Name of the client certificate
http-proxy (string; Default: )	Proxy address field.
password (string; Default: "")	Password used for authentication.
verify-server-address-from-certificate (yes|no; Default: no)	SSTP client will verify server address in certificate.
verify-server-certificate (yes|no; Default: no)	SSTP client will verify server certificate.
ciphers (aes256-gcm-sha384 | aes256-sha; Default: all)	Allowed ciphers.
keepalive-timeout (integer; Default:60)	Sets keepalive timeout in seconds.
pfs (yes | no | required ; Default: no)	Specifies which TLS authentication to use. With pfs=yes, TLS will use ECDHE-RSA- and DHE-RSA-. For maximum security setting pfs=required will use only ECDHE.
comment (string; Default: )	Short description of the tunnel.
max-mru (integer; Default: 1460)	Maximum Receive Unit.
max-mtu (integer; Default: 1460)	Maximum Transmission Unit.
port (integer; Default: 443)	Port to connect to.
connect-to (IP|IPv6; Default: )	Remote address of the SSTP server.
profile (name; Default: default)	Specifies which PPP profile configuration will be used when establishing the tunnel.
SSTP Server
Properties
authentication (chap, mschap1, mschap2, pap; Default: "all")	Allowed authentication methods, by default all methods are allowed.
keepalive-timeout (integer; Default:60)	Sets keepalive timeout in seconds.
port (string; Default: 443 )	Sets port used.
certificate (string | none; Default: none)	Name of the certificate in use.
max-mru (integer; Default: 1460)	Maximum Receive Unit.
max-mtu (integer; Default: 1460)	Maximum Transmission Unit.
tls-version (any | only-1.2; Default: any)	Specifies which TLS version to allow.
ciphers (aes256-gcm-sha384 | aes256-sha; Default: all)	Allowed ciphers.
verify-client-certificate (yes|no; Default: no)	SSTP server will verify client certificate.
mrru (integer: 512..65535|disabled; Default: disabled)	maximum packet size that can be received on the link. If a packet is bigger than tunnel MTU, it will be split into multiple packets, allowing full size IP or Ethernet packets to be sent over the tunnel.
default-profile (name; Default: default)	Specifies which PPP profile configuration will be used when establishing the tunnel.
enabled (yes | no; Default: no)	Enables/disables service.
pfs (yes | no | required ; Default: no)	Specifies which TLS authentication to use. With pfs=yes, TLS will use ECDHE-RSA- and DHE-RSA-. For maximum security setting pfs=required will use only ECDHE.
Certificates

To set up a secure SSTP tunnel, certificates are required. On the server, authentication is done only by username and password, but on the client - the server is authenticated using a server certificate. It is also used by the client to cryptographically bind SSL and PPP authentication, meaning - the clients send a special value over SSTP connection to the server, this value is derived from the key data that is generated during PPP authentication and server certificate, this allows the server to check if both channels are secure.

If SSTP clients are on Windows PCs then the only way to set up a secure SSTP tunnel when using a self-signed certificate is by importing the "server" certificate on the SSTP server and on the Windows PC adding a CA certificate in the trusted root.

If your server certificate is issued by a CA which is already known by Windows, then the Windows client will work without any additional certificate imports to a trusted root.

RSA key length must be at least 472 bits if a certificate is used by SSTP. Shorter keys are considered as security threats.


A similar configuration on RouterOS client would be to import the CA certificate and enabling the verify-server-certificate option. In this scenario, Man-in-the-Middle attacks are not possible.

Between two Mikrotik routers, it is also possible to set up an insecure tunnel by not using certificates at all. In this case, data going through the SSTP tunnel is using anonymous DH and Man-in-the-Middle attacks are easily accomplished. This scenario is not compatible with Windows clients.

It is also possible to make a secure SSTP tunnel by adding additional authorization with a client certificate. Configuration requirements are:

    certificates on both server and client
    verification options enabled on server and client

This scenario is also not possible with Windows clients, because there is no way to set up a client certificate on Windows.
Certificate Error Messages

When SSL handshake fails, you will see one of the following certificate errors:

    certificate is not yet valid - notBefore certificate date is after the current time;
    certificate has expired - certificate expiry date is before the current time;
    cinvalid certificate purpose - the supplied certificate cannot be used for the specified purpose;
    cself signed certificate in a chain - the certificate chain could be built up using the untrusted certificates but the root could not be found locally;
    cunable to get issuer certificate locally - CA certificate is not imported locally;
    cserver's IP address does not match certificate - server address verification is enabled, but the address provided in certificate does not match the server's address;

Quick Example

SSTP Client

In the following configuration example, e will create a simple SSTP client without using a certificate:
[admin@MikroTik > interface sstp-client add connect-to=192.168.62.2 disabled=no name=sstp-out1 password=StrongPass profile=default-encryption user=MT-User
[admin@MikroTik > interface sstp-client print
Flags: X - disabled; R - running 
 0  R name="sstp-out1" max-mtu=1500 max-mru=1500 mrru=disabled connect-to=192.168.62.2:443 
      http-proxy=0.0.0.0:443 certificate=none verify-server-certificate=no 
      verify-server-address-from-certificate=yes user="MT-User" password="StrongPass" 
      profile=default-encryption keepalive-timeout=60 add-default-route=no dial-on-demand=no 
      authentication=pap,chap,mschap1,mschap2 pfs=no tls-version=any
SSTP Server

We will configure PPP secret for a particular user, afterwards simply enable an SSTP server:
[admin@MikroTik] > ppp secret add local-address=10.0.0.1 name=MT-User password=StrongPass remote-address=10.0.0.5 service=sstp
[admin@MikroTik] > interface sstp-server server set default-profile=default-encryption enabled=yes
[admin@MikroTik] > interface sstp-server server print
                    enabled: yes
                       port: 443
                    max-mtu: 1500
                    max-mru: 1500
                       mrru: disabled
          keepalive-timeout: 60
            default-profile: default-encryption
             authentication: pap,chap,mschap1,mschap2
                certificate: none
  verify-client-certificate: no
                        pfs: no
                tls-version: any

In P2P setups network address will be same with other endpoint local address. 

As with any other ppp tunnel, SSTP also supports BCP which allows it to bridge SSTP tunnel with a local interface. For example in setups where routers are connected to Internet through ether1, workstations and laptops are connected to ether2. Both local networks are routed through SSTP client, and they are not in the same broadcast domain BCP is used.







    Creado por Usuario desconocido (emils), actualizado por última vez por Oskars K. el jun 05, 2025 9 min de lectura

Introduction

    Introduction
    Properties
        Read-only properties
    Peers
    Importing, Exporting Wireguard
        Read-only properties
    Application examples
        Site to Site WireGuard tunnel
            WireGuard interface configuration
            Peer configuration
            IP and routing configuration
            Firewall considerations
    RoadWarrior WireGuard tunnel
        RouterOS configuration
        iOS configuration
        Windows 10 configuration

WireGuard® is an extremely simple yet fast and modern VPN that utilizes state-of-the-art cryptography. It aims to be faster, simpler, leaner, and more useful than IPsec while avoiding massive headaches. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general-purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. Initially released for the Linux kernel, it is now cross-platform (Windows, macOS, BSD, iOS, Android) and widely deployable.
Properties
comment (string; Default: )	Short description of the tunnel.
disabled (yes | no; Default: no)	Enables/disables the tunnel.
listen-port (integer; Default: 13231)	Port for WireGuard service to listen on for incoming sessions.
mtu (integer [0..65536]; Default: 1420)	Layer3 Maximum transmission unit.
name (string; Default: )	Name of the tunnel.
private-key (string; Default: )	A base64 private key. If not specified, it will be automatically generated upon interface creation. Each network interface has a private key and a list of peers. 
Read-only properties
public-key (string)	A base64 public key is calculated from the private key. Each peer has a public key. Public keys are used by peers to authenticate each other. They can be passed around for use in configuration files.
running (yes | no)	

Whether the interface is running.
Peers
Property	Description
allowed-address (IP/IPv6 prefix; Default: )	List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. This IP address has to be in the same subnet as WireGuard interface set on ROS. If WireGuard interface is at 192.168.99.1/24, You have to input 192.168.99.2 to the client. By adding this IP under 'Allowed Address', you are saying that only this specific client (phone for example) is permitted to connect to this peer configuration. Allowed-address range cannot overlap on one interface, so you need to set own range for each peer.
comment (string; Default: )	Short description of the peer.
disabled (yes | no; Default: no)	Enables/disables the peer.
endpoint-address (IP/Hostname; Default: )	The IP address or hostname. It is used by WireGuard to establish a secure connection between two peers.
endpoint-port (integer:0..65535; Default: )	The Endpoint port is the UDP port on which a WireGuard peer listens for incoming traffic.
interface (string; Default: )	Name of the WireGuard interface the peer belongs to.
persistent-keepalive (integer:0..65535; Default: 0)	A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
preshared-key (string; Default: )	A base64 preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance. Also can be generated automatically or entered manually, when the key is provided by the system administrator.
private-key (auto/none; Default: none)	A base64 private key.

public-key (string; Default: )
	

A base64 public key is calculated from the private key. Each peer has a public key. Public keys are used by peers to authenticate each other. They can be passed around for use in configuration files.

show-client-config 
	

 Will show already created Peer configuration and generate a QR code for easier peer setup on a client device. Does not affect the WireGuard Server.

Used for the client-server setup scenario, when the configuration is imported using a qr code for a client, configuration details on tab with qrcode will appear once it has been set in the fields:

client-address (IP/IPv6 prefix; Default: )
	

When imported using a qr code for a client (for example, a phone), then this address for the wg interface is set on that device.

client-dns (IP/IPv6 prefix; Default: )
	

Specify when using WireGuard Server as a VPN gateway for peer traffic.

client-endpoint (IP/IPv6 prefix; Default: )
	

The IP address and port number of the WireGuard Server.

client-keepalive (integer:0..65535; Default: 0)
	

Same as persistent-keepalive but from peer side.

client-listen-port (integer:0..65535; Default: )
	

The local port upon which this WireGuard tunnel will listen for incoming traffic from peers, and the port from which it will source outgoing packets.

name (string; Default: )
	

Allows adding name to a peer. Name will be used as a reference for a peer in WireGuard logs. (Available from RouterOS version 7.15)

responder (yes | no; Default: no)
	

Specifies if peer is intended to be connection initiator or only responder. Should be used on WireGuard devices that are used as "servers" for other devices as clients to connect to. Otherwise router will all repeatedly try to connect "endpoint-address" or "current-endpoint-address".

*AllowedIPs  configuration that is provided to the client through WireGuard peer export (configuration file or QR code) can not be changed and will be "0.0.0.0/0, ::/0" at the moment. If it is necessary to change these values on remote end, then that is up to the remote peer software used for WireGuard connection.
Importing, Exporting Wireguard

Configuration can be done in various ways, here is simple wg import file example: export

Minimum parameters must be specified for importing on the client device by QR-code/file.

Example:

interface: wireguard1
public-key: v/oIzPyFm1FPHrqhytZgsKjU7mUToQHLrW+Tb5e601M=
private-key: KMwxqe/iXAU8Jn9dd1o5pPdHep2blGxNWm9I944/I24=
allowed-address: 192.168.88.3/24
client-address: 192.168.88.3/32
client-endpoint: example.com:13231

When using interface/wireguard/wg-import file=, you may get Could not parse error, if Wireguard import file starts with #, use it clean as per example:

[Interface]
Address =192.168.88.3/24
ListenPort = 13533
PrivateKey = UBLqJEFZZf9wszZSUF2BPWa9dsMX99RbEcxlNfxWffk=

Starting from 7.19_ab41, config-string parameter has been added, for example using this cli command you can import your configuration:

/interface wireguard/wg-import config-string="
[Interface]
Address =192.168.88.3/24
ListenPort = 13533
PrivateKey = UBLqJEFZZf9wszZSUF2BPWa9dsMX99RbEcxlNfxWffk=
[Peer]
PublicKey = EoF7HlFu3fbOnuYbyGqLMJkPZgQk9n3WwONZuJZ6qWc=
Endpoint = 199.168.100.10:51820
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25"

Read-only properties
current-endpoint-address (IP/IPv6)	The most recent source IP address of correctly authenticated packets from the peer.
current-endpoint-port (integer)	The most recent source IP port of correctly authenticated packets from the peer.
last-handshake (integer)	Time in seconds after the last successful handshake.
rx (integer)	The total amount of bytes received from the peer.
tx (integer)	The total amount of bytes transmitted to the peer.

When you encounter issues with reply traffic having the wrong source address, using NAT to translate packet source addresses to your loopback interface is a common workaround. This approach helps ensure that the source address is consistent and correct when packets are routed back through the network.
Application examples
Site to Site WireGuard tunnel

Consider setup as illustrated below. Two remote office routers are connected to the internet and office workstations are behind NAT. Each office has its own local subnet, 10.1.202.0/24 for Office1 and 10.1.101.0/24 for Office2. Both remote offices need secure tunnels to local networks behind routers.

WireGuard interface configuration

First of all, WireGuard interfaces must be configured on both sites to allow automatic private and public key generation. The command is the same for both routers:
/interface/wireguard
add listen-port=13231 name=wireguard1

Now when printing the interface details, both private and public keys should be visible to allow an exchange.

Any private key will never be needed on the remote side device - hence the name private.

Office1
/interface/wireguard print 
Flags: X - disabled; R - running 
 0  R name="wireguard1" mtu=1420 listen-port=13231 private-key="yKt9NJ4e5qlaSgh48WnPCDCEkDmq+VsBTt/DDEBWfEo=" 
      public-key="u7gYAg5tkioJDcm3hyS7pm79eADKPs/ZUGON6/fF3iI=" 

Office2
/interface/wireguard/print 
Flags: X - disabled; R - running 
 0  R name="wireguard1" mtu=1420 listen-port=13231 private-key="KMwxqe/iXAU8Jn9dd1o5pPdHep2blGxNWm9I944/I24=" 
      public-key="v/oIzPyFm1FPHrqhytZgsKjU7mUToQHLrW+Tb5e601M=" 
Peer configuration

Peer configuration defines who can use the WireGuard interface and what kind of traffic can be sent over it. To identify the remote peer, its public key must be specified together with the created WireGuard interface.

Office1
/interface/wireguard/peers
add allowed-address=10.1.101.0/24,10.255.255.1/32 endpoint-address=192.168.80.1 endpoint-port=13231 interface=wireguard1 \
public-key="v/oIzPyFm1FPHrqhytZgsKjU7mUToQHLrW+Tb5e601M="

Office2
/interface/wireguard/peers
add allowed-address=10.1.202.0/24,10.255.255.2/32 endpoint-address=192.168.90.1 endpoint-port=13231 interface=wireguard1 \
public-key="u7gYAg5tkioJDcm3hyS7pm79eADKPs/ZUGON6/fF3iI="
IP and routing configuration

Lastly, IP and routing information must be configured to allow traffic to be sent over the tunnel.

Office1
/ip/address
add address=10.255.255.1/30 interface=wireguard1
/ip/route
add dst-address=10.1.101.0/24 gateway=wireguard1

Office2
/ip/address
add address=10.255.255.2/30 interface=wireguard1
/ip/route
add dst-address=10.1.202.0/24 gateway=wireguard1
Firewall considerations

The default RouterOS firewall will block the tunnel from establishing properly. The traffic should be accepted in the "input" chain before any drop rules on both sites.

Office1
/ip/firewall/filter
add action=accept chain=input dst-port=13231 protocol=udp src-address=192.168.80.1

Office2
/ip/firewall/filter
add action=accept chain=input dst-port=13231 protocol=udp src-address=192.168.90.1

Additionally, it is possible that the "forward" chain restricts the communication between the subnets as well, so such traffic should be accepted before any drop rules as well.

Office1
/ip/firewall/filter
add action=accept chain=forward dst-address=10.1.202.0/24 src-address=10.1.101.0/24
add action=accept chain=forward dst-address=10.1.101.0/24 src-address=10.1.202.0/24

Office2
/ip/firewall/filter
add action=accept chain=forward dst-address=10.1.101.0/24 src-address=10.1.202.0/24
add action=accept chain=forward dst-address=10.1.202.0/24 src-address=10.1.101.0/24
RoadWarrior WireGuard tunnel
RouterOS configuration

Add a new WireGuard interface and assign an IP address to it.
/interface wireguard
add listen-port=13231 name=wireguard1
/ip address
add address=192.168.100.1/24 interface=wireguard1

Adding a new WireGuard interface will automatically generate a pair of private and public keys. You will need to configure the public key on your remote devices. To obtain the public key value, simply print out the interface details.
[admin@home] > /interface wireguard print 
Flags: X - disabled; R - running 
 0  R name="wireguard1" mtu=1420 listen-port=13231 private-key="cBPD6JNvbEQr73gJ7NmwepSrSPK3np381AWGvBk/QkU=" 
      public-key="VmGMh+cwPdb8//NOhuf1i1VIThypkMQrKAO9Y55ghG8=" 

For the next steps, you will need to figure out the public key of the remote device. Once you have it, add a new peer by specifying the public key of the remote device and allowed addresses that will be allowed over the WireGuard tunnel.
/interface wireguard peers
add allowed-address=192.168.100.2/32 interface=wireguard1 public-key="<paste public key from remote device here>"

Firewall considerations

If you have default or strict firewall configured, you need to allow remote device to establish the WireGuard connection to your device.
/ip firewall filter
add action=accept chain=input comment="allow WireGuard" dst-port=13231 protocol=udp place-before=1

To allow remote devices to connect to the RouterOS services (e.g. request DNS), allow the WireGuard subnet in input chain.
/ip firewall filter
add action=accept chain=input comment="allow WireGuard traffic" src-address=192.168.100.0/24 place-before=1

Or simply add the WireGuard interface to "LAN" interface list.
/interface list member
add interface=wireguard1 list=LAN
iOS configuration

Download the WireGuard application from the App Store. Open it up and create a new configuration from scratch.

First of all give your connection a "Name" and choose to generate a keypair. The generated public key is necessary for peer's configuration on RouterOS side.


Specify an IP address in "Addresses" field that is in the same subnet as configured on the server side. This address will be used for communication. For this example, we used 192.168.100.1/24 on the RouterOS side, you can use 192.168.100.2 here.

If necessary, configure the DNS servers. If allow-remote-requests is set to yes under IP/DNS section on the RouterOS side, you can specify the remote WireGuard IP address here.


Click "Add peer" which reveals more parameters.

The "Public key" value is the public key value that is generated on the WireGuard interface on RouterOS side.

"Endpoint" is the IP or DNS with port number of the RouterOS device that the iOS device can communicate with over the Internet.

"Allowed IPs" are set to 0.0.0.0/0 to allow all traffic to be sent over the WireGuard tunnel.

Depending on your configuration, you may need to add a NAT rule
chain=dstnat action=dst-nat to-ports=port protocol=udp in-interface=interface dst-port=port
Windows 10 configuration

Download WireGuard installer from Wireguard
Run as Administrator.

Press Ctrl+n to add new empty tunnel, add name for interface, Public key should be auto generated copy it to RouterOS peer configuration.
Add to server configuration, so full configuration looks like this (keep your auto generated PrivateKey in [Interface] section:
[Interface]
PrivateKey = your_autogenerated_private_key=
Address = 192.168.100.2/24
DNS = 192.168.100.1

[Peer]
PublicKey = your_MikroTik_public_KEY=
AllowedIPs = 0.0.0.0/0
Endpoint = example.com:13231


Save and Activate




    Creado por Normunds R., actualizado por última vez por Oskars K. el ene 08, 2025 9 min de lectura

    Introduction
        Video tutorial
    Required Network Configuration
        What ports does ZeroTier use?
        Recommended Local Network and Internet Gateway Configuration
    Configuration example
        Peer
    Parameters
    Controller
        Parameters
        Configuration example
            RouterOS Home
            RouterOS Office
            Other devices

Introduction

The ZeroTier network hypervisor is a self-contained network virtualization engine that implements an Ethernet virtualization layer similar to VXLAN built atop a cryptographically secure global peer-to-peer network. It provides advanced network virtualization and management capabilities on par with an enterprise SDN switch, but across both local and wide area networks and connecting almost any kind of app or device.

MikroTik has added ZeroTier to RouterOS v7.1rc2 as a separate package for the ARM/ARM64 architecture. 

Zerotier has been upgraded to 1.14.0 on 7.17rc6 ROS version.

Wait, so what can I use it for?

    Hosting a game server at home (useful for LAN only games) or simply creating a LAN party with your friends;
    Accessing LAN devices behind NAT directly;
    Accessing LAN devices via SSH without opening port to the Internet;
    Using your local Pi-Hole setup from anywhere via the Internet;

Video tutorial

    ZeroTier

Required Network Configuration
What ports does ZeroTier use?

It listens on three 3 UDP ports:

    9993 - The default
    A random, high numbered port derived from your ZeroTier address
    A random, high numbered port for use with UPnP/NAT-PMP mappings

That means your peers could be listening on any port. To talk with them directly, you need to be able to send them to any port.
Recommended Local Network and Internet Gateway Configuration

These ZeroTier recommended guidelines are consistent with the vast majority of typical deployments using commodity gateways and access points:

    Don't restrict outbound UDP traffic.
    Supporting either UPnP or NAT-PMP on your network can greatly improve performance by allowing ZeroTier endpoints to map external ports and avoid NAT traversal entirely.
    IPv6 is recommended and can greatly improve direct connection reliability if supported on both ends of a direct link. If present it should be implemented without NAT (NAT is wholly unnecessary with IPv6 and only adds complexity) and with a stateful firewall that permits bidirectional UDP conversations.
    Don't use "symmetric" NAT. Use "full cone" or "port restricted cone" NAT. Symmetric NAT is extremely hostile to peer-to-peer traffic and will degrade VoIP, video chat, games, WebRTC, and many other protocols as well as ZeroTier.
    No more than one layer of NAT should be present between ZeroTier endpoints and the Internet. Multiple layers of NAT introduce connection instability due to chaotic interactions between states and behaviors at different levels. No Double NAT.
    NATs should have a port mapping or connection timeout no shorter than 60 seconds.
    Place no more than about 16,000 devices behind each NAT-managed external IP address to ensure that each device can map a sufficient number of ports.
    Switches and wireless access points should allow direct local traffic between local devices. Turn off any "local isolation" features. Some switches might allow finer-grained control, and on these, it would be sufficient to allow local UDP traffic to/from 9993 (or in general).

Configuration example

By default, ZeroTier is designed to be zero-configuration. A user can start a new ZeroTier node without having to write configuration files or provide the IP addresses of other nodes. It’s also designed to be fast. Any two devices in the world should be able to locate each other and communicate almost instantly so the following example will enable ZeroTier on RouterOS device and connect one mobile phone using the ZeroTier application.


    Register on my.zerotier.com and Create A Network, obtain the Network ID, in this example: 1d71939404912b40;
    Download and Install ZeroTier NPK package in RouterOS, you can find under in the "Extra packages", upload package on the device and reboot the unit;

    Enable the default (official) ZeroTier instance:

[admin@mikrotik] > zerotier/enable zt1

Add a new network, specifying the network ID you created in the ZeroTier cloud console:
[admin@mikrotik] zerotier/interface/add network=1d71939404912b40 instance=zt1

Verify ZeroTier configuration:
[admin@MikroTik] > zerotier/interface/print
Flags: R - RUNNING
Columns: NAME, MAC-ADDRESS, NETWORK, NETWORK-NAME, STATUS
#   NAME       MAC-ADDRESS        NETWORK           NETWORK-NAME     STATUS
0 R zerotier1  42:AC:0D:0F:C6:F6  1d71939404912b40  modest_metcalfe  OK   

Now you might need to allow connections from the ZeroTier interface to your router, and optionally, to your other LAN interfaces: 
/ip firewall filter add action=accept chain=forward in-interface=zerotier1 place-before=0
/ip firewall filter add action=accept chain=input in-interface=zerotier1 place-before=0
Install a ZeroTier client on your smartphone or computer, follow the ZeroTier manual on how to connect to the same network from there.
If "Access Control" is set to "Private", you must authorize nodes before they become members:

    [admin@MikroTik] > ip/address/print where interface~"zero"
    Flags: D - DYNAMIC
    Columns: ADDRESS, NETWORK, INTERFACE
    #   ADDRESS             NETWORK        INTERFACE
    3 D 192.168.192.105/24  192.168.192.0  zerotier1

    [admin@MikroTik] > ping 192.168.192.252 count=3
    SEQ HOST                                     SIZE TTL TIME       STATUS                                                                                                                                           
    0 192.168.192.252                            56  64 407us     
    1 192.168.192.252                            56  64 452us     
    2 192.168.192.252                            56  64 451us     
    sent=3 received=3 packet-loss=0% min-rtt=407us avg-rtt=436us max-rtt=452us 

You should specify routes to specific internal subnets in the ZeroTier cloud console, to make sure you can access those networks when connecting from other devices. 
Peer
zerotier/peer/

ZeroTier`s peer is an informative section with a list of nodes that your node knows about. Nodes can not talk to each other unless they are joined and authorized on the same network.
[admin@Home] > zerotier/peer/print 
Columns: INSTANCE, ZT-ADDRESS, LATENCY, ROLE, PATH
# INSTANCE  ZT-ADDRESS  LATENCY  ROLE    PATH                                                            
0 zt1       61d294b9cb  186ms    PLANET  active,preferred,50.7.73.34/9993,recvd:4s526ms                  
1 zt1       62f865ae71  270ms    PLANET  active,preferred,50.7.252.138/9993,recvd:4s440ms,sent:9s766ms   
2 zt1       778cde7190  132ms    PLANET  active,preferred,103.195.103.66/9993,recvd:4s579ms,sent:9s766ms 
3 zt1       992fcf1db7  34ms     PLANET  active,preferred,195.181.173.159/9993,recvd:4s675ms,sent:4s712ms
4 zt1       159924d630  130ms    LEAF    active,preferred,34.121.192.xx/21002,recvd:3s990ms,sent:3s990ms
Parameters
[admin@MikroTik] > zerotier/
name (string; default: zt1)	Instance name.
port (number; default: 9993)	Port number the instance listen to.
identity (string; default)	Instance 40-bit unique address.
interface (string; default: all)	List of interfaces that are used in order to discover ZeroTier peers, by using ARP and IP type connections.
route-distance (number; default: 1 )	Route distance for routes obtained from planet/moon servers.
[admin@MikroTik] > zerotier/interface/
allow-default (string; yes | no)	A network can override the systems default route (force VPN mode).
allow-global (string; yes | no)	 ZeroTier IP addresses and routes can overlap public IP space.
allow-managed (string; yes | no)	ZeroTier managed IP addresses and routes are assigned.
arp-timeout ( number; default: auto)	ARP timeouts value.
comment (string; Default: )	Descriptive comment for the interfaces.
copy-from 	Allows copying existing interfaces configuration.
disable-running-check (string; yes | no)	Force interface in "running" state.
instance (string; Default: zt1)	ZeroTier instance name.
name (string; default: zerotier1)	A short name.
network (string; Default)	16-digit network ID.
Controller


RouterOS implements ZeroTier functionality in the role of a node where most of the network configuration must be done on the ZeroTier webpage dashboard. However, in situations where you would prefer to do all the configuration on your own device, RouterOS offers to host your own controller

A common misunderstanding is to conflate network controllers with root servers (planet and moons). Root servers are connection facilitators that operate at the VL1 level. Network controllers are configuration managers and certificate authorities that belong to the VL2 level. Generally, root servers don’t join or control virtual networks and network controllers are not root servers, though it is possible to have a node do both.
/zerotier/controller/

Every ZeroTier instance has a self-hosting network controller that can be used to host virtual networks. A controller is responsible for admitting members to the network, and issuing default configuration information including certificates. Controllers can in theory host up to 2^24 networks and serve many millions of devices (or more), but we recommend spreading large numbers of networks across many controllers for load balancing and fault tolerance reasons.
Parameters
broadcast  ( yes | no; Default: yes)	Allow receiving broadcast (FF:FF:FF:FF:FF:FF) packets.
comment (string; Default: )	Descriptive comment for the controller.

copy-from (string; Default: )
	Copies an existing item. It takes default values of a new item's properties from another item. If you do not want to make an exact copy, you can specify new values for some properties. When copying items that have names, you will usually have to give a new name to a copy.
instance (string; Default: zt1)	ZeroTier instance name.
ip-range (IP; Default: )	IP range, for example, 172.16.16.1-172.16.16.254.
 ip6-6plane ( yes | no; Default: no)	An option gives every member a /80 within a /40 network but uses NDP emulation to route all IPs under that /80 to their owner. The 6plane mode is great for use cases like Docker since it allows every member to assign IPv6 addresses within its /80 that just work instantly and globally across the network.
ip6-rfc4193 ( yes | no; Default: no)	The rfc4193 mode gives every member a /128 on a /88 network.
ip6-range (IPv6; Default: )	IPv6 range, for example fd00:feed:feed:beef::-fd00:feed:feed:beef:ffff:ffff:ffff:ffff.
mtu (integer; Default: 2800)	Network MTU.
multicast-limit (integer: Default: 32)	Maximum recipients for a multicast packet.
name (string; Default: )	A short name for this controller.
network (string; Default)	16-digit network ID.
private ( yes | no; Default: yes)	Enables access control.
routes (IP@GW; Default: )	Push routes in the following format:
Routes ::= Route[,Routes]
  Route ::= Dst[@Gw]
Configuration example

In the following example, we will use RouterOS built-in ZeroTier controller to send our new network hosts appropriate certificates, credentials, and configuration information. The controller will operate from the "RouterOS Home" device and we will join in our network 3 units: mobile phone, laptop, RouterOS Office device, but theoretically, you can join up to 100 devices in one network.

RouterOS Home

First, we enable the default instance which operates at the VL1 level :
[admin@Home] /zerotier> print
Columns: NAME, PORT, IDENTITY.PUBLIC
# NAME  PORT  IDENTITY.PUBLIC                                                                                                                              
;;; ZeroTier Central controller - https://my.zerotier.com/
0 zt1   9993  879c0b5265:0:d5fd2d17805e011d9b93ce8779385e427c8f405e520eea9284809d8444de0335a817xxb21aa4ba153bfbc229ca34d94e08de96d925a4aaa19b252da546693a28

Now we create a new network via the controller section which will operate at the VL2 level. Each network has its own controller and each network ID is generated from the controller address and controller ID combination.

Note that we use the private=yes option for a more secure network:
[admin@Home] /zerotier> controller/add name=ZT-private instance=zt1 ip-range=172.27.27.10-172.27.27.20 private=yes routes=172.27.27.0/24
[admin@Home] /zerotier> controller/print
Columns: INSTANCE, NAME, NETWORK, PRIVATE
# INSTANCE  NAME        NETWORK           PRIVATE
0 zt1       ZT-private  879c0b5265a99e4b  yes

Add our new network under the interface section:
[admin@Home] /zerotier> interface/add network=879c0b5265a99e4b name=myZeroTier instance=zt1 
[admin@Home] /zerotier> interface/print interval=1
Columns: NAME, MAC-ADDRESS, NETWORK, STATUS
# NAME        MAC-ADDRESS        NETWORK           STATUS       
0 myZeroTier  4A:19:35:6E:00:6E  879c0b5265a99e4b  ACCESS_DENIED

Each new peer asks for a controller to join the network, in this situation, we have ACCESS_DENIED status and we have to authorize a new peer, that is because we used the private=yes option.

After authorization, each member in the network receives information from the controller about new peers and approval they can exchange packets with them:
[admin@Home] /zerotier> controller/member/print
Columns: NETWORK, ZT-ADDRESS
#  NETWORK     ZT-ADDRESS
0  ZT-private  879a0b5265
[admin@Home] /zerotier> controller/member/set 0 authorized=yes

Verify newly configured IP address and route:
[admin@Home] /zerotier> /ip/address/print where interface~"Zero"
Flags: D - DYNAMIC
Columns: ADDRESS, NETWORK, INTERFACE
#   ADDRESS          NETWORK      INTERFACE 
4 D 172.27.27.15/24  172.27.27.0  myZeroTier

[admin@Home] /zerotier> /ip/route/pr where gateway~"Zero"
Flags: D - DYNAMIC; A - ACTIVE; c, y - COPY
Columns: DST-ADDRESS, GATEWAY, DISTANCE
    DST-ADDRESS     GATEWAY     DISTANCE
DAc 172.27.27.0/24  myZeroTier         0
RouterOS Office

Configuration on the Office device. We will enable the default instance and ask a controller to join the 879c0b5265a99e4b network:
[admin@office] /zerotier> interface/add network=879c0b5265a99e4b instance=zt1 name=ZT-interface 
[admin@office] /zerotier> interface/print interval=1
Columns: NAME, MAC-ADDRESS, NETWORK, STATUS
# NAME          MAC-ADDRESS        NETWORK           STATUS       
0 ZT-interface  4A:40:1C:38:97:BA  879c0b5265a99e4b  ACCESS_DENIED

As previously, because our network is private, we have to authorize a new peer via "RouterOS home device". After that verify from controller received IP address and route:
[admin@Home] /zerotier> controller/member/print
Flags: A - AUTHORIZED
Columns: NETWORK, ZT-ADDRESS, IP-ADDRESS, LAST-SEEN
#    NETWORK     ZT-ADDRESS  IP-ADDRESS    LAST-SEEN
0 A  ZT-private  879a0b5265  172.27.27.15           
1 A  ZT-private  554a914c7f  172.27.27.17           
2 A  ZT-private  a83ac6032a  172.27.27.10           
3    ZT-private  deba5dc5b1  172.27.27.13  3s348ms  
[admin@Home] /zerotier> controller/member/set 3 authorized=yes
[admin@Home] /zerotier> controller/member/print               
Flags: A - AUTHORIZED
Columns: NETWORK, ZT-ADDRESS, IP-ADDRESS, LAST-SEEN
#    NETWORK     ZT-ADDRESS  IP-ADDRESS    LAST-SEEN
0 A  ZT-private  879a0b5265  172.27.27.15           
1 A  ZT-private  554a914c7f  172.27.27.17           
2 A  ZT-private  a83ac6032a  172.27.27.10           
3 A  ZT-private  deba5dc5b1  172.27.27.13  4s55ms 

Verify via ZeroTier obtained IP address and route:
[admin@office] /zerotier> /ip/address/print where interface~"ZT"
Flags: D - DYNAMIC
Columns: ADDRESS, NETWORK, INTERFACE
#   ADDRESS          NETWORK      INTERFACE   
0 D 172.27.27.13/24  172.27.27.0  ZT-interface

[admin@office] /zerotier> /ip/route/print where gateway~"ZT"
Flags: D - DYNAMIC; A - ACTIVE; c, y - COPY
Columns: DST-ADDRESS, GATEWAY, DISTANCE
    DST-ADDRESS     GATEWAY       DISTANCE
DAc 172.27.27.0/24  ZT-interface         0
Other devices


Download the ZeroTier app for your mobile phone or computer and join your newly created network:

1) Via our Laptop ZeroTier application we join the 879c0b5265a99e4b network;

2) User Zerotier mobile app to join the 879c0b5265a99e4b network;

Also all other new hosts you have to authorize under the /zerotier/controller/member/ section.



