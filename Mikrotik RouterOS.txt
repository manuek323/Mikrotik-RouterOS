Firewall and Quality of Service

    Creado por Usuario desconocido (emils), actualizado por última vez por Māris B. el may 24, 2024 1 min de lectura

In This Section:

        Connection tracking
        Firewall
        Packet Flow in RouterOS
        Queues
        Firewall and QoS Case Studies
        Kid Control
        UPnP
        NAT-PMP
        IP Services








    Creado por Artūrs C., actualizado por última vez por Mārtiņš S. el may 28, 2025 6 min de lectura

    Introduction
    Connection states
    FastTrack
        Requirements
        Example
    Connection tracking settings
        Properties
    Connection List
        Properties

Introduction


Connection tracking allows the kernel to keep track of all logical network connections or sessions, and thereby relate all of the packets which may make up that connection.

NAT relies on this information to translate all related packets in the same way. 

Because of connection tracking you can use stateful firewall functionality even with stateless protocols such as UDP.

Firewall features affected by connection tracking:

    NAT
    firewall:
        connection-bytes
        connection-mark
        connection-type
        connection-state
        connection-limit
        connection-rate
        layer7-protocol
        new-connection-mark
        tarpit

List of tracked connections can be seen in /ip firewall connection for IPv4 and /ipv6 firewall connection for IPv6.
      [admin@3C22-atombumba] /ip firewall connection> print
      Flags: S - seen-reply, A - assured
      #    PR.. SRC-ADDRESS           DST-ADDRESS           TCP-STATE   TIMEOUT
      0    udp  10.5.8.176:5678       255.255.255.255:5678              0s
      1    udp  10.5.101.3:646        224.0.0.2:646                     5s
      2    ospf 10.5.101.161          224.0.0.5                         9m58s
      3    udp  10.5.8.140:5678       255.255.255.255:5678              8s
      4 SA tcp  10.5.101.147:48984    10.5.101.1:8291       established 4m59s
      [admin@3C22-atombumba] /ipv6 firewall connection> print
      Flags: S - seen reply, A - assured
      #    PRO.. SRC-ADDRESS                 DST-ADDRESS                 TCP-STATE
      0    udp   fe80::d6ca:6dff:fe77:3698   ff02::1
      1    udp   fe80::d6ca:6dff:fe98:7c28   ff02::1
      2    ospf  fe80::d6ca:6dff:fe73:9822   ff02::5
Connection states

Based on connection table entries arrived packet can get assigned one of the connection states: new, invalid, established, related, or untracked.

There are two different methods when the packet is considered new. The first one is in the case of stateless connections (like UDP) when there is no connection entry in the connection table. The other one is in the case of a stateful protocol (TCP). In this case, a new packet that starts a new connection is always a TCP packet with an SYN flag.

If a packet is not new it can belong to either an established or related connection or not belong to any connection making it invalid. A packet with an established state, as most of you already guessed, belongs to an existing connection from the connection tracking table. A related state is very similar, except that the packet belongs to a connection that is related to one of the existing connections, for example, ICMP error packets or FTP data connection packets.

Connection state notrack is a special case when RAW firewall rules are used to exclude connection from connection tracking. This rule would make all forwarded traffic bypass the connection tracking, improving packet processing speed through the device.

Any other packet is considered invalid and in most cases should be dropped.

Based on this information we can set a basic set of filter rules to speed up packet filtering and reduce the load on the CPU by accepting established/related packets, dropping invalid packets, and working on more detailed filtering only for new packets.
ip firewall filter
add chain=input connection-state=invalid action=drop comment="Drop Invalid connections"
add chain=input connection-state=established,related,untracked action=accept comment="Allow Established/Related/Untracked connections

Such a rule set must not be applied on routers with asymmetric routing, because asymmetrically routed packets may be considered invalid and dropped.
FastTrack

IPv4 FastTrack is a special handler that bypasses Linux facilities allowing for faster packet forwarding. The handler is used for TCP and UDP connections marked with "fasttrack-connection" action. IPv4 FastTrack handler supports NAT (SNAT, DNAT, or both).

Note that not all packets of the connection can be FastTracked, so it is likely to see some packets going through a slow path even though the connection is marked for FastTrack. This is the reason why fasttrack-connection is usually followed by an identical "action=accept" rule.

FastTrack-ed packets are bypassing:

     firewall,
    connection tracking,
    simple queues,
    queue tree with parent=global,
    IP accounting,
    IPSec,
    hotspot universal client,
    VRF assignment

It is up to the administrator to make sure FastTrack does not interfere with other configuration.
Requirements

IPv4 FastTrack is active if the following conditions are met:

    no mesh, metarouter interface configuration;
    sniffer, torch, or traffic generator is not running;
    /tool mac-scan is not actively used;
    /tool ip-scan is not actively used;
    FastPath and Route cache is enabled under IP/Settings

Example

For example, for SOHO routers with factory default configuration, you could FastTrack all LAN traffic with this one rule placed at the top of the Firewall Filter. The same configuration accept rule is required:
/ip firewall filter add chain=forward action=fasttrack-connection connection-state=established,related
/ip firewall filter add chain=forward action=accept connection-state=established,related

    Connection is FastTracked until the connection is closed, timed-out, or router is rebooted.
    Dummy rules will disappear only after FastTrack firewall rules will be deleted/disabled and the router rebooted.
    While FastPath and FastTrack both are enabled on the device only one can be active at a time.


Queues (except Queue Trees parented to interfaces), firewall filter, and mangle rules will not be applied for FastTracked traffic.
Connection tracking settings

Connection tracking settings are managed from /ip firewall connection tracking menu.
Properties
enabled (yes | no | auto; Default: auto)	Allows to disable or enable connection tracking. With disabled connection tracking  firewall features listed above will stop working. If set to "auto" connection tracking is disabled until at least one firewall rule is added.
loose-tcp-tracking (yes; Default: yes)	

    In case loose-tcp-tracking=yes, the 2nd part (SYN,ACK) and 3rd part (ACK) of the handshake without having seen the first initial SYN will be considered ESTABLISHED
    In case loose-tcp-tracking=no, the 2nd part (SYN,ACK) and 3rd part (ACK) without having seen the first initial SYN will be considered INVALID

tcp-syn-sent-timeout (time; Default: 5s)	TCP SYN timeout.
tcp-syn-received-timeout (time; Default: 5s)	TCP SYN timeout.
tcp-established-timeout (time; Default: 1d)	Time after which established TCP connection times out.
tcp-fin-wait-timeout (time; Default: 10s)	
tcp-close-wait-timeout (time; Default: 10s)	
tcp-last-ack-timeout (time; Default: 10s)	
tcp-time-wait-timeout (time; Default: 10s)	
tcp-close-timeout (time; Default: 10s)	
udp-timeout (time; Default: 30s)	Specifies the timeout for UDP connections that have seen packets in one direction
udp-stream-timeout (time; Default: 3m)	Specifies the timeout of UDP connections that have seen packets in both directions
icmp-timeout (time; Default: 10s)	ICMP connection timeout
generic-timeout (time; Default: 10m)	Timeout for all other connection entries


Read-only properties
max-entries (integer)	

Max amount of entries that the connection tracking table can hold. This value depends on the installed amount of RAM.

Note that the system does not create a maximum-size connection tracking table when it starts, it may increase if the situation demands it and the system still has free RAM, but the size will not exceed 1048576
total-entries (integer)	Amount of connections that the connection table currently holds


Connection List

List of tracked connections ban be seen in /ip firewall connection for ipv4 and /ipv6 firewall connection for IPv6.
Properties

All properties in the connection list are read-only
assured (yes | no)	Indicates that this connection is assured and that it will not be erased if the maximum possible tracked connection count is reached.
confirmed (yes | no)	Connection is confirmed and a packet is sent out from the device
connection-mark (string)	Connection mark that was set by the mangle rule.
connection-type (pptp | ftp)	Type of connection, the property is empty if connection tracking is unable to determine a predefined connection type.
dst-address (ip)	Destination address.
dst-port (integer)	Destination port.
dstnat (yes | no)	A connection has gone through DST-NAT (for example, port forwarding).
dying (yes | no)	The connection is dying due to a connection timeout.
expected (yes | no)	Connection is set up using connection helpers (pre-defined service rules).
fasttrack (yes | no)	Whether the connection is FastTracked.
gre-key (integer)	Contents of the GRE Key field.
gre-protocol (string)	Protocol of the encapsulated payload.
gre-version (string)	A version of the GRE protocol was used in the connection.
connection-mark (string)	Connection mark assigned for the connection from firewall.
hw-offload (yes | no)	Hardware offloaded connection.
icmp-code (string)	ICMP Code Field
icmp-id (integer)	Contains the ICMP ID
icmp-type (integer)	ICMP Type Number
orig-bytes (integer)	Amount of bytes sent out from the source address using the specific connection.
orig-fasttrack-bytes (integer)	Amount of FastTracked bytes sent out from the source address using the specific connection.
orig-fasttrack-packets (integer)	Amount of FastTracked packets sent out from the source address using the specific connection.
orig-packets (integer)	Amount of packets sent out from the source address using the specific connection.
orig-rate (integer)	The data rate at which packets are sent out from the source address using the specific connection.
protocol (string)	IP protocol type
repl-bytes (integer)	Amount of bytes received from the destination address using the specific connection.
repl-fasttrack-bytes (string)	Amount of FastTracked bytes received from the destination address using the specific connection.
repl-fasttrack-packets (integer)	Amount of FastTracked packets received from the destination address using the specific connection.
repl-packets (integer)	Amount of packets received from the destination address using the specific connection.
repl-rate (string)	The data rate at which packets are received from the destination address using the specific connection.
reply-dst-address (ip)	Destination address expected of return packets.
reply-dst-port (integer)	Destination port expected of return packets.
reply-src-address (ip)	Source address expected of return packets.
reply-src-port (integer)	Source port expected of return packets.
seen-reply (yes | no)	The destination address has replied to the source address.
src-address (ip)	The source address.
src-port (integer)	The source port.
srcnat (yes | no)	Connection is going through SRC-NAT, including packets that were masqueraded through NAT.
tcp-state (string)	The current state of TCP connection :

    "established"
    "time-wait"
    "close"
    "syn-sent"
    "syn-recv"
    "fin-wait"
    "close-wait"
    "last-ack"
    "listen"

timeout (time)	Time after connection will be removed from the connection list.





    Creado por Māris B., actualizado por última vez el may 24, 2024 3 min de lectura

The firewall implements stateful (by utilizing connection tracking) and stateless packet filtering and thereby provides security functions that are used to manage data flow to, from, and through the router. Along with the Network Address Translation (NAT), it serves as a tool for preventing unauthorized access to directly attached networks and the router itself as well as a filter for outgoing traffic.

Network firewalls keep outside threats away from sensitive data available inside the network. Whenever different networks are joined together, there is always a threat that someone from outside of your network will break into your LAN. Such break-ins may result in private data being stolen and distributed, valuable data being altered or destroyed, or entire hard drives being erased. Firewalls are used as a means of preventing or minimizing the security risks inherent in connecting to other networks. A properly configured firewall plays a key role in efficient and secure network infrastructure deployment.

MikroTik RouterOS has very powerful firewall implementation with features including:

    stateless packet inspection
    stateful packet inspection 
    Layer-7 protocol detection
    peer-to-peer protocols filtering
    traffic classification by:
        source MAC address
        IP addresses (network or list) and address types (broadcast, local, multicast, unicast)
        port or port range
        IP protocols
        protocol options (ICMP type and code fields, TCP flags, IP options and MSS)
        interface the packet arrived from or left through
        internal flow and connection marks
        DSCP byte
        packet content
        rate at which packets arrive and sequence numbers
        packet size
        packet arrival time

and much more!

Firewall is split in three major modules:

    filter/raw - used to deny traffic based on configured policies. Filtering in RAW tables allow to save resources if connection tracking is not required. 
    mangle - used to mark certain connections, packets, streams, set priorities and do other tasks
    nat - used to set up address translation rules redirects and port forwarding

Chains

Firewall filtering rules are grouped together in chains. It allows a packet to be matched against one common criterion in one chain, and then passed over for processing against some other common criteria to another chain.

For example, a packet should be matched against the IP address:port pair. Of course, it could be achieved by adding as many rules with IP address:port match as required to the forward chain, but a better way could be to add one rule that matches traffic from a particular IP address. Then rules that perform matching against separate ports can be added to "mychain" chain without specifying the IP addresses.
/ip firewall filter 
add chain=mychain protocol=tcp dst-port=22 action=accept
add chain=mychain protocol=tcp dst-port=23 action=accept

add chain=input src-address=1.1.1.2/32 jump-target="mychain"


When processing a chain, rules are taken from the chain in the order they are listed, from top to bottom. If a packet matches the criteria of the rule, then the specified action is performed on it, and no more rules are processed in that chain (the exception is the passthrough action).

If a packet has not matched any rule within the chain, then it is accepted. 

Each firewall module has its own pre-defined chains:

    raw:
        prerouting
        output
    filter
        input
        forward
        output
    mangle
        prerouting
        input
        forward
        output
        postrouting
    nat
        srcnat
        dstnat


More detailed packet processing in RouterOS is described in the Packet Flow in the RouterOS diagram.



    Creado por Artūrs C., actualizado por última vez por GG el ago 13, 2024 7 min de lectura

    Introduction
    Firewall Example
        IPv4 firewall 
            Protect the router itself
            Protect the LAN devices
        IPv6 firewall 
            Protect the router itself
            Protect the LAN devices
    Matchers
    Actions
    RAW Filtering
        Basic RAW Example
    Read More

Introduction

Firewall filters are used to allow or block specific packets forwarded to your local network, originating from your router, or destined to the router.

There are two methods on how to set up filtering:

    allow specific traffic and drop everything else
    drop only malicious traffic, everything else is allowed.

Both methods have pros and cons, for example, from a security point of view first method is much more secure, but requires administrator input whenever traffic for a new service needs to be accepted. This strategy provides good control over the traffic and reduces the possibility of a breach because of service misconfiguration.

On the other hand, when securing a customer network it would be an administrative nightmare to accept all possible services that users may use. Therefore careful planning of the firewall is essential in advanced setups.

A firewall filter consists of three predefined chains that cannot be deleted:

    input - used to process packets entering the router through one of the interfaces with the destination IP address which is one of the router's addresses. Packets passing through the router are not processed against the rules of the input chain
    forward - used to process packets passing through the router
    output - used to process packets originating from the router and leaving it through one of the interfaces. Packets passing through the router are not processed against the rules of the output chain

Firewall filter configuration is accessible from ip/firewall/filter menu for IPv4 and ipv6/firewall/filter menu for IPv6.
Firewall Example

Lets look at basic firewall example to protect router itself and clients behind the router, for both IPv4 and IPv6 protocols.
IPv4 firewall 
Protect the router itself

Rules of thumb followed to set up the firewall:

    work with new connections to decrease the load on a router;
    accept what you need
    drop everything else, log=yes could be set to log some attackers, but keep in mind that it may add some load to he CPU on heavy attacks.


We always start by accepting already known and accepted connections, so the first rule should be to accept "established" and "related" connections.
/ip firewall filter
add action=accept chain=input comment="default configuration" connection-state=established,related

Now we can proceed by accepting some new connections, in our example we want to allow access ICMP protocol from any address and everything else only from 192.168.88.2-192.168.88.254 address range. For that we create an address list and two firewall rules.
/ip firewall address-list
add address=192.168.88.2-192.168.88.254 list=allowed_to_router
/ip firewall filter
add action=accept chain=input src-address-list=allowed_to_router
add action=accept chain=input protocol=icmp

And lastly we drop everything else:
add action=drop chain=input


Complete set of just created rules:
/ip firewall filter
add action=accept chain=input comment="default configuration" connection-state=established,related
add action=accept chain=input src-address-list=allowed_to_router
add action=accept chain=input protocol=icmp
add action=drop chain=input
/ip firewall address-list
add address=192.168.88.2-192.168.88.254 list=allowed_to_router


Protect the LAN devices

Concept in protecting the users is very similar, except that in this case we are blocking unwanted traffic and accepting everythign else.

At first we will create address-list with the name "not_in_internet" which we will use for the firewall filter rules:
/ip firewall address-list
add address=0.0.0.0/8 comment=RFC6890 list=not_in_internet
add address=172.16.0.0/12 comment=RFC6890 list=not_in_internet
add address=192.168.0.0/16 comment=RFC6890 list=not_in_internet
add address=10.0.0.0/8 comment=RFC6890 list=not_in_internet
add address=169.254.0.0/16 comment=RFC6890 list=not_in_internet
add address=127.0.0.0/8 comment=RFC6890 list=not_in_internet
add address=224.0.0.0/4 comment=Multicast list=not_in_internet
add address=198.18.0.0/15 comment=RFC6890 list=not_in_internet
add address=192.0.0.0/24 comment=RFC6890 list=not_in_internet
add address=192.0.2.0/24 comment=RFC6890 list=not_in_internet
add address=198.51.100.0/24 comment=RFC6890 list=not_in_internet
add address=203.0.113.0/24 comment=RFC6890 list=not_in_internet
add address=100.64.0.0/10 comment=RFC6890 list=not_in_internet
add address=240.0.0.0/4 comment=RFC6890 list=not_in_internet
add address=192.88.99.0/24 comment="6to4 relay Anycast [RFC 3068]" list=not_in_internet

Brief firewall filter rule explanation:

    packets with connection-state=established,related added to FastTrack for faster data throughput, the firewall will work with new connections only;
    drop invalid connection and log them with prefix "invalid";
    drop attempts to reach not public addresses from your local network, apply address-list=not_in_internet before, "bridge" is local network interface, log=yes attempts with prefix "!public_from_LAN";
    drop incoming packets that are not NAT`ed, ether1 is public interface, log attempts with "!NAT" prefix;
    jump to ICMP chain to drop unwanted ICMP messages
    drop incoming packets from the Internet, which are not public IP addresses, ether1 is a public interface, log attempts with prefix "!public";
    drop packets from LAN that does not have LAN IP, 192.168.88.0/24 is local network used subnet;

/ip firewall filter
add action=fasttrack-connection chain=forward comment=FastTrack connection-state=established,related
add action=accept chain=forward comment="Established, Related" connection-state=established,related
add action=drop chain=forward comment="Drop invalid" connection-state=invalid log=yes log-prefix=invalid
add action=drop chain=forward comment="Drop tries to reach not public addresses from LAN" dst-address-list=not_in_internet in-interface=bridge log=yes log-prefix=!public_from_LAN out-interface=!bridge
add action=drop chain=forward comment="Drop incoming packets that are not NAT`ted" connection-nat-state=!dstnat connection-state=new in-interface=ether1 log=yes log-prefix=!NAT
add action=jump chain=forward protocol=icmp jump-target=icmp comment="jump to ICMP filters"
add action=drop chain=forward comment="Drop incoming from internet which is not public IP" in-interface=ether1 log=yes log-prefix=!public src-address-list=not_in_internet
add action=drop chain=forward comment="Drop packets from LAN that do not have LAN IP" in-interface=bridge log=yes log-prefix=LAN_!LAN src-address=!192.168.88.0/24

Allow only needed ICMP codes in "icmp" chain:
/ip firewall filter
  add chain=icmp protocol=icmp icmp-options=0:0 action=accept \
    comment="echo reply"
  add chain=icmp protocol=icmp icmp-options=3:0 action=accept \
    comment="net unreachable"
  add chain=icmp protocol=icmp icmp-options=3:1 action=accept \
    comment="host unreachable"
  add chain=icmp protocol=icmp icmp-options=3:4 action=accept \
    comment="host unreachable fragmentation required"
  add chain=icmp protocol=icmp icmp-options=8:0 action=accept \
    comment="allow echo request"
  add chain=icmp protocol=icmp icmp-options=11:0 action=accept \
    comment="allow time exceed"
  add chain=icmp protocol=icmp icmp-options=12:0 action=accept \
    comment="allow parameter bad"
  add chain=icmp action=drop comment="deny all other types"

IPv6 firewall 
Protect the router itself

Very similar to IPv4 setup, except that we have to deal with more protocols required for IPv6 to function properly.

At first we create an address-list from which you allow access to the device:
/ipv6 firewall address-list add address=fd12:672e:6f65:8899::/64 list=allowed

Brief IPv6 firewall filter rule explanation:

    work with new packets, accept established/related packets;
    drop link-local addresses from Internet(public) interface/interface-list;
    accept access to a router from link-local addresses, accept multicast addresses for management purposes, accept your source address-list for router access;
    drop anything else;

/ipv6 firewall filter
add action=accept chain=input comment="allow established and related" connection-state=established,related
add chain=input action=accept protocol=icmpv6 comment="accept ICMPv6"
add chain=input action=accept protocol=udp port=33434-33534 comment="defconf: accept UDP traceroute"
add chain=input action=accept protocol=udp dst-port=546 src-address=fe80::/10 comment="accept DHCPv6-Client prefix delegation."
add action=drop chain=input in-interface=in_interface_name log=yes log-prefix=dropLL_from_public src-address=fe80::/10
add action=accept chain=input comment="allow allowed addresses" src-address-list=allowed
add action=drop chain=input
/ipv6 firewall address-list
add address=fe80::/16 list=allowed
add address=xxxx::/48 list=allowed
add address=ff02::/16 comment=multicast list=allowed

In certain setups where the DHCPv6 relay is used, the src address of the packets may not be from the link-local range. In that case, the src-address parameter of rule #4 must be removed or adjusted to accept the relay address.
Protect the LAN devices

This step is more important than it is for IPv4. In IPv4 setups clients mostly have addresses from local address range and are NATed to public IP, that way they are not directly reachable from the public networks. 

IPv6 is a different story. In most common setups, enabled IPv6 makes your clients available from the public networks, so proper firewall filter rules to protect your customers are mandatory.

In brief we will very basic LAN protection should:

    accept established/related and work with new packets;
    drop invalid packets;
    accept ICMPv6 packets;
    accept new connections originated only from your clients to the public network;
    drop everything else.

/ipv6 firewall filter
add action=accept chain=forward comment=established,related connection-state=established,related
add action=drop chain=forward comment=invalid connection-state=invalid log=yes log-prefix=ipv6,invalid
add action=accept chain=forward comment=icmpv6 in-interface=!in_interface_name protocol=icmpv6
add action=accept chain=forward comment="local network" in-interface=!in_interface_name src-address-list=allowed
add action=drop chain=forward log-prefix=IPV6


Matchers

All matcher properties are common and listed here.


Actions

Tables below shows list of filter specific actions and associated properties.  Other actions are listed here.


action (action name; Default: accept)	

    drop - silently drop the packet

    fasttrack-connection - process packets from a connection using FastPath by enabling FastTrack for the connection. IPv4 only.
    reject - drop the packet and send an ICMP reject message; this action allows ICMP reply specification, such as: prohibit or unreachable admin/host/network/port
    tarpit - captures and holds TCP connections (replies with SYN/ACK to the inbound TCP SYN packet). IPv4 only.

reject-with (icmp-no-route | icmp-admin-prohibited | icmp-not-neighbour | icmp-address-unreachable | icmp-port-unreachable | tcp-reset | icmp-err-src-routing-header | icmp-headers-too-long ; Default: icmp-no-route)	

Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject

    icmp-no-route: sends ICMP address no-route message. ICMP type 2, code 0
    icmp-admin-prohibited: sends ICMP address prohibited message. ICMP type 2, code 1
    icmp-not-neighbour: sends ICMP address not-member message. ICMP type 2, code 2
    icmp-address-unreachable: sends ICMP address unreachable message. ICMP type 2, code 3
    icmp-port-unreachable: sends ICMP port unreachable message. ICMP type 2, code 4
    tcp-reset: sends ICMP resetting a TCP connection. ICMP type 2, code 6
    icmp-err-src-routing-header: sends ICMP Error in Source Routing Header message. ICMP type 2, code 7
    icmp-headers-too-long: sends ICMP Headers too long message. ICMP type 2, code 8

RAW Filtering

The firewall RAW table allows to selectively bypass or drop packets before connection tracking, that way significantly reducing the load on the CPU. The tool is very useful for DoS/DDoS attack mitigation.

RAW filter configuration is accessible from ip/firewall/raw menu for IPv4 and ipv6/firewall/raw menu for IPv6.

The RAW table does not have matchers that depend on connection tracking ( like connection-state, layer7, etc.).
If a packet is marked to bypass the connection tracking packet de-fragmentation will not occur.

Also RAW firewall can have rules only in two chains:

    prerouting - used to process any packet entering the router
    output - used to process packets originated from the router and leaving it through one of the interfaces. Packets passing through the router are not processed against the rules of the output chain

And has one specific action:
action (action name; Default: accept)	

    notrack - do not send a packet to connection tracking. Useful when you still need to use regular firewall, but do not require connection tracking.

Basic RAW Example

Let's assume that we have OSPF configuration, but due to connection tracking OSPF have adjacency problems. We can use RAW rules to fix this, by not sending OSPF packets to connection tracking.
/ip firewall raw 
add chain=prerouting protocol=ospf action=notrack
add chain=output protocol=ospf action=notrack
Read More

    Building advanced firewall
    Connection Rate
    SSH bruteforce protection
    Syn/DoS protection
	
	

    Creado por Artūrs C., actualizado por última vez por Usuario desconocido (elvijsi) el ene 20, 2025 4 min de lectura

    Introduction
    Configuration example
        Change MSS
        Marking Connections
    Mangle Actions

Introduction

Mangle is a kind of 'marker' that marks packets for future processing with special marks. Many other facilities in RouterOS make use of these marks, e.g. queue trees, NAT, routing. They identify a packet based on its mark and process it accordingly. The mangle marks exist only within the router, they are not transmitted across the network.

Additionally, the mangle facility is used to modify some fields in the IP header, like TOS (DSCP) and TTL fields.

Firewall mangle rules consist of five predefined chains that cannot be deleted:


    The PREROUTING chain: Rules in this chain apply to packets as they just arrive on the network interface;
    The INPUT chain: Rules in this chain apply to packets just before they’re given to a local process;
    The OUTPUT chain: The rules here apply to packets just after they’ve been produced by a process;
    The FORWARD chain: The rules here apply to any packets that are routed through the current host;
    The POSTROUTING chain: The rules in this chain apply to packets as they just leave the network interface;

Configuration example
Change MSS

It is a known fact that VPN links have a smaller packet size due to encapsulation overhead. A large packet with MSS that exceeds the MSS of the VPN link should be fragmented before sending it via that kind of connection. However, if the packet has a Don't Fragment flag set, it cannot be fragmented and should be discarded. On links that have broken path MTU discovery (PMTUD), it may lead to a number of problems, including problems with FTP and HTTP data transfer and e-mail services.

In the case of a link with broken PMTUD, a decrease of the MSS of the packets coming through the VPN link resolves the problem. The following example demonstrates how to decrease the MSS value via mangle:
/ip firewall mangle add out-interface=pppoe-out protocol=tcp tcp-flags=syn action=change-mss new-mss=1300 chain=forward tcp-mss=1301-65535
Marking Connections

Sometimes it is necessary to perform some actions on the packets belonging to specific connection (for example, to mark packets from/to specific host for queues), but inspecting each packets IP header is quite expensive task. We can use connection marks to optimize the setup a bit.
/ip firewall mangle 
add chain=forward in-interface=local src-address=192.168.88.123 connection-state=new action=mark-connection new-connection-mark=client_conn
add chain=forward connection-mark=client_conn action=mark-packet new-packet-mark=client_p

Warning: Packet marks are limited to a maximum of 4096 unique entries. Exceeding this limit will cause an error "bad new packet mark"
Mangle Actions

Table list mangle actions and associated properties. Other actions are listed here.
action (action name; Default: accept)	

    change-dscp - change the Differentiated Services Code Point (DSCP) field value specified by the new-dscp parameter
    change-mss - change the Maximum Segment Size field value of the packet to a value specified by the new-mss parameter
    change-ttl - change the Time to Live field value of the packet to a value specified by the new-ttl parameter
    clear-df - clear 'Do Not Fragment' Flag
    fasttrack-connection - shows fasttrack counters, useful for statistics
    mark-connection - place a mark specified by the new-connection-mark parameter on the entire connection that matches the rule
    mark-packet - place a mark specified by the new-packet-mark parameter on a packet that matches the rule
    mark-routing - place a mark specified by the new-routing-mark parameter on a packet. This kind of mark is used for policy routing purposes only. Do not apply any other routing marks besides "main" for the packets processed by FastTrack, since FastTrack can only work in the main routing table.
    route - forces packets to a specific gateway IP by ignoring normal routing decisions (prerouting chain only)
    set-priority - set priority specified by the new-priority parameter on the packets sent out through a link that is capable of transporting priority (VLAN or WMM-enabled wireless interface). Read more
    sniff-pc - send a packet to a remote RouterOS CALEA server.
    sniff-tzsp - send a packet to a remote TZSP compatible system (such as Wireshark). Set remote target with sniff-target and sniff-target-port parameters (Wireshark recommends port 37008)
    strip-ipv4-options - strip IPv4 option fields from IP header, the action does not actually remove IPv4 options but rather replaces all option octets with NOP, further matcher with ipv4-options=any will still match the packet.

new-dscp (integer: 0..63; Default: )	Sets a new DSCP value for a packet
new-mss (integer; Default: )	

Sets a new MSS for a packet.

Clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of a path. Host sends all datagrams on that path with the DF bit set until receives ICMP
Destination Unreachable messages with a code meaning "fragmentation needed and DF set".  Upon receipt of such a message, the source host reduces its assumed PMTU for the path.

new-packet-mark (string; Default: )	Sets a new packet-mark value
new-priority (integer | from-dscp | from-dscp-high-3-bits | from-ingress; Default: )	Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority Read more. This property can also be used to set an internal priority.
new-routing-mark (string; Default: )	Sets a new routing-mark value (in RouterOS v7 routing mark must be created before as a new Routing table)
new-ttl (decrement | increment | set:integer; Default: )	Sets a new Time to live value 
route-dst (IP, Default:)	Matches packets with a specific gateway




    Creado por Artūrs C., actualizado por última vez por Normunds R. el nov 29, 2024 12 min de lectura

    Introduction
    Types of NAT:
        Destination NAT
        Source NAT
            Masquerade
            CGNAT (NAT444)
            Hairpin NAT
        Endpoint-Independent NAT
    NAT Helpers

Introduction

Network Address Translation is an Internet standard that allows hosts on local area networks to use one set of IP addresses for internal communications and another set of IP addresses for external communications. A LAN that uses NAT is ascribed as a natted network. For NAT to function, there should be a NAT gateway in each natted network. The NAT gateway (NAT router) performs IP address rewriting on the way while packets travel from/to LAN. In RouterOS NAT is supported for IPv4. RouterOS does not support NAT64. 

Nat matches only the first packet of the connection, connection tracking remembers the action and performs on all other packets belonging to the same connection.

Whenever NAT rules are changed or added, the connection tracking table should be cleared otherwise NAT rules may seem to be not functioning correctly until the connection entry expires.
Types of NAT:

There are two types of NAT:

    source NAT or srcnat. This type of NAT is performed on packets that are originated from a natted network. A NAT router replaces the private source address of an IP packet with a new public IP address as it travels through the router. A reverse operation is applied to the reply packets traveling in the other direction.
    destination NAT or dstnat. This type of NAT is performed on packets that are destined for the natted network. It is most commonly used to make hosts on a private network to be accessible from the Internet. A NAT router performing dstnat replaces the destination IP address of an IP packet as it travels through the router toward a private network.

Since RouterOS v7 the firewall NAT has two new INPUT and OUTPUT chains which are traversed for packets delivered to and sent from applications running on the local machine:

    input - used to process packets entering the router through one of the interfaces with the destination IP address which is one of the router's addresses. Packets passing through the router are not processed against the rules of the input chain.
    output - used to process packets that originated from the router and leave it through one of the interfaces. Packets passing through the router are not processed against the rules of the output chain.


Destination NAT

Network address translation works by modifying network address information in the packet's IP header. Let`s take a look at the common setup where a network administrator wants to access an office server from the internet.

We want to allow connections from the internet to the office server whose local IP is 10.0.0.3. In this case, we have to configure a destination address translation rule on the office gateway router:
/ip firewall nat add chain=dstnat action=dst-nat dst-address=172.16.16.1 dst-port=22 to-addresses=10.0.0.3 protocol=tcp

The rule above translates: when an incoming connection requests TCP port 22 with destination address 172.16.16.1, use the dst-nat action and depart packets to the device with local IP address 10.0.0.3 and port 22.

To allow access only from the PC at home, we can improve our dst-nat rule with "src-address=192.168.88.1" which is a Home`s PC public (this example) IP address. It is also considered to be more secure!
Source NAT

If you want to hide your local devices behind your public IP address received from the ISP, you should configure the source network address translation (masquerading) feature of the MikroTik router. 
Let`s assume you want to hide both the office computer and server behind the public IP 172.16.16.1, the rule will look like the following one:
/ip firewall nat add chain=srcnat src-address=10.0.0.0/24 action=src-nat to-addresses=172.16.16.1 out-interface=WAN

Now your ISP will see all the requests coming with IP 172.16.16.1 and they will not see your LAN network IP addresses.
Masquerade

Firewall NAT action=masquerade is a unique subversion of action=srcnat, it was designed for specific use in situations when public IP can randomly change, for example, DHCP server changes assigned IP or PPPoE tunnel after disconnect gets a different IP, in short - when public IP is dynamic.
/ip firewall nat add chain=srcnat src-address=10.0.0.0/24 action=masquerade out-interface=WAN

Every time when interface disconnects and/or its IP address changes, the router will clear all masqueraded connection tracking entries related to the interface, this way improving system recovery time after public IP change. If srcnat is used instead of masquerade, connection tracking entries remain and connections can simply resume after a link failure.

Unfortunately, this can lead to some issues with unstable links when the connection gets routed over different links after the primary link goes down. In such a scenario following things can happen:

    on disconnect, all related connection tracking entries are purged;
    next packet from every purged (previously masqueraded) connection will come into the firewall as new, and, if a primary interface is not back, a packet will be routed out via an alternative route (if you have any) thus creating a new masqueraded connection;
    the primary link comes back, routing is restored over the primary link, so packets that belong to existing connections are sent over the primary interface without being masqueraded, that way leaking local IPs to a public network.

To work around this situation blackhole route can be created as an alternative to the route that might disappear on disconnect.

Hosts behind a NAT-enabled router do not have true end-to-end connectivity. Therefore some Internet protocols might not work in scenarios with NAT. Services that require the initiation of TCP connection from outside the private network or stateless protocols such as UDP, can be disrupted. 

To overcome these limitations RouterOS includes a number of so-called NAT helpers, that enable NAT traversal for various protocols. When action=srcnat is used instead, connection tracking entries remain and connections can simply resume.

Though Source NAT and masquerading perform the same fundamental function: mapping one address space into another one, the details differ slightly. Most noticeably, masquerading chooses the source IP address for the outbound packet from the IP bound to the interface through which the packet will exit.
CGNAT (NAT444)

To combat IPv4 address exhaustion, a new RFC 6598 was deployed. The idea is to use shared 100.64.0.0/10 address space inside the carrier's network and perform NAT on the carrier's edge router to a single public IP or public IP range.

Because of the nature of such a setup, it is also called NAT444, as opposed to a NAT44 network for a 'normal' NAT environment, three different IPv4 address spaces are involved.

CGNAT configuration on RouterOS does not differ from any other regular source NAT configuration:
/ip firewall nat 
 add chain=src-nat action=srcnat src-address=100.64.0.0/10 to-address=2.2.2.2 out-interface=<public_if>

Where:

    2.2.2.2 - public IP address,
    public_if - interface on provider's edge router connected to the internet

The advantage of NAT444 is obvious, fewer public IPv4 addresses are used. But this technique comes with major drawbacks:

    The service provider router performing CGNAT needs to maintain a state table for all the address translations: this requires a lot of memory and CPU resources.
    Console gaming problems. Some games fail when two subscribers using the same outside public IPv4 address try to connect to each other.
    Tracking users for legal reasons means extra logging, as multiple households go behind one public address.
    Anything requiring incoming connections is broken. While this already was the case with regular NAT, end-users could usually still set up port forwarding on their NAT router. CGNAT makes this impossible. This means no web servers can be hosted here, and IP Phones cannot receive incoming calls by default either.
    Some web servers only allow a maximum number of connections from the same public IP address, as a means to counter DoS attacks like SYN floods. Using CGNAT this limit is reached more often and some services may be of poor quality.
    6to4 requires globally reachable addresses and will not work in networks that employ addresses with a limited topological span.


Packets with Shared Address Space source or destination addresses MUST NOT be forwarded across Service Provider boundaries. Service Providers MUST filter such packets on ingress links. In RouterOS this can be easily done with firewall filters on edge routers:
/ip firewall filter
 add chain=input src-address=100.64.0.0/10 action=drop in-interface=<public_if>
 add chain=output dst-address=100.64.0.0/10 action=drop out-interface=<public_if>
 add chain=forward src-address=100.64.0.0/10 action=drop in-interface=<public_if>
 add chain=forward src-address=100.64.0.0/10 action=drop out-interface=<public_if>
 add chain=forward dst-address=100.64.0.0/10 action=drop out-interface=<public_if>

Service providers may be required to log of MAPed addresses, in a large CGN deployed network which may be a problem. Fortunately, RFC 7422 suggests a way to manage CGN translations in such a way as to significantly reduce the amount of logging required while providing traceability for abuse response.

RFC states that instead of logging each connection, CGNs could deterministically map customer private addresses (received on the customer-facing interface of the CGN, a.k.a., internal side) to public addresses extended with port ranges.

That means that separate NAT rules have to be added to achieve individual mappings such as the ones seen in the below example:
Inside IP	Outside IP/Port range
100.64.0.1	2.2.2.2:5000-5199
100.64.0.2	2.2.2.2:5200-5399
100.64.0.3	2.2.2.2:5400-5599
100.64.0.4	2.2.2.2:5600-5799
100.64.0.5	2.2.2.2:5800-5999

Instead of writing the rules by hand, it is suggested to use a script instead. The following example could be adapted to any requirements of your setup.
{
######## Adjustable values #########
:local StartingAddress 100.64.0.1
:local ClientCount 5
:local AddressesPerClient 2
:local PublicAddress 2.2.2.2
:local StartingPort 5000
:local PortsPerAddress 200
####################################

# All client chain jump
/ip firewall nat add chain=srcnat action=jump jump-target=clients \
    src-address="$StartingAddress-$($StartingAddress + ($ClientCount * $AddressesPerClient) - 1)"

:local currentPort $StartingPort

:for c from=1 to=$ClientCount do={
    # Specific client chain jumps
    :if ($AddressesPerClient > 1) do={
      /ip firewall nat add chain=clients action=jump jump-target="client-$c" \
      src-address="$($StartingAddress + ($AddressesPerClient * ($c - 1)))-$($StartingAddress + ($AddressesPerClient * $c -1))"
    } else={
      /ip firewall nat add chain=clients action=jump jump-target="client-$c" \
      src-address="$($StartingAddress + ($AddressesPerClient * ($c - 1)))"
    }
  
    # Translation rules
    :for a from=1 to=$AddressesPerClient do={
      /ip firewall nat add chain="client-$c" action=src-nat protocol=tcp \
      src-address="$($StartingAddress + (($c -1) * $AddressesPerClient) + $a - 1)" to-address=$PublicAddress to-ports="$currentPort-$($currentPort + $PortsPerAddress - 1)"
      /ip firewall nat add chain="client-$c" action=src-nat protocol=udp \
      src-address="$($StartingAddress + (($c -1) * $AddressesPerClient) + $a - 1)" to-address=$PublicAddress to-ports="$currentPort-$($currentPort + $PortsPerAddress - 1)"
      :set currentPort ($currentPort + $PortsPerAddress)
    }
}
}

The six local values can be adjusted and the script can be either simply pasted in the terminal or it can be stored in the system script section, in case the configuration needs to be regenerated later.

After execution, you should get a set of rules:
[admin@MikroTik] > ip firewall nat print
Flags: X - disabled, I - invalid; D - dynamic 
 0    chain=srcnat action=jump jump-target=clients 
      src-address=100.64.0.1-100.64.0.10 

 1    chain=clients action=jump jump-target=client-1 
      src-address=100.64.0.1-100.64.0.2 

 2    chain=client-1 action=src-nat to-addresses=2.2.2.2 to-ports=5000-5199 
      protocol=tcp src-address=100.64.0.1 

 3    chain=client-1 action=src-nat to-addresses=2.2.2.2 to-ports=5000-5199 
      protocol=udp src-address=100.64.0.1 

 4    chain=client-1 action=src-nat to-addresses=2.2.2.2 to-ports=5200-5399 
      protocol=tcp src-address=100.64.0.2 

 5    chain=client-1 action=src-nat to-addresses=2.2.2.2 to-ports=5200-5399 
      protocol=udp src-address=100.64.0.2 

 6    chain=clients action=jump jump-target=client-2 
      src-address=100.64.0.3-100.64.0.4 

 7    chain=client-2 action=src-nat to-addresses=2.2.2.2 to-ports=5400-5599 
      protocol=tcp src-address=100.64.0.3 

 8    chain=client-2 action=src-nat to-addresses=2.2.2.2 to-ports=5400-5599 
      protocol=udp src-address=100.64.0.3 

 9    chain=client-2 action=src-nat to-addresses=2.2.2.2 to-ports=5600-5799 
      protocol=tcp src-address=100.64.0.4 

10    chain=client-2 action=src-nat to-addresses=2.2.2.2 to-ports=5600-5799 
      protocol=udp src-address=100.64.0.4 

11    chain=clients action=jump jump-target=client-3 
      src-address=100.64.0.5-100.64.0.6 

12    chain=client-3 action=src-nat to-addresses=2.2.2.2 to-ports=5800-5999 
      protocol=tcp src-address=100.64.0.5 

13    chain=client-3 action=src-nat to-addresses=2.2.2.2 to-ports=5800-5999 
      protocol=udp src-address=100.64.0.5 

14    chain=client-3 action=src-nat to-addresses=2.2.2.2 to-ports=6000-6199 
      protocol=tcp src-address=100.64.0.6 

15    chain=client-3 action=src-nat to-addresses=2.2.2.2 to-ports=6000-6199 
      protocol=udp src-address=100.64.0.6 

[...]

Hairpin NAT

Hairpin network address translation (NAT Loopback) is where the device on the LAN can access another machine on the LAN via the public IP address of the gateway router. 



In the above example, the gateway router has the following dst-nat configuration rule:
/ip firewall nat add chain=dstnat action=dst-nat dst-address=172.16.16.1 dst-port=443 to-addresses=10.0.0.3 to-ports=443 protocol=tcp

When a user from the PC at home establishes a connection to the web server, the router performs DST NAT as configured:

    the client sends a packet with a source IP address of 192.168.88.1 to a destination IP address of 172.16.16.1 on port 443 to request some web resources;
    the router destination NAT`s the packet to 10.0.0.3 and replaces the destination IP address in the packet accordingly. The source IP address stays the same: 192.168.88.1;
    the server replies to the client's request and the reply packet has a source IP address of 10.0.0.3 and a destination IP address of 192.168.88.1.
    the router determines that the packet is part of a previous connection and undoes the destination NAT, and puts the original destination IP address into the source IP address field. The destination IP address is 192.168.88.1, and the source IP address is 172.16.16.1;
    The client receives the reply packet it expects, and the connection is established;


But, there will be a problem, when a client on the same network as the web server requests a connection to the web server's public IP address: 

    the client sends a packet with a source IP address of 10.0.0.2 to a destination IP address of 172.16.16.1 on port 443 to request some web resources;
    the router destination NATs the packet to 10.0.0.3 and replaces the destination IP address in the packet accordingly. The source IP address stays the same: 10.0.0.2;
    the server replies to the client's request. However, the source IP address of the request is on the same subnet as the web server. The web server does not send the reply back to the router but sends it back directly to 10.0.0.2 with a source IP address in the reply of 10.0.0.3;
    The client receives the reply packet, but it discards it because it expects a packet back from 172.16.16.1, and not from 10.0.0.3;

To resolve this issue, we will configure a new src-nat rule (the hairpin NAT rule) as follows:
/ip firewall nat
add action=masquerade chain=srcnat dst-address=10.0.0.3 out-interface=LAN protocol=tcp src-address=10.0.0.0/24

After configuring the rule above:

    the client sends a packet with a source IP address of 10.0.0.2 to a destination IP address of 172.16.16.1 on port 443 to request some web resources;
    the router destination NATs the packet to 10.0.0.3 and replaces the destination IP address in the packet accordingly. It also source NATs the packet and replaces the source IP address in the packet with the IP address on its LAN interface. The destination IP address is 10.0.0.3, and the source IP address is 10.0.0.1;
    the web server replies to the request and sends the reply with a source IP address of 10.0.0.3 back to the router's LAN interface IP address of 10.0.0.1;
    the router determines that the packet is part of a previous connection and undoes both the source and destination NAT, and puts the original destination IP address of 10.0.0.3 into the source IP address field, and the original source IP address of 172.16.16.1 into the destination IP address field

Endpoint-Independent NAT

Endpoint-independent NAT creates mapping in the source NAT and uses the same mapping for all subsequent packets with the same source IP and port. This mapping is created with the following rule:
/ip firewall nat
add action=endpoint-independent-nat chain=srcnat out-interface=WAN protocol=udp

This mapping allows running source-independent filtering, which allows forwarding packets from any source from WAN to mapped internal IP and port. The following rule enables filtering:
/ip firewall nat
add action=endpoint-independent-nat chain=dstnat in-interface=WAN protocol=udp


Endpoint-independent NAT works only with UDP protocol.


Additionally, endpoint-independent-nat can take a few other parameters:

    randomize-port - randomize to which public port connections will be mapped.


More info https://www.ietf.org/rfc/rfc5128.txt section 2.2.3 and 2.2.5
NAT Helpers

Hosts behind a NAT-enabled router do not have true end-to-end connectivity. Therefore some Internet protocols might not work in scenarios with NAT. To overcome these limitations RouterOS includes a number of NAT helpers, that enable NAT traversal for various protocols.

Nat helpers can be managed from /ip firewall service-ports menu.

List of available nat helpers:
FTP	FTP service helper
H323	H323 service helper
IRC	IRC service helper
PPTP	PPTP (GRE) tunneling helper
UDPLITE	UDP-Lite service helper
DCCP	DCCP service helper
SCTP	SCTP service helper
SIP	SIP helper. Additional options:

    sip-direct-media allows redirecting the RTP media stream to go directly from the caller to the callee. The default value is yes.
    sip-timeout allows adjusting TTL of SIP UDP connections. Default: 1 hour. In some setups, you have to reduce that.

TFTP	TFTP service helper
RSTP	RTSP service helper


If connection tracking is not enabled then firewall service ports will be shown as inactive

udplite, dccp, and sctp are built-in services of the connection tracking. Since these are not separately loaded modules, they cannot be disabled separately, they got disabled together with the connection tracking.


NAT Actions

Table lists NAT actions and their associated properties. Other actions are listed here.
action (action name; Default: accept)	

    dst-nat - replaces the destination address and/or port of an IP packet with values specified by to-addresses and to-ports parameters
    masquerade - replaces the source port of an IP packet with one specified by to-ports parameter and replace the source address of an IP packet to the IP determined by the routing facility. 
    netmap - creates a static 1:1 mapping of one set of IP addresses to another one. Often used to distribute public IP addresses to hosts on private networks
    redirect - replaces the destination port of an IP packet with one specified by to-ports parameter and destination address to one of the router's local addresses
    same - gives a particular client the same source/destination IP address from a supplied range for each connection. This is most frequently used for services that expect the same client address for multiple connections from the same client. IPv4 only
    src-nat - replaces the source address of an IP packet with values specified by to-addresses and to-ports parameters
    endpoint-independent-nat - uses endpoint-independent mapping and filtering. Works only with UDP protocol. IPv4 only.

same-not-by-dst (yes | no; Default: )	Specifies whether to take into account or not the destination IP address when selecting a new source IP address. Applicable if action=same
to-addresses (IP address[-IP address]; Default: 0.0.0.0)	Replace the original address with the specified one. Applicable if action is dst-nat, netmap, same, src-nat
to-ports (integer[-integer]: 0..65535; Default: )	Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same, src-nat



    Creado por Māris B., actualizado por última vez por Matīss O. el ene 13, 2025 15 min de lectura

    Common Actions and Associated properties
        Stats
        Other Useful Commands
    Matchers
        Stateless Properties
        Stateful Properties

Common Actions and Associated properties
action (action name; Default: accept)	Action to take if a packet is matched by the rule:

    accept - accept the packet. A packet is not passed to the next firewall rule.
    add-dst-to-address-list - add destination address to address list specified by address-list parameter
    add-src-to-address-list - add source address to address list specified by address-list parameter
    jump - jump to the user-defined chain specified by the value of jump-target parameter
    log - add a message to the system log containing the following data: in-interface, out-interface, src-mac, protocol, src-ip:port->dst-ip:port and length of the packet. After a packet is matched it is passed to the next rule in the list, similar as passthrough
    passthrough - if a packet is matched by the rule, increase counter and go to next rule (useful for statistics)
    return - passes control back to the chain from where the jump took place

address-list (name; Default: )	

Name of the address list to be used. Applicable if action is add-dst- to-address-list or add-src-to-address-list
address-list-timeout (none-dynamic | none-static | time; Default: none-dynamic)	Time interval after which the address will be removed from the address list specified by address-list parameter. Used in conjunction with add-dst-to-address-list or add-src-to-address-list actions

    Value of none-dynamic (00:00:00) will leave the address in the address list till reboot
    Value of none-static will leave the address in the address list forever and will be included in the configuration export/backup

jump-target (name; Default: )	Name of the target chain to jump to. Applicable only if action=jump
log (yes | no; Default: no)	Add a message to the system log containing the following data: in-interface, out-interface, src-mac, protocol, src-ip:port->dst-ip:port, and length of the packet. Allows to log packets even if action is not "log", useful for debugging firewall.
log-prefix (string; Default: )	Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
Stats

To view matching statistics by firewall rules, run /ip firewall filter print stats command or /ipv6 firewall filter print stats for IPv6 firewall.


bytes (integer)	The total amount of bytes matched by the rule
packets (integer)	The total amount of packets matched by the rule
[admin@MikroTik] > ip firewall filter print stats 
Flags: X - disabled, I - invalid, D - dynamic 
 #    CHAIN                                                                                                                 ACTION                            BYTES         PACKETS
 0  D ;;; special dummy rule to show fasttrack counters
      forward                                                                                                               passthrough              50 507 925 242      50 048 246
 1    ;;; defconf: drop invalid
      forward                                                                                                               drop                            432 270           9 719
 2    ;;; defconf: drop invalid
      input                                                                                                                 drop                            125 943           2 434
 3    input                                                                                                                 accept                   20 090 211 549      20 009 864
 4    ;;; defconf: accept ICMP
      input                                                                                                                 accept                          634 926           7 648
 5    ;;; defconf: drop all not coming from LAN
      input                                                                                                                 drop                          4 288 079          83 428
 6    ;;; defconf: accept in ipsec policy
      forward                                                                                                               accept                                0               0
7    ;;; defconf: accept out ipsec policy
      forward                                                                                                               accept                                0               0
8    ;;; defconf: fasttrack
      forward                                                                                                               fasttrack-connection     28 505 528 775      31 504 682
9    ;;; defconf: accept established,related, untracked
      forward                                                                                                               accept                   28 505 528 775      31 504 682
10    ;;; defconf: drop all from WAN not DSTNATed
      forward                                                                                                               drop                                  0               0


Statistics parameters can be reset by following commands:
reset-counters (id)	

Reset statistics counters for specific firewall rule or list of rules.
reset-counters-all	

Reset statistics counters for all firewall rules in the table.
Other Useful Commands

By default print is equivalent to print static and shows only static rules.

To print also dynamic rules use print all.

Or to print only dynamic rules use print dynamic.
Matchers

Tables below shows all the properties that can be used as a matchers in the firewall rules.

Matchers are executed in a specific order.

For IPv4:

    Source MAC Address
    In/Out interfaces
    In/Out interface lists
    IP Range
    Address type
    Address list
    TTL
    DSCP
    Length
    TLS
    IPv4 Options
    Dst Port
    Src Port
    Any Port
    TCP Options
    TCP MSS
    ICMP Codes
    Ingress Priority
    Priority
    Packet Mark
    Realm (routing table)
    Hotsopot
    Connection Mark
    Connection State
    Connection NAT State
    Connection Bytes
    Connection Limit
    Connection Rate
    Ipsec Policy
    Helper
    String (content)
    PSD
    Layer7
    Random
    Nth
    PCC
    Limit
    Dst Limit
    Log

For IPv6:

    Address type
    Address list
    Source MAC Address
    In/Out interfaces
    In/Out interface lists
    Hop Limit
    DSCP
    Length
    TLS
    IPv6 Header
    Dst Port
    Src Port
    Any Port
    TCP Options
    TCP MSS
    ICMPv6 Codes
    Ingress Priority
    Priority
    Packet Mark
    Connection Mark
    Connection State
    Connection NAT State
    Connection Bytes
    Connection Limit
    Connection Rate
    Ipsec Policy
    Helper
    Match String (content)
    Random
    Nth
    PCC
    Limit
    Dst Limit
    Log

 

Properties are split in two parts:

    stateless - properties do not require connection tracking to function and can be used in stateless RAW firewall matching.
    stateful - properties either require connection tracking to function or is available only in stateful firewall config.

Stateless Properties


chain (name; Default: )	Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new chain will be created
comment (string; Default: )	Descriptive comment for the rule
content (string; Default: )	Match packets that contain specified text
dscp (integer: 0..63; Default: )	Matches DSCP IP header field.
dst-address (IP/netmask | IP range; Default: )	Matches packets whose destination is equal to the specified IP or falls into the specified IP range.
dst-address-list (name; Default: )	

Matches the destination address of a packet against a user-defined address-list.

Supports only one list!
dst-address-type (unicast | local | broadcast | multicast )	Matches destination address type:

    unicast - IP address used for point to point transmission
    local - if dst-address is assigned to one of the router's interfaces
    broadcast - packet is sent to all devices in a subnet
    multicast - packet is forwarded to a defined group of devices

dst-limit (integer[/time],integer,dst-address | dst-port | src-address[/time]; Default: )	Matches packets until a given rate is exceeded. Rate is defined as packets per time interval. As opposed to the limit matcher, every flow has its own limit. Flow is defined by a mode parameter. Parameters are written in the following format: rate[/time],burst,mode[/expire].

    rate - packet count per time interval per-flow to match
    time - specifies the time interval in which the packet count rate per flow cannot be exceeded (optional, 1s will be used if not specified)
    burst - initial number of packets per flow to match: this number gets recharged by one every time/rate, up to this number
    mode - this parameter specifies what unique fields define flow (src-address, dst-address, src-and-dst-address, dst-address-and-port, addresses-and-dst-port)
    expire - specifies interval after which flow with no packets will be allowed to be deleted (optional)

dst-port (integer[-integer]: 0..65535; Default: )	List of destination port numbers or port number ranges
fragment (yes|no; Default: )	

Matches fragmented packets. The first (starting) fragment does not count. If connection tracking is enabled there will be no fragments as the system automatically assembles every packet.

IPv4 only.

header (Type[:Mode]; Mode=contains|exact; Type=hop|dst|route|frag|ah|esp|none|proto)
	

Matches IPv6 next-header.

Two types of header matching are possible controlled by "mode" parameter:

    contains - soft matching, matches at least selected headers
    exact - matches exact set of selected headers

IPv6 only.

hop-limit (Mode:Value; Mode=equal | greater-than | less-than | not-equal; Value=0..255)
	

Matches hop limit field in the IPv6 header. 

IPv6 only.
hotspot (auth | from-client | http | local-dst | to-client; Default: )	Matches packets received from HotSpot clients against various HotSpot matchers.

    auth - matches authenticated HotSpot client packets
    from-client - matches packets that are coming from the HotSpot client
    http - matches HTTP requests sent to the HotSpot server
    local-dst - matches packets that are destined to the HotSpot server
    to-client - matches packets that are sent to the HotSpot client

IPv4 Only.
icmp-options (integer:integer; Default: )	Matches ICMP type: code fields
in-bridge-port (name; Default: )	Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall is enabled in bridge settings.
in-bridge-port-list (name; Default: )	Set of interfaces defined in interface list. Works the same as in-bridge-port
in-interface (name; Default: )	Interface the packet has entered the router
in-interface-list (name; Default: )	Set of interfaces defined in interface list. Works the same as in-interface
ingress-priority (integer: 0..63; Default: )	Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit. read more
ipsec-policy (in | out, ipsec | none; Default: )	Matches the policy used by IPsec. Value is written in the following format: direction, policy. The direction is Used to select whether to match the policy used for decapsulation or the policy that will be used for encapsulation.

    in - valid in the PREROUTING, INPUT, and FORWARD chains
    out - valid in the POSTROUTING, OUTPUT, and FORWARD chains

    ipsec - matches if the packet is subject to IPsec processing;
    none - matches packets that are not subject to IPsec processing (for example, IPSec transport packet).

For example, if a router receives an IPsec encapsulated Gre packet, then rule ipsec-policy=in,ipsec will match Gre packet, but a rule ipsec-policy=in,none will match the ESP packet.
ipv4-options (any | loose-source-routing | no-record-route | no-router-alert | no-source-routing | no-timestamp | none | record-route | router-alert | strict-source-routing | timestamp; Default: )	Matches IPv4 header options.

    any - match packet with at least one of the ipv4 options
    loose-source-routing - match packets with a loose source routing option. This option is used to route the internet datagram based on information supplied by the source
    no-record-route - match packets with no record route option. This option is used to route the internet datagram based on information supplied by the source
    no-router-alert - match packets with no router alter option
    no-source-routing - match packets with no source routing option
    no-timestamp - match packets with no timestamp option
    record-route - match packets with record route option
    router-alert - match packets with router alter option
    strict-source-routing - match packets with a strict source routing option
    timestamp - match packets with a timestamp

IPv4 only.
limit (integer,time,integer; Default: )	Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is reached. Parameters are written in the following format: rate[/time],burst:mode.

    rate - packet or bit count per time interval to match
    time - specifies the time interval in which the packet or bit rate cannot be exceeded (optional, 1s will be used if not specified)
    burst - initial number of packets or bits to match: this number gets recharged every 10ms so burst should be at least 1/100 of a rate per second
    mode - packet or bit mode

nth (integer,integer; Default: )	Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched by the rule
out-bridge-port (name; Default: )	Actual interface the packet leaves the router if the outgoing interface is a bridge. Works only if use-ip-firewall is enabled in bridge settings.
out-bridge-port-list (name; Default: )	Set of interfaces defined in interface list. Works the same as out-bridge-port
out-interface (; Default: )	Interface the packet is leaving the router
out-interface-list (name; Default: )	Set of interfaces defined in interface list. Works the same as out-interface
packet-mark (no-mark | string; Default: )	Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any unmarked packet. 
packet-size (integer[-integer]:0..65535; Default: )	Matches packets of specified size or size range in bytes.
per-connection-classifier (ValuesToHash:Denominator/Remainder; Default: )	

PCC matcher ( or Per Stream Classifier) allows dividing traffic into equal streams with the ability to keep packets with a specific set of options in one particular stream.

Streams are hashed based on selected values to hash:

    both-addresses    
    both-addresses-and-ports    
    both-ports    
    dst-address    
    dst-address-and-port    
    dst-port    
    src-address    
    src-address-and-port    
    src-port 

 Read more >>
port (integer[-integer]: 0..65535; Default: )	Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if protocol is TCP or UDP
priority (integer: 0..63; Default:)	Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP bit, or from the priority that has been set using the set-priority action. Read more
protocol (name or protocol ID; Default: tcp)	Matches particular IP protocol specified by protocol name or number
psd (integer,time,integer,integer; Default: )	Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold, LowPortWeight, HighPortWeight

    WeightThreshold - total weight of the latest TCP/UDP packets with different destination ports coming from the same host to be treated as port scan sequence
    DelayThreshold - delay for the packets with different destination ports coming from the same host to be treated as possible port scan subsequence
    LowPortWeight - the weight of the packets with privileged (<1024) destination port
    HighPortWeight - the weight of the packet with a non-privileged destination port

IPv4 only.
random (integer: 1..99; Default: )	Matches packets randomly with a given probability
src-address (Ip/Netmask, Ip range; Default: )	Matches packets whose source is equal to a specified IP or falls into a specified IP range
src-address-list (name; Default: )	

Matches the source address of a packet against a user-defined address list.

Supports only one list!
src-address-type (unicast | local | broadcast | multicast | blackhole | prohibit | unreachable ; Default: )	

mote{ta{tableMatches source address type:

    unicast - IP address used for point to point transmission
    local - if an address is assigned to one of the router's interfaces
    broadcast - packet is sent to all devices in the subnet
    multicast - packet is forwarded to a defined group of devices

src-port (integer[-integer]: 0..65535; Default: )	List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP
src-mac-address (MAC address; Default: )	Matches the source MAC address of the packet
tcp-flags (ack | cwr | ece | fin | psh | rst | syn | urg; Default: )	Matches specified TCP flags

    ack - acknowledging data
    cwr - congestion window reduced
    ece - ECN-echo flag (explicit congestion notification)
    fin - close connection
    psh - push function
    rst - drop connection
    syn - new connection
    urg - urgent data

tcp-mss (integer[-integer]: 0..65535; Default: )	Matches TCP MSS value of an IP packet
time (time-time,sat | fri | thu | wed | tue | mon | sun; Default: )	Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time and date
tls-host (string; Default: )	Allows matching HTTPS traffic based on TLS SNI hostname. Accepts GLOB syntax for wildcard matching. Note that the matcher will not be able to match the hostname if the TLS handshake frame is fragmented into multiple TCP segments (packets).

Watch our video about this value. 
ttl (integer: 0..255; Default: )	Matches packets TTL value. IPv4 Only.
Stateful Properties


connection-bytes (integer-integer; Default: )	

Matches packets only if a given amount of bytes has been transferred through the particular connection.

0 - means infinity, for example connection-bytes=2000000-0 means that the rule matches if more than 2MB has been transferred through the relevant connection
connection-limit (integer,netmask; Default: )	Matches connections per address or address block after a given value is reached. Should be used together with connection-state=new and/or with tcp-flags=syn because matcher is very resource-intensive
connection-mark (no-mark | string; Default: )	Matches packets marked via mangle facility with particular connection mark. If no-mark is set, the rule will match any unmarked connection
connection-nat-state (srcnat | dstnat; Default: )	Can match connections that are srcnatted, distracted, or both. Note that connection-state=related connections connection-nat-state is determined by the direction of the first packet. and if connection tracking needs to use dst-nat to deliver this connection to the same hosts as the main connection it will be in connection-nat-state=dstnat even if there are no dst-nat rules at all
connection-rate (Integer 0..4294967295; Default: )	Connection Rate is a firewall matcher that allows capturing traffic based on the present speed of the connection
connection-state (established | invalid | new | related | untracked; Default: )	Interprets the connection tracking analytics data for a particular packet:

    established - a packet that belongs to an existing connection
    invalid - a packet that does not have a determined state in connection tracking (usually - severe out-of-order packets, packets with wrong sequence/ack number, or in case of a resource over usage on the router), for this reason, an invalid packet will not participate in NAT (as only connection-state=new packets do), and will still contain original source IP address when routed. We strongly suggest dropping all connection-state=invalid packets in the firewall filter forward and input chains
    new - the packet has started a new connection or is otherwise associated with a connection that has not seen packets in both directions.
    related - a packet that is related to, but not parts of an existing connection, such as ICMP errors or a packet that begins an FTP data connection
    untracked - packet that was set to bypass connection tracking in firewall RAW tables.

connection-type (ftp | h323 | irc | pptp | quake3 | sip | tftp; Default: )	Matches packets from related connections based on information from their connection tracking helpers. A relevant connection helper must be enabled under the: /ip firewall service-port
layer7-protocol (name; Default: )	Layer7 filter name defined in layer7 protocol menu. Read more>>.

p2p ()
	

Matches some unencrypted P2P protocols. Deprecated in modern days since mostly everything is encrypted and requires deep packet inspection to identify.

IPv4 only.
realm (integer: 0..4294967295; Default: )	IPv4 only.
routing-mark (string; Default: )	Matches packets marked by mangle facility with particular routing mark



    Creado por Artūrs C., actualizado por última vez por GG el abr 23, 2024 2 min de lectura

    Summary
        Properties
    Examples
        Simple L7 usage example
        L7 in the input chain
        Youtube Matcher

Summary

Layer7-protocol is a method of searching for patterns in ICMP/TCP/UDP streams.

The L7 matcher is very resource-intensive. Use this feature only for very specific traffic. It is not recommended to use the L7 matcher for generic traffic, such as for blocking web pages. This will almost never work correctly and your device will exhaust its resources, trying to catch all the traffic. Use other features to block webpages by URL.

L7 matcher collects the first 10 packets of a connection or the first 2KB of a connection and searches for the pattern in the collected data. If the pattern is not found in the collected data, the matcher stops inspecting further. Allocated memory is freed and the protocol is considered unknown. You should take into account that a lot of connections will significantly increase memory and CPU usage. To avoid this, add regular firewall matchers to reduce the amount of data passed to layer-7 filters repeatedly.

An additional requirement is that the layer7 matcher must see both directions of traffic (incoming and outgoing). To satisfy this requirement l7 rules should be set in the forward chain. If the rule is set in the input/prerouting chain then the same rule must be also set in the output/postrouting chain, otherwise, the collected data may not be complete resulting in an incorrectly matched pattern.

 Layer 7 matcher is case insensitive!

Example L7 patterns compatible with RouterOS can be found on the l7-filter project page.

 In some cases when layer 7 regular expression cannot be performed, RouterOS will log topic=firewall, warning with an error message stating the problem in the message!
Properties
/ip firewall layer7-protocol


name (string; Default: )	Descriptive name of l7 pattern used by configuration in firewall rules. See example >>.
regexp (string; Default: )	POSIX compliant regular expression is used to match a pattern.
Examples
Simple L7 usage example

First, add Regexp strings to the protocols menu, to define the strings you will be looking for. In this example, we will use a pattern to match RDP packets.
/ip firewall layer7-protocol
add name=rdp regexp="rdpdr.*cliprdr.*rdpsnd"

Then, use the defined protocols in the firewall.
/ip firewall filter

# add few known protocols to reduce mem usage
add action=accept chain=forward comment="" disabled=no port=80 protocol=tcp
add action=accept chain=forward comment="" disabled=no port=443 protocol=tcp

# add l7 matcher
add action=accept chain=forward comment="" disabled=no layer7-protocol=\
    rdp protocol=tcp

As you can see before the l7 rule we added several regular rules that will match known traffic thus reducing memory usage.
L7 in the input chain

In this example, we will try to match the telnet protocol connecting to our router.
/ip firewall layer7-protocol add comment="" name=telnet regexp="^\\xff[\\xfb-\\xfe].\\xff[\\xfb-\\xfe].\\xff[\\xfb-\\xfe]"

Note that we need both directions which is why we need also the l7 rule in the output chain that sees outgoing packets.
/ip firewall filter

add action=accept chain=input comment="" disabled=no layer7-protocol=telnet \
    protocol=tcp

add action=passthrough chain=output comment="" disabled=no layer7-protocol=telnet \
    protocol=tcp
Youtube Matcher

When a user is logged in YouTube will use HTTPS, meaning that L7 will not be able to match this traffic. Only unencrypted HTTP can be matched.


/ip firewall layer7-protocol
add name=youtube regexp="(GET \\/videoplayback\\\?|GET \\/crossdomain\\.xml)"






    Creado por Artūrs C., actualizado por última vez por GG el abr 23, 2024 2 min de lectura

    Summary
    Properties

Summary
/ip firewall address-list

Firewall address lists allow a user to create lists of IP addresses grouped together under a common name. Firewall filter, mangle, and NAT facilities can then use those address lists to match packets against them.

The address list records can also be updated dynamically via the action=add-src-to-address-list or action=add-dst-to-address-list items found in NAT, Mangle, and Filter facilities.

Firewall rules with action add-src-to-address-list or add-dst-to-address-list work in passthrough mode, which means that the matched packets will be passed to the next firewall rules.
Properties
address (DNS Name | IP address/netmask | IP-IP; Default: )	A single IP address or range of IPs to add to the address list or DNS name. You can input for example, '192.168.0.0-192.168.1.255' and it will auto modify the typed entry to 192.168.0.0/23 on saving.
dynamic (yes, no)	Allows creating data entry with dynamic form.
list (string; Default: )	Name for the address list of the added IP address.
timeout (time; Default: )	Time after address will be removed from the address list. If the timeout is not specified, the address will be stored in the address list permanently.
creation-time (time; Default: )	The time when the entry was created.


If the timeout parameter is not specified, then the address will be saved to the list permanently on the disk. If a timeout is specified, the address will be stored on the RAM and will be removed after a system's reboot.

Example

The following example creates a dynamic address list of people who are connecting to port 23 (telnet) on the router and drops all further traffic from them for 5 minutes. Additionally, the address list will also contain one static address list entry of 192.0.34.166/32 (www.example.com):
/ip firewall address-list add list=drop_traffic address=192.0.34.166/32
/ip firewall address-list print
Flags: X - disabled, D - dynamic
 #   LIST         ADDRESS
 0   drop_traffic 192.0.34.166
/ip firewall mangle add action=add-src-to-address-list address-list=drop_traffic address-list-timeout=5m chain=prerouting dst-port=23 protocol=tcp
/ip firewall filter add action=drop chain=input src-address-list=drop_traffic
/ip firewall address-list print
Flags: X - disabled, D - dynamic
 #   LIST         ADDRESS
 0   drop_traffic 192.0.34.166
 1 D drop_traffic 1.1.1.1
 2 D drop_traffic 10.5.11.8

As seen in the output of the last print command, two new dynamic entries appeared in the address list (marked with a status of 'D'). Hosts with these IP addresses tried to initialize a telnet session to the router and were then subsequently dropped by the filter rule.



    Creado por Māris B., actualizado por última vez por Gļebs K. el mar 24, 2025 24 min de lectura

    Understanding Packet Flow
        Overall Packetflow Diagram
            Chains
        Flow of Routed Packet
            Forward
            Input
            Output
        Flow of Bridged Packet
            Bridge Forward
            Bridge Input
            Bridge Output
            Forward With Firewall Enabled
        Flow of Hardware Offloaded Packet
            Switch Forward
            Switch to CPU Input
            CPU Output to Switch
        Flow of MPLS Packet
            Pop Label
            Switch Label
            Push Label
        MPLS IP VPN
        Logical Interfaces
        IPSec Policies
    Fast Path
        How Fast Path Works
    FastTrack
        Configuration example: excluding specific host, from being Fast-Tracked
        Requirements
    Packet flow for the visually impaired


Understanding Packet Flow

More advanced firewall setups, or complicated tasks, such as traffic prioritization, routing policies, where it is necessary to utilize more than one RouterOS facility, require knowledge: How do these facilities work together? What happens when and why?

RouterOS packet flow diagram and flow examples will try to answer these questions.

It would be very complicated to represent what is going on with the packet in one diagram, therefore a packet flow diagram is divided into three parts:

    overall diagram;
    detailed bridging, routing, and MPLS flow diagram;
    a diagram that shows what facilities and in what order are included in prerouting, input, forward, output, and postrouting.

Overall Packetflow Diagram

Let's look at the overall diagram. It looks complicated at first, but after we go through the diagram with examples it will become much clearer.


There are 4 boxes in the center of the diagram: Bridging, Routing, Mpls decisions, and local router processes. So for example, if the packet needs to be routed over the router, a packet will flow as illustrated in the image below. Without looking deeper into each facility, the packet enters the in-interface, the router determines that it is IP traffic and needs to be routed, the packet goes through all routing processes and exits the out-interface.

Let's take a look at another example that will illustrate what happens if the packet's destination is a router. For example, the in-interface receives ICMP (ping) packet, its destination is the router itself, so the packet will go for local-in processing. After the packet is processed ICMP (ping) reply is generated inside the router (local-out processing) and will be sent out over the out-interface.

A simple explanation of each box before we go further with examples:

    physical in-interface - the starting point of the packet received by the router;
    logical in-interface - the starting point of the decapsulated packet (from tunnels, IPsec, etc);
    local in - the last point of a packet destined to router itself;
    interface HTB (Hierarchical Token Bucket) - interface queue;
    physical out-interface - last point of the packet before it is actually sent out;
    logical out-interface - last point of the packet before encapsulation (to tunnels, IPsec, etc);
    local out - the starting point of a packet generated by the router;


Now it is time to take a deeper look at what is happening inside bridging, MPLS, and routing flows.

A simple explanation of each box before we go further with examples:

    routing decision - go through routes in the routing table to find a match for the destination IP address of the packet. When a match is found - the packet will be processed further, in case of no match - the packet will be discarded.;
    mpls decision - what to do with the packet based on MPLS forwarding tables;
    bridging decision - bridge goes through the MAC address table to find a match for the destination MAC address of the packet. When a match is found - the packet will be processed further, in case of no match - multiple copies of the packet will be created and packets will be flooded (sent out via all bridge ports). A single packet copy will also reach a bridge input chain as the bridge interface itself is one of the many destinations. When using vlan-filtering=yes, packets that are not allowed due to the "/interface bridge vlan" table, will be dropped at this stage.
    use-ip-firewall - whether a 'use-ip-firewall' option is enabled in bridge settings;
    ipsec-policy - whether a packet matches any of configured IPsec policies;

Chains

RouterOS consist of a few default chains. These chains allow you to filter packets at various points:

    The PREROUTING chain: Rules in this chain apply to packets as they just arrive on the network interface. This chain is present in the nat, mangle and raw tables.
    The INPUT chain: Rules in this chain apply to packets just before they’re given to a local process. This chain is present in the mangle and filter tables.
    The OUTPUT chain: The rules here apply to packets just after they’ve been produced by a process. This chain is present in the raw, mangle, nat, and filter tables.
    The FORWARD chain: The rules here apply to any packets that are routed through the current host. This chain is only present in the mangle and filter tables.
    The POSTROUTING chain: The rules in this chain apply to packets as they just leave the network interface. This chain is present in the nat and mangle tables.

Each of the prerouting, input, forward, output, and postrouting blocks contains even more facilities, which are illustrated in the third part of the packet flow diagram:


A simple explanation of each box before we go further with examples:

    Hotspot-in - allows to capture traffic that otherwise would be discarded by connection tracking - this way our Hotspot feature is able to provide connectivity even if networks settings are an incomplete mess ;
    RAW Prerouting - RAW table prerouting chain;
    Connection tracking - packet is processed by connection tracking;
    Mangle Prerouting - Mangle prerouting chain;
    Mangle Input - Mangle input chain;
    Filter Input - Firewall filter input chain;
    HTB Global - Queue tree;
    Simple Queues - is a feature that can be used to limit traffic for a particular target;
    TTL - indicates an exact place where the Time To Live (TTL) of the routed packet is reduced by 1 if TTL becomes 0, a packet will be discarded;
    Mangle Forward - Mangle forward chain;
    Filter Forward - Filter forward chain;
    Accounting - Authentication, Authorization, and Accounting feature processing;
    RAW Output - RAW table output chain;
    Mangle Output - Mangle output chain;
    Filter Output - Firewall filter output chain;
    Routing Adjustment - this is a workaround that allows to set up policy routing in mangle chain output (routing-mark) ;
    Mangle Postrouting - Mangle postrouting chain;
    Src Nat - Network Address Translation srcnat chain;
    Dst Nat - Network Address Translation dstnat chain;
    Hotspot-out - undo all that was done by hotspot-in for the packets that are going back to the client;


Flow of Routed Packet
Forward

Now, let's take our first example where the packet gets routed over the router and look deeper through what facilities packet goes:

We already learned that packet goes into the in-interface, the router determines that it is an IP packet and needs to be routed, and here starts the complicated process:

     The packet enters prerouting processing:
        check if there is a hotspot and modify the packet for hotspot use
        process packet through RAW prerouting chain;
        send the packet through connection tracking;
        process packet through Mangle prerouting chain;
         process packet through NATs dst-nat chain;
    Run packet through routing table to make routing decision;
    The packet enters the forward process;
        check TTL value;
        process packet through Mangle forward chain;
        process packet through the Filter forward chain;
        send the packet to accounting processes;

    A packet enters postrouting process;
        process packet through Mangle postrouting chain;
        process packet through NATs src-nat chain;
        if there is a hotspot undo any modifications made in hotspot-in;
        process packet through queue tree (HTB Global);
        process packet through simple queues;

    Check if there is IPsec and then process through IPsec policies;


Input

We already learned that packet goes into the in-interface, the router determines that it is an IP packet and needs to be routed, and here starts the complicated process:

    A very similar process happens when a packet's destination is a router (routing input): Packet enters prerouting processing:
        - check if there is a hotspot and modify the packet for hotspot use;
        - process packet through RAW prerouting chain;
        - send a packet through connection tracking;
        - process packet through Mangle prerouting chain;
        - process packet through NATs dst-nat chain;

    Run packet through routing table to make routing decision;

    A Packet enters the input process;
        - process packet through Mangle input chain;
        - process packet through Filter input chain;
        - process packet through queue tree (HTB Global);
        - process packet through simple queues;

    Check if there is IPsec and then process through IPsec policies.

Output

Or when a packet is originated from the router (routing output):

    The packet is originated from the router itself
        the packet goes through the routing table to make a routing decision

    A packet enters the output process
        process packet through the Bridge decision;
        send the packet through connection tracking;
        process packet through the Mangle output chain;
        process packet through the Filter output chain;
        send the packet to routing adjustment ( policy routing)

     The packet enters postrouting process; 
        - process packet through Mangle postrouting chain;
        - process packet through NATs src-nat chain;
        - if there is a hotspot undo any modifications made in hotspot-in;
        - process packet through queue tree (HTB Global);
        - process packet through simple queues;

    Check if there is IPsec and then process through IPsec policies;



Flow of Bridged Packet

Below is discussed a general bridging process in RouterOS. Most of the packets will always follow the same processing path, but in certain configurations (e.g. with enabled VLAN filtering, horizon, STP, DHCP, or IGMP snooping) some packets can be treated differently. Please visit the bridging manual for more specific information.
Bridge Forward

Bridge forward is a process that takes place when a packet is forwarded from one bridge port to another, essentially connecting multiple devices on the same network. After receiving a packet on the in-interface, the device determines that the in-interface is a bridge port, so it gets passed through the bridging process:

    A packet goes through the bridge NAT dst-nat chain, where MAC destination and priority can be changed, apart from that, a packet can be simply accepted, dropped, or marked;
    Checks whether the use-ip-firewall option is enabled in the bridge settings;
    Run packet through the bridge host table to make a forwarding decision. A packet that ends up being flooded (e.g. broadcast, multicast, unknown unicast traffic), gets multiplied per bridge port and then processed further in the bridge forward chain. When using vlan-filtering=yes, packets that are not allowed due to the "/interface bridge vlan" table, will be dropped at this stage.
    A packet goes through the bridge filter forward chain, where priority can be changed or the packet can be simply accepted, dropped, or marked;
    Checks whether the use-ip-firewall option is enabled in the bridge settings;
    A packet goes through the bridge NAT src-nat chain, where MAC source and priority can be changed, apart from that, a packet can be simply accepted, dropped, or marked;
    Checks whether the use-ip-firewall option is enabled in the bridge settings;


For RouterOS v6:
When bridge vlan-filtering is enabled, received untagged packets might get encapsulated into the VLAN header before the "DST-NAT" block, which means these packets can be filtered using the mac-protocol=vlan and vlan-encap settings. Encapsulation can happen if the outgoing interface has frame-types set to admit-all or admit-only-untagged-and-priority-tagged.

Tagged packets might get decapsulated on the "BRIDGING DECISION" block, which means these packets will no longer match the mac-protocol=vlan and vlan-encap settings. Decapsulation can happen if the packet's VLAN ID matches the outgoing port's untagged VLAN membership.

For RouterOS v7 and newer:

When bridge vlan-filtering is enabled, received untagged packets might get encapsulated into the VLAN header on the "BRIDGING-DECISION" block, which means these packets can be filtered using the mac-protocol=vlan and vlan-encap settings.  Encapsulation can happen if the outgoing interface has frame-types set to admit-all or admit-only-untagged-and-priority-tagged.

Tagged packets might get decapsulated on the "BRIDGING DECISION" block, which means these packets will no longer match the mac-protocol=vlan and vlan-encap settings. Decapsulation can happen if the packet's VLAN ID matches the outgoing port's untagged VLAN membership.
Bridge Input

Bridge input is a process that takes place when a packet is destined for the bridge interface. Most commonly this happens when you need to reach some services that are running on the bridge interface (e.g. a DHCP server) or you need to route traffic to other networks. The very first steps are similar to the bridge forward process - after receiving a packet on the in-interface, the device determines that the in-interface is a bridge port, so it gets passed through the bridging process:

    A packet goes through the bridge NAT dst-nat chain, where MAC destination and priority can be changed, apart from that, a packet can be simply accepted, dropped, or marked;
    Checks whether the use-ip-firewall option is enabled in the bridge settings;
    Run packet through the bridge host table to make a forwarding decision. A packet where the destination MAC address matches the bridge MAC address will be passed to the bridge input chain. A packet that ends up being flooded (e.g. broadcast, multicast, unknown unicast traffic), also reaches the bridge input chain as the bridge interface itself is one of the many destinations;
    A packet goes through the bridge filter input chain, where priority can be changed or the packet can be simply accepted, dropped, or marked;

