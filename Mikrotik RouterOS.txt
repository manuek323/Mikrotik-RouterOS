
High Availability Solutions

    Creado por Usuario desconocido (emils), actualizado por última vez el may 31, 2022 1 min de lectura

In This Section:

        Load Balancing
        Bonding
        Bonding Examples
        HA Case Studies
        Multi-chassis Link Aggregation Group
        VRRP
        VRRP Configuration Examples




    Creado por Artūrs C., actualizado por última vez por Māris B. el abr 03, 2024 1 min de lectura

    Failover (WAN Backup)
    Per connection classifier


Introduction

Network load balancing is the ability to balance traffic across two or more links without using dynamic routing protocols.

There are two type of balancing methods:

    per-packet - each packet of a single stream can be forwarded over different links. This method will work reliably especially on TCP and secure connections only when you are able to control both balancing endpoints.
    per-connection - all packets of the same connection (stream) is always sent over one link. This method is mandatory in setups where only one end of the balancing is under our control, for example, home router with multiple WAN connections.


Method	Per-connection	Per-packet


Firewall Mangle
	Nth	Yes	Yes
PCC (Per Connection Classifier)	Yes	No
Other matchers	Yes	Yes
ECMP (Equal Cost Multi-Path)	Yes	No
Bonding	No	Yes
OSPF	Yes	No
BGP	Yes	No

 
Simple Failover Example

Simplest failover setup would be to use multiple gateways when one gateway is active and another one takes over when the first one fails.

To make this work, configure larger distance value for the secondary one, and check-gateway for the first one:
/ip route add gateway=192.168.1.1 distance=1 check-gateway=ping
/ip route add gateway=192.168.2.1 distance=2

The check-gateway will make sure the gateway is up only when actual traffic can reach the gateway. When the ping fails the first gateway will become inactive and the second one will take over,  and when the first gateway recovers  it will become active and make the second gateway to work again as a backup.





    Creado por Artūrs C., actualizado por última vez por Māris B. el nov 07, 2024 2 min de lectura

Introduction

In this article, we will look at another advanced method of failover using recursive routing and scopes from the routing section. Recursive routing occurs when a route (either static or dynamically learned) has a next-hop that is not directly connected to the local router. It is necessary to restrict a set of routes that can be used to look up immediate next-hops. Nexthop values of RIP or OSPF routes, for example, are supposed to be directly reachable and should be looked up only using connected routes. This is achieved using a scope and target-scope properties.
Setup Overview

Let's assume that our gateway has two public network uplinks ("ISP1", "ISP2"). First uplink should be preferred and second one should act as a backup. 

Then we mark traffic in two parts, one with the name "ISP1" and the second as "ISP2" which goes through the ether1 and ether2 accordingly. In this setup, we want to monitor two hosts: Host1 and Host2. We will use Google DNS servers with IP 8.8.8.8 (Host1) and 8.8.4.4 (Host2), but it is not mandatory to use specifically these addresses.



Configuration
Basic failover

First things first, since we have a local address space we need to masquerade LAN traffic on both uplinks:
/ip/firewall/nat
add chain=srcnat action=masquerade out-interface=ether1
add chain=srcnat action=masquerade out-interface=ether2

Next we want to pick tow hosts on the internet and make them reachable each on its own uplink. Generally you would pick hosts that are always supposed to be reachable, accepts ICMP, in this example we will use google DNS servers (8.8.8.8 and 8.8.4.4).
/ip/route/ 
add dst-address=8.8.8.8 scope=10 gateway=10.111.0.1
add dst-address=8.8.4.4 scope=10 gateway=10.112.0.1

And add default routes recursively resolved over both hosts with ISP1 being the primary one (by having smaller distance):
/ip/route/
add distance=1 gateway=8.8.8.8 target-scope=11 check-gateway=ping
add distance=2 gateway=8.8.4.4 target-scope=11 check-gateway=ping


Improve detection reliability

At this point we are relying link reachability on a single host. Even though google services are very rarely down we can still improve reliability by adding a second host on each link.
/ip/route
add dst-address=208.67.222.222 gateway=10.111.0.1 scope=10
add dst-address=208.67.220.220 gateway=10.112.0.1 scope=10

add distance=1 gateway=208.67.222.222 target-scope=11 check-gateway=ping
add distance=2 gateway=208.67.220.220 target-scope=11 check-gateway=ping

Essentially what it does is creates ECMP default route and if only one of the gateways is not reachable default route on the first link will still be active. Complete switchover to second link will happen only if all the gateways become unreachable.




    Creado por GG, actualizado por última vez por Gļebs K. el feb 23, 2024 8 min de lectura

PCC matcher will allow you to divide traffic into equal streams with the ability to keep packets with specific set of options in one particular stream (you can specify this set of options from src-address, src-port, dst-address, dst-port)

    Theory
    Example
    How PCC works
    Configuration Example
    IP Addresses
    Policy routing
    NAT

Theory

PCC takes selected fields from IP header, and with the help of a hashing algorithm converts selected fields into 32-bit value. This value then is divided by a specified Denominator and the remainder then is compared to a specified Remainder, if equal then the packet will be captured. You can choose from src-address, dst-address, src-port, dst-port from the header to use in this operation.

PCC is not a valid method, in case of Hotspot(captive portal) -  due to the fact  that Hotspot  uses web-proxy and it uses only the default routing table, at the moment.
per-connection-classifier=
PerConnectionClassifier ::= [!]ValuesToHash:Denominator/Remainder
  Remainder ::= 0..4294967295    (integer number)
  Denominator ::= 1..4294967295    (integer number)
  ValuesToHash ::= both-addresses|both-ports|dst-address-and-port|
  src-address|src-port|both-addresses-and-ports|dst-address|dst-port|src-address-and-port 
Example

This configuration will divide all connections into 3 groups based on the source address and port
/ip firewall mangle add chain=prerouting action=mark-connection \
 new-connection-mark=1st_conn per-connection-classifier=src-address-and-port:3/0
/ip firewall mangle add chain=prerouting action=mark-connection \
  new-connection-mark=2nd_conn per-connection-classifier=src-address-and-port:3/1
/ip firewall mangle add chain=prerouting action=mark-connection \
  new-connection-mark=3rd_conn per-connection-classifier=src-address-and-port:3/2
How PCC works

This article aims to explain in simple terms how PCC works. The definition from the official manual wiki page reads: "PCC takes selected fields from IP header, and with the help of a hashing algorithm converts selected fields into 32-bit value. This value then is divided by a specified Denominator and the remainder then is compared to a specified Remainder, if equal then packet will be captured. You can choose from src-address, dst-address, src-port, dst-port from the header to use in this operation.", with the full number of fields available being: "both-addresses|both-ports|dst-address-and-port|src-address|src-port|both-addresses-and-ports|dst-address|dst-port|src-address-and-port". If you understand that definition, there'll be nothing interesting in this article for you.

First, here are the terms necessary to understand the definition.

IP packets have a header that contains several fields, two of those fields are the IP address of the source of the packet and the IP address of the destination of the packet. TCP and UDP packets also have headers that contain the source port and the destination port.

Denominators and remainders are parts of modulus operations. A modulus operation produces the integer left over when you divide two numbers and only accept the whole number portion of the result. It is represented by a % sign. Here are some examples: 3 % 3 = 0, because 3 divides cleanly by 3. 4 % 3 = 1, because the next smallest number to 4 that cleanly divides by 3 is 3, and 4 - 3 = 1. 5 % 3 is 2, because the next smallest number to 5 that divides cleanly by 3 is 3, and 5 - 3 = 2. 6 % 3 = 0, because 6 divides cleanly by 3.

A hash is a function that is fed input, and produces output. Hashes have many interesting properties, but the only important one for the purpose of this article is that hash functions are deterministic. That means that when you feed a hash function an input that reads 'hello' and it produces the output '1', you can rely on the fact that if you feed it 'hello' a second time it will produce the output '1' again. When you feed a hash function the same input, it will always produce the same output. What exact hashing algorithm is used by PCC is not important, so for this discussion let's assume that when you feed it IP addresses and ports, it just adds up the octets of the IP addresses as decimal numbers as well as the ports, and then takes the last digit and produces it as the output. Here an example:

The hash function is fed 1.1.1.1 as the source IP address, 10000 as the source TCP port, 2.2.2.2 as the destination IP address and 80 as the destination TCP port. The output will be 1+1+1+1+10000+2+2+2+2+80 = 10092, the last digit of that is 2, so the hash output is 2. It will produce 2 every time it is fed that combination of IP addresses and ports.

At this point it's important to note that even though PCC is most often used for spreading load across circuits, PCC itself has absolutely nothing to do with routing, routing marks or spreading load. PCC is simply a way to match packets, and not directly related to the action of then marking those matched packets even if that is its main purpose.

Here are three lines often used for PCC, with their explanation:
/ip firewall mangle add chain=prerouting action=mark-connection \
 new-connection-mark=1st_conn per-connection-classifier=src-address-and-port:3/0
/ip firewall mangle add chain=prerouting action=mark-connection \
  new-connection-mark=2nd_conn per-connection-classifier=src-address-and-port:3/1
/ip firewall mangle add chain=prerouting action=mark-connection \
  new-connection-mark=3rd_conn per-connection-classifier=src-address-and-port:3/2

Here are what the different field options mean for the purpose of packet matching, these are the fields that will be fed into the hashing algorithm (and, for the purpose of spreading load across links, decide what link a packet will be put on). Remember that a hash function will always produce the same input when it's fed the same output:

    src-address: The source address of a client will always be the same, so all traffic from a particular client will always match the same PCC matcher, and will always be put on the same link.
    dst-address: The destination address of a specific server will always be the same, so all traffic to that server (say, the Mikrotik Wiki) will always match the same PCC matcher, and will always be put on the same link.
    both-addresses: The source and destination IP pair between the same client and server will always be the same, so all traffic between one specific client and a specific server (say, your laptop and the Mikrotik Wiki) will always match the same PCC matcher, and will always be put on the same link.
    src-port: Source ports of clients are usually randomly chosen when the connection is created, so across many connections different source ports will be fed into the hash function, and different PCC matchers will match and traffic will go across different links. However, some client protocols always choose the same source port, and servers behind your router will mostly likely always use the same service port to send traffic back to their clients. A web server behind your router would send most traffic from its HTTP (80) and HTTPS (443) ports, and that traffic would always match the same PCC matcher and would be put on the same link.
    dst-port: Destination ports of clients are usually well defined service ports, all HTTP (80) traffic between your clients and servers on the Internet would always match the same PCC matcher, and would be put on the same link. However, the same clients doing HTTPS (443) traffic could match a different PCC matcher, and would go across a different link.
    both-ports: Since the client port is (usually) randomly chosen, the combination of the two ports is (usually) random and will spread load across links.
    src-address-and-port: Same caveat as src-port.
    dst-address-and-port: Same caveat as dst-port.
    both-addresses-and-ports: This is the most random way to spread traffic across links, since it has the most number of variables.

It's important to note that even though the hash function discussed in this article is greatly simplified and not what is used in real life, it nicely demonstrates another property of hash functions: two completely different inputs can produce the same output. In our example, 3 % 3 = 0, and 6 % 3 = 0; we get back 0 when we feed it a 3 as well as when we feed it a 6. The same is true for the actual function used for PCC, even though I don't know what it is we do know from the definition that it produces a 32 bit value as output. IP addresses are 32 bit, and ports are 16 bit, so assuming that we're using both-addresses-and-ports, we'd be feeding it 32+32+16+16 = 96 bits of input and would only receive 32 bits back, so it must be producing the same output for different inputs. This means that two completely unrelated connections could match the same PCC matcher, and would be put on the same line. PCC works better the more connections you put across it so that the hash function has more chances to produce different outputs.


Configuration Example

Let's assume this configuration:


IP Addresses
/ip address
add address=10.10.4.100/24 interface=ether_ISP1 network=10.10.4.0
add address=10.10.5.100/24 interface=ether_ISP2 network=10.10.5.0
add address=192.168.100.1/24 interface=ether_LAN network=192.168.100.0

The router has two upstream (ISP) interfaces with the addresses of 10.10.4.100/24 and 10.10.5.100/24. The LAN interface has IP address of 192.168.0.1/24.


We are adding two new Routing tables, which will be used later:
/routing table
add disabled=no fib name=ISP1_table
add disabled=no fib name=ISP2_table
Policy routing
/ip firewall mangle
add action=accept chain=prerouting dst-address=10.10.4.0/24 in-interface=ether_LAN
add action=accept chain=prerouting dst-address=10.10.5.0/24 in-interface=ether_LAN

With policy routing it is possible to force all traffic to the specific gateway, even if traffic is destined to the host (other that gateway) from the connected networks. This way routing loop will be generated and communications with those hosts will be impossible. To avoid this situation we need to allow usage of default routing table for traffic to connected networks.
add action=mark-connection chain=input connection-state=new in-interface=ether_ISP1 new-connection-mark=ISP1
add action=mark-connection chain=input connection-state=new in-interface=ether_ISP2 new-connection-mark=ISP2

add action=mark-connection chain=output connection-mark=no-mark connection-state=new new-connection-mark=ISP1 passthrough=yes per-connection-classifier=both-addresses:2/0
add action=mark-connection chain=output connection-mark=no-mark connection-state=new new-connection-mark=ISP2 per-connection-classifier=both-addresses:2/1

First it is necessary to manage connection initiated from outside - replies must leave via same interface (from same Public IP) request came. We will mark all new incoming connections, to remember what was the interface.
add action=mark-connection chain=prerouting connection-mark=no-mark connection-state=new dst-address-type=!local in-interface=ether_LAN new-connection-mark=ISP1 per-connection-classifier=both-addresses:2/0
add action=mark-connection chain=prerouting connection-mark=no-mark connection-state=new dst-address-type=!local in-interface=ether_LAN new-connection-mark=ISP2 per-connection-classifier=both-addresses:2/1

Action mark-routing can be used only in mangle chain output and prerouting, but mangle chain prerouting is capturing all traffic that is going to the router itself. To avoid this we will use dst-address-type=!local. And with the help of the new PCC we will divide traffic into two groups based on source and destination addressees.
add action=mark-routing chain=output connection-mark=ISP1 new-routing-mark=ISP1_table
add action=mark-routing chain=prerouting connection-mark=ISP1 in-interface=ether_LAN new-routing-mark=ISP1_table

add action=mark-routing chain=output connection-mark=ISP2 new-routing-mark=ISP2_table
add action=mark-routing chain=prerouting connection-mark=ISP2 in-interface=ether_LAN new-routing-mark=ISP2_table

Then we need to mark all packets from those connections with a proper mark. As policy routing is required only for traffic going to the Internet, do not forget to specify in-interface option.
/ip route
add check-gateway=ping disabled=no dst-address=0.0.0.0/0 gateway=10.10.4.1 routing-table=ISP1_table suppress-hw-offload=no
add check-gateway=ping disabled=no dst-address=0.0.0.0/0 gateway=10.10.5.1 routing-table=ISP2_table suppress-hw-offload=no

Create a route for each routing-mark
add distance=1 dst-address=0.0.0.0/0 gateway=10.10.4.1
add distance=2 dst-address=0.0.0.0/0 gateway=10.10.5.1

To enable failover, it is necessary to have routes that will jump in as soon as others will become inactive on gateway failure. (and that will happen only if check-gateway option is active)
NAT
/ip firewall nat
add action=masquerade chain=srcnat out-interface=ether_ISP1
add action=masquerade chain=srcnat out-interface=ether_ISP2

As routing decision is already made we just need rules that will fix src-addresses for all outgoing packets. If this packet will leave via ether_ISP1 it will be NATed to 10.10.4.100, if via ether_ISP2 then NATed to 10.10.5.100



    Creado por Māris B., actualizado por última vez por Edgars P. el jun 03, 2025 13 min de lectura

    Summary
    Quick Setup Guide
    Link monitoring
        ARP Monitoring
        MII monitoring
    Bonding modes
        802.3ad
        balance-xor
        balance-rr
        active-backup
        broadcast
        balance-tlb
            Configuration example
        balance-alb
    Bonding monitoring
    Property Description
    See also

Summary

Bonding is a technology that allows aggregation of multiple ethernet-like interfaces into a single virtual link, thus getting higher data rates and providing failover. 

Interface bonding does not create an interface with a larger link speed. Interface bonding creates a virtual interface that can load balance traffic over multiple interfaces. More details can be found in the LAG interfaces and load balancing page.


CRS3xx, CRS5xx series switches, CCR2116, CCR2216 routers and 88E6393X, 88E6191X, 88E6190 switch chips support bridge hardware offloading with bonding interfaces. Only 802.3ad and balance-xor bonding modes are hardware offloaded, other bonding modes will use the CPU's resources. The built-in switch chip will always use Layer2+Layer3+Layer4 for a transmit hash policy, changing the transmit hash policy manually will have no effect. See more details on CRS3xx, CRS5xx, CCR2116, CCR2216 switch chip features.


Quick Setup Guide

Let us assume that we have two Ethernet interfaces on each router (Router1 and Router2) and want to get the maximum data rate between these two routers. To make this possible, follow these steps:

    Make sure that you do not have IP addresses on interfaces that will be enslaved for bonding interface.

    Add bonding interface and IP address on the Router1:

/interface bonding add slaves=ether1,ether2 name=bond1
/ip address add address=172.16.0.1/24 interface=bond1

Do the same thing on the Router2:
/interface bonding add slaves=ether1,ether2 name=bond1
/ip address add address=172.16.0.2/24 interface=bond1

Test the link from Router1:

    [admin@Router1] > ping 172.16.0.2
      SEQ HOST                                 SIZE TTL TIME  STATUS                   
        0 172.16.0.2                             56  64 0ms  
        1 172.16.0.2                             56  64 0ms  
        2 172.16.0.2                             56  64 0ms  
        sent=3 received=3 packet-loss=0% min-rtt=0ms avg-rtt=0ms max-rtt=0ms

The bonding interface needs a couple of seconds to get connectivity with its peers.
Link monitoring

It is critical that one of the available link monitoring options is enabled. In the above example, if one of the bonded links were to fail, the bonding driver will still continue to send packets over the failed link which will lead to network degradation. Bonding in RouterOS currently supports two schemes for monitoring a link state of slave devices: MII and ARP monitoring. It is not possible to use both methods at the same time due to restrictions in the bonding driver.
ARP Monitoring

ARP monitoring sends ARP queries and uses the response as an indication that the link is operational. The ARP replies are not validated, any received packet by the slave interface will result in the slave interface considered as active. This gives assurance that traffic is actually flowing over the links. If balance-rr and balance-xor modes are set, then the switch should be configured to evenly distribute packets across all links. Otherwise, all replies from the ARP targets will be received on the same link which could cause other links to fail. ARP monitoring is enabled by setting three properties - link-monitoring, arp-ip-targets and arp-interval. The meaning of each option is described later in this article. It is possible to specify multiple ARP targets that can be useful in High Availability setups. If only one target is set, the target itself may go down. Having additional targets increases the reliability of the ARP monitoring.

To enable ARP monitoring on Router1:
/interface bonding set [find name=bond1] link-monitoring=arp arp-ip-targets=172.16.0.2

and Router2:
/interface bonding set [find name=bond1] link-monitoring=arp arp-ip-targets=172.16.0.1

We will not change the arp-interval value in our example, RouterOS sets arp-interval to 100ms by default. Unplug one of the cables to test if the link monitoring works correctly, you might notice some ping timeouts until arp monitoring detects link failure.
[admin@MikroTik] > ping 172.16.0.2
  SEQ HOST                                     SIZE TTL TIME  STATUS                                 
    0 172.16.0.2                                 56  64 0ms  
    1 172.16.0.2                                 56  64 0ms  
    2 172.16.0.2                                 56  64 0ms  
    3 172.16.0.2                                 56  64 0ms  
    4 172.16.0.2                                              timeout                                
    5 172.16.0.2                                 56  64 0ms  
    6 172.16.0.2                                 56  64 0ms  
    sent=7 received=6 packet-loss=14% min-rtt=0ms avg-rtt=0ms max-rtt=0ms


For ARP monitoring to work properly it is not required to have any IP address on the device, ARP monitoring will work regardless of the IP address that is set on any interface.

When ARP monitoring is used, bonding slaves will send out ARP requests without a VLAN tag, even if an IP address is set on a VLAN interface in the same subnet as the arp-ip-targets
MII monitoring

MII monitoring monitors only the state of the local interface. MII Type 1 - a device driver determines whether a link is up or down. If the device driver does not support this option then the link will appear as always up. The main disadvantage is that MII monitoring can't tell if the link can actually pass packets or not, even if the link is detected as being up. MII monitoring is configured by setting the variables - link-monitoring and mii-interval.

To enable MII Type1 monitoring on Router1 and Router2:
/interface bonding set [find name=bond1] link-monitoring=mii

We will leave mii-interval to its default value (100ms). When unplugging one of the cables, the failure will be detected almost instantly compared to ARP link monitoring.
Bonding modes
802.3ad

802.3ad mode is an IEEE standard also called LACP (Link Aggregation Control Protocol). It includes automatic configuration of the aggregates, so minimal configuration of the switch is needed. This standard also mandates that frames will be delivered in order and connections should not see misordering of packets. The standard also mandates that all devices in the aggregate must operate at the same speed and duplex mode.

LACP balances outgoing traffic across the active ports based on hashed protocol header information and accepts incoming traffic from any active port. The hash includes the Ethernet source and destination address and if available, the VLAN tag, and the IPv4/IPv6 source and destination address. How this is calculated depends on transmit-hash-policy parameter. The ARP link monitoring is not recommended, because the ARP replies might arrive only on one slave port due to transmit hash policy on the LACP peer device. This can result in unbalanced transmitted traffic, so MII link monitoring is the recommended option.

The layer-3-and-4 transmit hash mode is not fully compatible with LACP. More details can be found in https://www.kernel.org/doc/Documentation/networking/bonding.txt
balance-xor

This mode balances outgoing traffic across the active ports based on the hashed protocol header information and accepts incoming traffic from any active port. The mode is very similar to LACP except that it is not standardized and works with layer-3-and-4 hash policy. The mode can work together with static Link Aggregation Group (LAG) interfaces.
balance-rr

If this mode is set, packets are transmitted in sequential order from the first available slave to the last. The balance-rr is the only mode that will send packets across multiple interfaces that belong to the same TCP/IP connection. When utilizing multiple sending and multiple receiving links, packets are often received out of order, which results in segment retransmission, for other protocols such as UDP it is not a problem if a client software can tolerate out-of-order packets. If a switch is used to aggregate links together, then appropriate switch port configuration is required, however many switches do not support balance-rr. Quick setup guide demonstrates the usage of the balance-rr bonding mode. As you can see, it is quite simple to set up. Balance-rr is also useful for bonding several wireless links, however, it requires equal bandwidth for all bonded links. If the bandwidth of one bonded link drops, then the total bandwidth of bond will be equal to the bandwidth of the slowest bonded link.
active-backup

This mode uses only one active slave to transmit packets. The additional slave only becomes active if the primary slave fails. The MAC address of the bonding interface is presented onto the active port to avoid confusing the switch. Active-backup is the best choice in high availability setups with multiple switches that are interconnected.

The ARP monitoring in this mode will not work correctly if both routers are directly connected. In such setups, MII monitoring must be used or a switch should be put between routers.
broadcast

When ports are configured with broadcast mode, all slave ports transmit the same packets to the destination to provide fault tolerance. This mode does not provide load balancing.
balance-tlb

This mode balances outgoing traffic by peer. Each link can be a different speed and duplex mode and no specific switch configuration is required as for the other modes. The downside of this mode is that only MII link monitoring is supported (ARP link monitoring is ignored when configured) and incoming traffic is not balanced. Incoming traffic will use the link that is configured as "primary".
Configuration example

Let's assume that the router has two links - ether1 max bandwidth is 10Mbps and ether2 max bandwidth is 5Mbps. The first link has more bandwidth so we set it as a primary link:
/interface bonding add mode=balance-tlb slaves=ether1,ether2 primary=ether1

No additional configuration is required for the switch. The image above illustrates how balance-tlb mode works. As you can see router can communicate to all the clients connected to the switch with a total bandwidth of both links (15Mbps). But as you already know, balance-tlb is not balancing incoming traffic. In our example, clients can communicate to the router with a total bandwidth of primary link which is 10Mbps in our configuration.
balance-alb

The mode is basically the same as balance-tlb but incoming IPv4 traffic is also balanced. The receive load balancing is achieved by ARP negotiation. The bonding driver intercepts locally generated ARP messages on their way out and overwrites the source hardware address with the unique address of one of the slaves in the bond such that different peers use different hardware addresses. Only MII link monitoring is supported (ARP link monitoring is ignored when configured), the additional downside of this mode is that it requires device driver capability to change MAC address. The mode is not compatible with local-proxy-arp setting.


The image above illustrates how balance-alb mode works. Compared to balance-tlb mode, traffic from clients can also use the secondary link to communicate with the router.
Bonding monitoring

Since RouterOS 6.48 version, it is possible to monitor the bonding interface and bonding ports. For the 802.3ad bonding mode, more detailed monitoring options are available.
/interface bonding monitor [find] 
                      mode: 802.3ad           active-backup
              active-ports: ether4            ether6
                            ether5            
            inactive-ports:                   ether7
            lacp-system-id: CC:2D:E0:11:22:33 
      lacp-system-priority: 65535             
    lacp-partner-system-id: B8:69:F4:44:55:66
mode (802.3ad | active-backup | balance-alb | balance-rr | balance-tlb | balance-xor | broadcast)	Used bonding mode
active-ports (interface)	Shows the active bonding ports
inactive-ports (interface)	Shows the inactive bonding ports (e.g. a disabled or backup interface)
lacp-system-id (MAC address)	Shows the local LACP system ID
lacp-system-priority (integer)	Shows the local LACP priority
lacp-partner-system-id (MAC address)	Shows the partner LACP system ID

To monitor individual bonding ports, use a monitor-slaves command.
/interface bonding monitor-slaves bond1
Flags: A - active, P - partner 
 AP port=ether4 key=17 flags="A-GSCD--" partner-sys-id=D4:CA:6D:12:06:65 partner-sys-priority=65535 partner-key=9 partner-flags="A-GSCD--" 

 AP port=ether5 key=17 flags="A-GSCD--" partner-sys-id=D4:CA:6D:12:06:65 partner-sys-priority=65535 partner-key=9 partner-flags="A-GSCD--" 
port (interface)	Used bonding port
key (integer)	Shows the local LACP aggregation key. The lower 6 bits are automatically assigned based on individual port link speed and duplex. The upper 10 bits can be manually specified using the lacp-user-key setting (available only since RouterOS v7.3). 
flags (string)	

Shows the local LACP flags:

A - activity (link is active, otherwise passive)
T - timeout (link is using short 1-second timeout, otherwise using 30-second timeout)
G - aggregation (link can be aggregatable)
S - synchronization (link is synchronized)
C - collecting (link is able to collect incoming frames)
D - distributing (link is able to distribute outgoing frames)
F - defaulted (link is using defaulted partner information, indicated that no LACPDU has been received from the partner)
E - expired (link has expired state)
partner-sys-id (MAC address)	Shows the partner LACP system ID
partner-sys-priority (integer)	Shows the partner LACP priority
partner-key (integer)	Shows the partner LACP aggregation key
partner-flags (string)	Shows the partner LACP flags
Property Description

This section describes the available bonding settings. 
arp (disabled | enabled | proxy-arp | reply-only; Default: enabled)	Address Resolution Protocol for the interface.

    disabled - the interface will not use ARP
    enabled - the interface will use ARP
    proxy-arp - the interface will use the ARP proxy feature
    reply-only - the interface will only reply to requests originated from matching IP address/MAC address combinations which are entered as static entries in the "/ip arp" table. No dynamic entries will be automatically stored in the "/ip arp" table. Therefore for communications to be successful, a valid static entry must already exist.

arp-interval (time; Default: 00:00:00.100)	Time in milliseconds defines how often to monitor ARP requests
arp-ip-targets (IP address; Default: )	IP target address which will be monitored if link-monitoring is set to arp. You can specify multiple IP addresses, separated by a comma
comment (string; Default: )	Short description of the interface
disabled (yes | no; Default: no)	Changes whether the bonding interface is disabled
down-delay (time; Default: 00:00:00)	If a link failure has been detected, the bonding interface is disabled for a down-delay time. The value should be a multiple of mii-interval, otherwise, it will be rounded down to the nearest value. This property only has an effect when link-monitoring is set to mii.
forced-mac-address (MAC address; Default: none)	By default, the bonding interface will use the MAC address of the first selected slave interface. This property allows to configure static MAC address for the bond interface (all zeros, broadcast or multicast addresses will not apply). RouterOS will automatically change the MAC address for slave interfaces and it will be visible in /interface ethernet configuration export
lacp-mode (active | passive; Default: active)	

Specifies whether ports actively or passively participates in the LACP:

    active - ports actively initiate LACP communication, regardless of the partner's LACP mode (i.e, it "speaks" even if the partner is silent),
    passive - ports only respond to LACP messages and do not initiate them unless the partner is in active mode (i.e., it "listens" and responds only if spoken to).

lacp-rate (1sec | 30secs; Default: 30secs)	Link Aggregation Control Protocol rate specifies how often to exchange with LACPDUs between bonding peers. Used to determine whether a link is up or other changes have occurred in the network. LACP tries to adapt to these changes providing failover.
lacp-user-key (integer: 0..1023; Default: 0)	Specifies the upper 10 bits of the port key. The lower 6 bits are automatically assigned based on individual port link speed and duplex. The setting is available only since RouterOS v7.3.
link-monitoring (arp | mii | none; Default: mii)	Method to use for monitoring the link (whether it is up or down)

    arp - uses Address Resolution Protocol to determine whether the remote interface is reachable
    mii - uses Media Independent Interface to determine link status. Link status determination relies on the device driver.
    none - no method for link monitoring is used.

Note: some bonding modes require specific link monitoring to work properly.
min-links (integer: 0..4294967295; Default: 0)	How many active slave links needed for bonding to become active
mii-interval (time; Default: 00:00:00.100)	How often to monitor the link for failures (the parameter used only if link-monitoring is mii)
mlag-id (integer: 0..4294967295; Default:)	Changes MLAG ID for bonding interface. The same MLAG ID should be used on both peer devices to successfully create a single MLAG. See more details on MLAG.
mode (802.3ad | active-backup | balance-alb | balance-rr | balance-tlb | balance-xor | broadcast; Default: balance-rr)	Specifies one of the bonding policies

    802.3ad - IEEE 802.3ad dynamic link aggregation. In this mode, the interfaces are aggregated in a group where each slave shares the same speed. It provides fault tolerance and load balancing. Slave selection for outgoing traffic is done according to the transmit-hash-policy more>
    active-backup - provides link backup. Only one slave can be active at a time. Another slave only becomes active, if the first one fails. more>
    balance-alb - adaptive load balancing. The same as balance-tlb but received traffic is also balanced. The device driver should have support for changing it's MAC address. more>
    balance-rr - round-robin load balancing. Slaves in a bonding interface will transmit and receive data in sequential order. It provides load balancing and fault tolerance. more>
    balance-tlb - Outgoing traffic is distributed according to the current load on each slave. Incoming traffic is not balanced and is received by the current slave. If receiving slave fails, then another slave takes the MAC address of the failed slave. more>
    balance-xor - Transmit based on the selected transmit-hash-policy. This mode provides load balancing and fault tolerance. more>
    broadcast - Broadcasts the same data on all interfaces at once. This provides fault tolerance but slows down traffic throughput on some slow machines. more>

mtu (integer; Default: 1500)	Maximum Transmit Unit in bytes. Must be smaller or equal to the smallest L2MTU value of a bonding slave. L2MTU of a bonding interface is determined by the lowest L2MTU value among its slave interfaces
name (string; Default: )	Name of the bonding interface
primary (string; Default: none)	Controls the primary interface between active slave ports, works only for active-backup, balance-tlb and balance-alb modes. For active-backup mode, it controls which running interface is supposed to send and receive the traffic. For balance-tlb mode, it controls which running interface is supposed to receive all the traffic, but for balance-alb mode, it controls which interface is supposed to receive the unbalanced traffic (the non-IPv4 traffic). When none of the interfaces are selected as primary, device will automatically select the interface that is configured as the first one.
slaves (string; Default: none)	At least two ethernet-like interfaces separated by a comma, which will be used for bonding
up-delay (time; Default: 00:00:00)	If a link has been brought up, the bonding interface is disabled for up-delay time and after this time it is enabled. The value should be a multiple of mii-interval, otherwise, it will be rounded down to the nearest value. This property only has an effect when link-monitoring is set to mii.
transmit-hash-policy (encap-2-and-3 | encap-3-and-4 | layer-2 | layer-2-and-3 | layer-3-and-4; Default: layer-2)	

Selects the transmit hash policy to use for slave selection in balance-xor and 802.3ad modes

    encap-2-and-3 - This policy works like the layer-2-and-3 method for distributing traffic, but uses a process to also analyze the encapsulated packet headers. If an encapsulation protocol (like tunneling) is used, it may select the inner headers instead of the outer ones. RouterOS can use this feature when tunnels like 6to4, GRE, GRE6, IPIP, IPIP6, PPPoE, or PPTP are run over a bonding interface.
    encap-3-and-4 - This policy works like the layer-3-and-4 method for distributing traffic, but uses a process to also analyze the encapsulated packet headers. If an encapsulation protocol (like tunneling) is used, it may select the inner headers instead of the outer ones. RouterOS can use this feature when tunnels like 6to4, GRE, GRE6, IPIP, IPIP6, PPPoE, or PPTP are run over a bonding interface.
    layer-2 - Uses XOR of hardware MAC addresses to generate the hash. This algorithm will place all traffic to a particular network peer on the same slave. This algorithm is 802.3ad compliant.
    layer-2-and-3 - This policy uses a combination of layer2 and layer3 protocol information to generate the hash. Uses XOR of hardware MAC addresses and IP addresses to generate the hash. This algorithm will place all traffic to a particular network peer on the same slave. For non-IP traffic, the formula is the same as for the layer2 transmit hash policy. This policy is intended to provide a more balanced distribution of traffic than layer2 alone, especially in environments where a layer3 gateway device is required to reach most destinations. This algorithm is 802.3ad compliant.
    layer-3-and-4 - This policy uses upper layer protocol information, when available, to generate the hash. This allows for traffic to a particular network peer to span multiple slaves, although a single connection will not span multiple slaves. For fragmented TCP or UDP packets and all other IP protocol traffic, the source and destination port information is omitted. For non-IP traffic, the formula is the same as for the layer2 transmit hash policy. This algorithm is not fully 802.3ad compliant.

See also

    Bonding presentation at the MUM
    Bonding Examples
	
	
	
	

    Creado por Artūrs C., actualizado por última vez por Māris B. el abr 03, 2024 2 min de lectura

    Bonding EoIP tunnels over two wireless links
        Network Diagram
        Configuration
        Test the configuration
        Link Monitoring

Bonding EoIP tunnels over two wireless links

This is an example of aggregating multiple network interfaces into a single pipe. In particular, it is shown how to aggregate multiple virtual (EoIP) interfaces to get maximum throughput (MT) with emphasis on availability.
Network Diagram

Two routers R1 and R2 are interconnected via wireless links. Wireless interfaces on both sides have assigned IP addresses.


Configuration

Bonding could be used only on OSI layer 2 (Ethernet level) connections. Thus we need to create EoIP interfaces on each of the wireless links. This is done as follows:

on router R1:
/interface eoip add remote-address=10.0.1.1/24 tunnel-id=1 
/interface eoip add remote-address=10.2.2.1/24 tunnel-id=2

and on router R2:
/interface eoip add remote-address=10.0.1.2/24 tunnel-id=1 
/interface eoip add remote-address=10.2.2.2/24 tunnel-id=2

The second step is to add a bonding interface and specify EoIP interfaces as slaves:

R1:
/interface bonding add slaves=eoip-tunnel1,eoip-tunnel2 mode=balance-rr

R2:
/interface bonding add slaves=eoip-tunnel1,eoip-tunnel2 mode=balance-rr

The last step is to add IP addresses to the bonding interfaces:

R1:
/ip address add address 192.168.0.1/24 interface=bonding1

R2:
/ip address add address 192.168.0.2/24 interface=bonding1


Test the configuration

Now two routers are able to reach each other using addresses from the 192.168.0.0/24 network. To verify bonding interface functionality, do the following:

R1:
/interface monitor-traffic eoip-tunnel1,eoip-tunnel2

R2:
/tool bandwidth-test 192.168.0.1 direction=transmit

You should see that traffic is distributed equally across both EoIP interfaces:
/int monitor-traffic eoip-tunnel1,eoip-tunnel2              
    received-packets-per-second: 685      685                                  
       received-bits-per-second: 8.0Mbps  8.0Mbps                              
        sent-packets-per-second: 21       20                                   
           sent-bits-per-second: 11.9kbps 11.0kbps                             
    received-packets-per-second: 898      899                                  
       received-bits-per-second: 10.6Mbps 10.6Mbps                             
        sent-packets-per-second: 20       21                                   
           sent-bits-per-second: 11.0kbps 11.9kbps                             
    received-packets-per-second: 975      975                                  
       received-bits-per-second: 11.5Mbps 11.5Mbps                             
        sent-packets-per-second: 22       22                                   
           sent-bits-per-second: 12.4kbps 12.3kbps                             
    received-packets-per-second: 980      980                                  
       received-bits-per-second: 11.6Mbps 11.6Mbps                             
        sent-packets-per-second: 21       21                                   
           sent-bits-per-second: 11.9kbps 11.8kbps                             
    received-packets-per-second: 977      977                                  
       received-bits-per-second: 11.6Mbps 11.5Mbps                             
        sent-packets-per-second: 21       21                                   
           sent-bits-per-second: 11.9kbps 11.8kbps                             
-- [Q quit|D dump|C-z pause]
Link Monitoring

It is easy to notice that with the configuration above as soon as any individual link fails, the bonding interface throughput collapses. That's because no link monitoring is performed, consequently, the bonding driver is unaware of problems with the underlying links. Enabling link monitoring is a must in most bonding configurations. To enable ARP link monitoring, do the following:

R1:
/interface bonding set bonding1 link-monitoring=arp arp-ip-targets=192.168.0.2

R2:
/interface bonding set bonding1 link-monitoring=arp arp-ip-targets=192.168.0.1






    Creado por Edgars P., actualizado por última vez el abr 16, 2025 6 min de lectura

    Introduction
    Quick setup
    MLAG settings and monitoring

Introduction

MLAG (Multi-chassis Link Aggregation Group) implementation in RouterOS allows configuring LACP bonds on two separate devices, while the client device believes to be connected to the same machine. This provides a physical redundancy in case of switch failure. All CRS3xx, CRS5xx series switches, and CCR2116, CCR2216 devices can be configured with MLAG using RouterOS version 7.

Both peers establish the MLAG interfaces and update the bridge host table over peer-port using ICCP (Inter Chassis Control Protocol). RouterOS ICCP does not require an IP configuration, it sends untagged Layer2 packets marked with EtherType 0x88B5 and a destination MAC address of 01:80:C2:00:00:0E. ICCP packets are link-local, meaning they are always received and handled by the MLAG devices themselves and never forwarded to other parts of the network. The peer-ports on each MLAG device must be directly connected to each other. It is also recommended to keep the untagged VLAN used by the peer ports separate from the rest of your network, either by assigning a dedicated untagged VLAN (using pvid), or by setting the peer port to only allow VLAN tagged frames (using frame-types=admit-only-vlan-tagged). Peer ports can be configured as single Ethernet interfaces or bonding interfaces. However, using a bonding interface is recommended, as it helps prevent a single interface failure from affecting connectivity, especially when both MLAG nodes are still up and running.

When peer-port is running and ICCP is established, the primary device election happens and system-id will be selected. The peer with the lowest priority will act as the primary device. If the priorities are the same, the peer with the lowest bridge MAC address will become the primary. This system-id is used for STP BPDU bridge identifier and LACP system ID. The MLAG supports STP, RSTP or MSTP protocols. Use the same STP priority and the same STP configuration on dual-connected bridge ports on both nodes. When MLAG bridges are elected as STP root, then both devices will show as root bridges under the bridge monitor. 

The MLAG is not compatible with L3 hardware offloading. When using MLAG, the L3 hardware offloading must be disabled.

The MLAG is not compatible with Multiple VLAN Registration protocol (MVRP). Registered VLANs on dual-connected bonds does not get synchronized to other MLAG node.


Quick setup

in this example, CRS317 and CRS309 devices are used as MLAG peers and any device with two SFP+ interfaces can be used as an LACP client. The SFP+1 interface is used on both peer nodes to create peer-port, and it is used for ICCP, see a network scheme below.

Below are configuration commands to create a regular LACP bonding in RouterOS for the Client device. To speed up LACP link establishment, use a 1-second LACPDU transmission rate:
/interface bonding
add mode=802.3ad name=bond1 slaves=sfp-sfpplus1,sfp-sfpplus2 lacp-rate=1sec 

Next, configure bonding interfaces for MLAG on Peer1 and Peer2 devices, use a matching mlag-id setting on both peer devices, and set the 1-second LACPDU transmission rate:
# Peer1
/interface bonding
add mlag-id=10 mode=802.3ad name=client-bond slaves=sfp-sfpplus2 lacp-rate=1sec

# Peer2
/interface bonding
add mlag-id=10 mode=802.3ad name=client-bond slaves=sfp-sfpplus2 lacp-rate=1sec

Set up the bridge interface with vlan-filtering enabled. In this example, we want both MLAG nodes to act as the root bridge, so we assign a better (lower) bridge priority using priority=0x1000. Make sure both MLAG nodes use the same priority value.

Optionally, you can set frame-types=admit-only-vlan-tagged on the bridge interface to disables the default untagged VLAN 1 (pvid=1).
# Peer1
/interface bridge
add name=bridge1 vlan-filtering=yes priority=0x1000 frame-types=admit-only-vlan-tagged

# Peer2
/interface bridge
add name=bridge1 vlan-filtering=yes priority=0x1000 frame-types=admit-only-vlan-tagged

Next, add the necessary interfaces to the bridge. In this example, only the peer port (sfp-sfpplus1) and the client-bond interface need to be added.

For the peer port, we disable the default untagged VLAN 1 (pvid=1) by configuring it to accept only VLAN-tagged traffic (frame-types=admit-only-vlan-tagged).

For the client-bond interface, we want untagged traffic to belong to VLAN 10, so we set pvid=10 on that interface.
# Peer1
/interface bridge port
add bridge=bridge1 interface=sfp-sfpplus1 frame-types=admit-only-vlan-tagged
add bridge=bridge1 interface=client-bond pvid=10

# Peer2
/interface bridge port
add bridge=bridge1 interface=sfp-sfpplus1 frame-types=admit-only-vlan-tagged
add bridge=bridge1 interface=client-bond pvid=10


The MLAG supports STP, RSTP or MSTP protocol. Use the same STP priority and the same STP configuration (e.g. path-cost, priority, edge) on dual-connected bridge ports on both nodes.

If the dual-connected bond interface is not connected to any other RSTP/MSTP bridges or switches, you can set edge=yes on that interface on both MLAG nodes.

This setting allows the bond port to quickly enter the forwarding state, which helps reduce packet loss when one side of the MLAG becomes available again.

In this example, client-bond interfaces uses VLAN 10 for untagged traffic (set with pvid=10), and we also want to allow tagged VLAN 20. To make sure traffic for both VLANs can pass between the MLAG devices, we need to add the peer ports as tagged members of VLANs 10 and 20 on both MLAG nodes. It is important to include the peer ports in all VLANs that are used on other bridge ports, this includes the untagged and tagged VLANs. Below are configuration commands for both peer devices:
# Peer1
/interface bridge vlan
add bridge=bridge1 tagged=sfp-sfpplus1 vlan-ids=10
add bridge=bridge1 tagged=sfp-sfpplus1,client-bond vlan-ids=20

# Peer2
/interface bridge vlan
add bridge=bridge1 tagged=sfp-sfpplus1 vlan-ids=10
add bridge=bridge1 tagged=sfp-sfpplus1,client-bond vlan-ids=20


All VLANs used for bridge slave ports must be also configured as tagged VLANs for peer-port, so that peer-port is a member of those VLANs and can forward data.

Last, specify bridge and peer-port to enable MLAG. To control which device becomes the primary MLAG node, set a lower priority value on the preferred device. In this example, we want Peer1 to be the primary, so we set its priority=50. Peer2 keeps the default priority of 128, making it the secondary. Below are configuration commands for both peer devices:
# Peer1
/interface bridge mlag
set bridge=bridge1 peer-port=sfp-sfpplus1 priority=50

# Peer2
/interface bridge mlag
set bridge=bridge1 peer-port=sfp-sfpplus1

Additionally, check MLAG status on peer devices and make sure that Client LACP has both interfaces active.
# Peer1
[admin@Peer1] > /interface/bridge/mlag/monitor    
       status: connected
    system-id: 74:4D:28:11:70:6B
  active-role: primary

# Peer2
[admin@Peer2] > /interface/bridge/mlag/monitor           
       status: connected
    system-id: 74:4D:28:11:70:6B
  active-role: secondary

# Client
[admin@Client] > /interface bonding monitor bond1 
                    mode: 802.3ad
            active-ports: sfp-sfpplus1,sfp-sfpplus2
          inactive-ports: 
          lacp-system-id: 74:4D:28:7B:7F:96
    lacp-system-priority: 65535
  lacp-partner-system-id: 74:4D:28:11:70:6C

MLAG settings and monitoring

This section describes the available MLAG settings and monitoring options.

Sub-menu: /interface bridge mlag
bridge (interface; Default: none)	The bridge interface where MLAG is being created.
heartbeat (time: 1s..10s | none; Default: 00:00:05)	This setting controls how often heartbeat messages are sent to check the connection between peers. If no heartbeat message is received for three intervals in a row, the peer logs a warning about potential communication problems. If set to none, heartbeat messages are not sent at all.

peer-port  (interface; Default: none)
	

An interface that will be used as a peer port. Both peer devices are using inter-chassis communication over these peer ports to establish MLAG and update the host table. Peer port should be isolated on a different untagged VLAN using a pvid setting. Peer port can be configured as a bonding interface.
priority (integer: 0..128; Default: 128)	This setting changes the priority for selecting the primary MLAG node. A lower number means higher priority. If both MLAG nodes have the same priority, the one with the lowest bridge MAC address will become the primary device.

Use the monitor commands to see the current MLAG status.
[admin@Peer1] > /interface/bridge/mlag/monitor    
       status: connected
    system-id: 74:4D:28:11:70:6B
  active-role: primary
status (connected | connecting | disabled)	The MLAG status.

system-id (MAC address)
	The lowest MAC address between both peer bridges will be used as the system-id. This system-id is used for (R/M)STP BPDU bridge identifier and LACP system ID.

active-role (primary | secondary)
	

The peer with the lowest priority will act as the primary device. If the priorities are the same, the peer with the lowest bridge MAC address will become the primary. The system-id of the primary device is used for sending the (R/M)STP BPDU bridge identifier and LACP system ID.

Sub-menu: /interface bonding
mlag-id (integer: 0..4294967295; Default:)	Changes MLAG ID for bonding interface. The same MLAG ID should be used on both peer devices to successfully create a single LAG for the client device. The peer-port should not be configured with the MLAG ID. 

LACP bonding interface and bonding slave ports can be monitored with monitor and monitor-slaves commands. See more details on Bonding monitoring.

The "not hw offloaded" : error will occur, if the bridge or bridge/port does not utilize Layer 2 hardware offloading. MLAG setup must be done using single bridge as well as bridge port hw=yes





    Creado por Artūrs C., actualizado por última vez por Edgars P. el jun 19, 2025 12 min de lectura

    Summary
    Protocol Overview
        Virtual Router (VR)
            Virtual MAC address
        Owner
        Master
        Backup
        Virtual Address
            IPv4 ARP
            IPv6 ND
    VRRP state machine
            Init state
            Backup state
            Master state
        Connection tracking synchronization
    Configuring VRRP
        IPv4
        IPV6
    Parameters

Summary

This chapter describes the Virtual Router Redundancy Protocol (VRRP) support in RouterOS.

Mostly on larger LANs dynamic routing protocols (OSPF or RIP) are used, however, there are a number of factors that may make it undesirable to use dynamic routing protocols. One alternative is to use static routing, but if the statically configured first hop fails, then the host will not be able to communicate with other hosts.

In IPv6 networks, hosts learn about routers by receiving Router Advertisements used by the Neighbor Discovery (ND) protocol. ND already has a built-in mechanism to determine unreachable routers. However, it can take up to 38 seconds to detect an unreachable router. It is possible to change parameters and make detection faster, but it will increase the overhead of ND traffic especially if there are a lot of hosts. VRRP allows the detection of unreachable routers within 3 seconds without additional traffic overhead.

Virtual Router Redundancy Protocol (VRRP) provides a solution by combining a number of routers into a logical group called Virtual Router (VR). VRRP implementation in RouterOS is based on VRRPv2 RFC 3768 and VRRPv3 RFC 5798.

It is recommended to use the same version of RouterOS for all devices with the same VRID used to implement VRRP.

 According to RFC authentication is deprecated for VRRP v3.
Protocol Overview

The purpose of the VRRP is to communicate to all VRRP routers associated with the Virtual Router ID and support router redundancy through a prioritized election process among them.

All messaging is done by IPv4 or IPv6 multicast packets using protocol 112 (VRRP). The destination address of an IPv4 packet is 224.0.0.18 and for IPv6 it is FF02:0:0:0:0:0:0:12. The source address of the packet is always the primary IP address of an interface from which the packet is being sent. In IPv6 networks, the source address is the link-local address of an interface.

These packets are always sent with TTL=255 and are not forwarded by the router. If for any reason the router receives a packet with lower TTL, a packet is discarded.

Each VR node has a single assigned MAC address. This MAC address is used as a source for all periodic messages sent by Master.

Virtual Router is defined by VRID and mapped set of IPv4 or IPv6 addresses. The master router is said to be the owner of mapped IPv4/IPv6 addresses. There are no limits to using the same VRID for IPv4 and IPv6, however, these will be two different Virtual Routers.

Only the Master router is sending periodic Advertisement messages to minimize the traffic. A backup will try to preempt the Master only if it has the higher priority and preemption is not prohibited.

All VRRP routers belonging to the same VR must be configured with the same advertisement interval. If the interval does not match router will discard the received advertisement packet.
Virtual Router (VR)

A Virtual Router (VR) consists of one Owner router and one or more backup routers belonging to the same network.

VR includes:

    VRID configured on each VRRP router
    the same virtual IP on each router
    Owner and Backup configured on each router. On a given VR there can be only one Owner.

Virtual MAC address

VRRP automatically assigns MAC address to VRRP interface based on standard MAC prefix for VRRP packets and VRID number. The first five octets are 00:00:5E:00:01 and the last octet is configured VRID. For example, if Virtual Routers VRID is 49, then the virtual MAC address will be 00:00:5E:00:01:31.

Virtual mac addresses can not be manually set or edited.
Owner

An Owner router for a VR is the default Master router and operates as the Owner for all subnets included in the VR. Priority on an owner router must be the highest value (255) and virtual IP is the same as real IP (owns the virtual IP address).

RouterOS can not be configured as Owner. The Pure virtual IP configuration is the only valid configuration unless a non-RouterOS device is set as the owner.
Master

A master router in a VR operates as the physical gateway for the network for which it is configured. The selection of the Master is controlled by priority value. The Master state describes the behavior of the Master router. For example network, R1 is the Master router. When R1 is no longer available R2 becomes master.
Backup

VR must contain at least one Backup router. A backup router must be configured with the same virtual IP as the Master for that VR. The default priority for Backup routers is 100. When the current master router is no longer available, a backup router with the highest priority will become a current master. Every time when a router with higher priority becomes available it is switched to master. Sometimes this behavior is not necessary. To override it preemption mode should be disabled.
Virtual Address


Virtual IP associated with VR must be identical and set on all VR nodes. All virtual and real addresses should be from the same network.

RouterOS can not be configured as Owner. VRRP address and real IP address should not be the same.

If the Master of VR is associated with multiple IP addresses, then Backup routers belonging to the same VR must also be associated with the same set of virtual IP addresses. If the virtual address on the Master is not also on Backup a misconfiguration exists and VRRP advertisement packets will be discarded.

All Virtual Router members can be configured so that virtual IP is not the same as physical IP. Such a virtual address can be called a floating or pure virtual IP address. The advantage of this setup is the flexibility given to the administrator. Since the virtual IP address is not the real address of any one of the participant routers, the administrator can change these physical routers or their addresses without any need to reconfigure the virtual router itself.

In IPv6 networks, the first address is always a link-local address associated with VR. If multiple IPv6 addresses are configured, then they are added to the advertisement packet after the link-local address.
IPv4 ARP

The Master for a given VR responds to ARP requests with the VR's assigned MAC address. The virtual MAC address is also used as the source MAC address for advertisement packets sent by the Master. To ARP requests for non-virtual IP, addresses router responds with the system MAC address. Backup routers are not responding to ARP requests for Virtual IPs.
IPv6 ND

As you may know, in IPv6 networks, the Neighbor Discovery protocol is used instead of ARP. When a router becomes the Master, an unsolicited ND Neighbor Advertisement with the Router Flag is sent for each IPv6 address associated with the virtual router.
VRRP state machine

As you can see from the diagram, each VRRP node can be in one of three states:

    Init state
    Backup state
    Master state

Init state

The purpose of this state is to wait for a Startup event. When this event is received, the following actions are taken:

    if priority is 255,
    * for IPv4 send advertisement packet and broadcast ARP requests;
    * for IPv6 send an unsolicited ND Neighbor Advertisement for each IPv6 address associated with the virtual router and set target address to link-local address associated with VR;
    * transit to MASTER state;
    else transit to BACKUP state.

Backup state

When in the backup state,

    in IPv4 networks, a node is not responding to ARP requests and is not forwarding traffic for the IP associated with the VR.
    in IPv6 networks, a node is not responding to ND Neighbor Solicitation messages and is not sending ND Router Advertisement messages for VR-associated IPv6 addresses.

Routers' main task is to receive advertisement packets and check if the master node is available.

The backup router will transmit itself to the master state in two cases:

    If priority in advertisement packet is 0;
    When Preemption_Mode is set to yes and Priority in the ADVERTISEMENT is lower than the local Priority

After the transition to Master state node is:

    in IPv4 broadcasts gratuitous ARP request;
    in IPv6 sends an unsolicited ND Neighbor Advertisement for every associated IPv6 address.

In other cases, advertisement packets will be discarded. When the shutdown event is received, transit to Init state.

Preemption mode is ignored if the Owner router becomes available.
Master state

When the MASTER state is set, the node functions as a forwarding router for IPv4/IPv6 addresses associated with the VR.

In IPv4 networks, the Master node responds to ARP requests for the IPv4 address associated with the VR. In IPv6 networks Master node:

    responds to ND Neighbor Solicitation message for the associated IPv6 address;
    sends ND Router Advertisements for the associated IPv6 addresses.


If the advertisement packet is received by master node:

    If priority is 0, send advertisement immediately;
    If priority in advertisement packet is greater than nodes priority then transit to the backup state;
    If priority in advertisement packet is equal to nodes priority and primary IP Address of the sender is greater than the local primary IP Address, then transit to the backup state;
    Ignore advertisement in other cases.

When the shutdown event is received, send the advertisement packet with priority=0 and transit to Init state.
Connection tracking synchronization

Similar to different High availability features, RouterOS v7 supports VRRP connection tracking synchronization.

The VRRP connection tracking synchronization requires that RouterOS connection tracking is running. By default, connection tracking is working in auto mode. If VRRP devices do not contain any firewall rules, you need to manually enable connection tracking:
/ip/firewall/connection/tracking/set enabled=yes

To sync connection tracking entries configure the device as follows:
/interface/vrrp/set vrrp1 sync-connection-tracking=yes

Verify configuration in the logging section:
16:14:06 vrrp,info vrrp1 now MASTER, master down timer
16:14:06 vrrp,info vrrp1 stop CONNTRACK
16:14:06 vrrp,info vrrp1 starting CONNTRACK MASTER

Connection tracking entries are synchronized only from the Master to the Backup device.

When both sync-connection-tracking and preemption-mode are enabled, and a router with higher VRRP priority becomes online, the connections get synchronized first, and only then the router with higher priority becomes the VRRP master.

If multiple VRRP interfaces are configured between two units and sync-connection-tracking=yes is required, it must be enabled only on one of the VRRP interfaces, preferably the one designated as the group-authority.
Configuring VRRP
IPv4

Setting up Virtual Router is quite easy, only two actions are required - create VRRP interface and set Virtual Routers IP address.

For example, add VRRP to ether1 and set VRs address to 192.168.1.1
/interface vrrp add name=vrrp1 interface=ether1
/ip address add address=192.168.1.2/24 interface=ether1
/ip address add address=192.168.1.1/32 interface=vrrp1

Notice that only the 'interface' parameter was specified when adding VRRP. It is the only parameter required to be set manually, other parameters if not specified will be set to their defaults: vrid=1, priority=100 and authentication=none.

Address on the VRRP interface must have /32 netmask if the address configured on VRRP is from the same subnet as on the router's any other interface.

Before VRRP can operate correctly correct IP address is required on ether1. In this example, it is 192.168.1.2/24.
IPV6

To make VRRP work in IPv6 networks, several additional options must be enabled - v3 support is required and the protocol type should be set to IPv6:
/interface vrrp add name=vrrp1 interface=ether1 version=3 v3-protocol=ipv6

Now when the VRRP interface is set, we can add a global address and enable ND advertisement:
/ipv6 address add address=FEC0:0:0:FFFF::1/64 advertise=yes interface=vrrp1

No additional address configuration is required as it is in the IPv4 case. IPv6 uses link-local addresses to communicate between nodes.
Parameters
arp (disabled | enabled | proxy-arp | reply-only; Default: enabled)	ARP resolution protocol mode.
arp-timeout (integer; Default: auto)	
authentication (ah | none | simple; Default: none)	Authentication method to use for VRRP advertisement packets.

    none - should be used only in low-security networks (e.g., two VRRP nodes on LAN).
    ah - IP Authentication Header. This algorithm provides strong protection against configuration errors, replay attacks, and packet corruption/modification. Recommended when there is limited control over the administration of nodes on a LAN. HMAC-MD5 is used.
    simple - uses a clear-text password. Protects against accidental misconfiguration of routers on a local network.

connection-tracking-mode (active-active | passive-active; Default: passive-active)	

Specifies the mode for connection tracking synchronization. This setting is only relevant when sync-connection-tracking=yes is enabled.

    passive-active - this mode is designed for traditional VRRP setups, where one master and one or more backup routers are used. In this mode, only the master device performs connection tracking synchronization by sending updates to the backup devices. Backup devices do not send any connection tracking data.
    active-active - This mode is intended for setups using multiple VRRP groups to achieve load balancing. Each VRRP group has its own master, and these masters may reside on different physical devices. With active-active mode, all active masters can synchronize connection tracking data with each other. Each VRRP group in active-active mode must use a unique connection-tracking-port value. Reusing the same port across multiple groups can cause non-synchronized connection tracking table. 

Using multiple VRRP groups with passive-active mode may lead to unsynchronized connection tracking tables, since only one master handles synchronization, and the others do not exchange tracking data.

Example configuration:
R1
/interface vrrp
add connection-tracking-mode=active-active connection-tracking-port=8275 interface=ether1 name=vrrp30 priority=100 sync-connection-tracking=yes vrid=1
add connection-tracking-mode=active-active connection-tracking-port=8276 interface=ether1 name=vrrp40 priority=100 sync-connection-tracking=yes vrid=2

R2
/interface vrrp
add connection-tracking-mode=active-active connection-tracking-port=8275 interface=ether1 name=vrrp30 priority=55 sync-connection-tracking=yes vrid=1
add connection-tracking-mode=active-active connection-tracking-port=8276 interface=ether1 name=vrrp40 priority=155 sync-connection-tracking=yes vrid=2


connection-tracking-port (integer; Default: 8275)	Specifies UDP port for connection tracking synchronization. This setting is only relevant when sync-connection-tracking=yes is enabled.
group-authority (interface; Default: none)	

Allows combining multiple VRRP interfaces to maintain the same VRRP status within the group. For example, VRRP instances run on LAN and WAN networks with NAT in-between. If one VRRP instance is Master and the other is Backup on the same device, the entire network malfunctions due to NAT failure. Grouping LAN and WAN VRRP interfaces ensures that both are either VRRP Master or Backup.

In a VRRP group, VRRP control traffic gets sent only by the group authority. That's why in a typical WAN+LAN setup, it is recommended to use the LAN network as the group master to keep VRRP control traffic in the internal network.
/interface vrrp
add name=vrrp-wan interface=sfp-sfpplus1 vrid=1 priority=100
add name=vrrp-lan interface=bridge1 vrid=2 priority=100
set [find] group-authority=vrrp-lan

Group-authority was previously called "group-master", "group-master" is kept for compatibility with scripts, but if both are set only "group-authority" will be taken into account.
interface (string; Default: )	Interface name on which VRRP instance will be running.
interval (time [10ms..4m15s]; Default: 1s)	VRRP update interval in seconds. Defines how often the master sends advertisement packets.
mtu (read-only; Default: )	Layer3 MTU size. Since RouterOS v7.7, the VRRP interface always uses slave interface MTU.
name (string; Default: )	VRRP interface name.
on-backup (string; Default: )	Script to execute when the node is switched to the backup state.
on-master (string; Default: )	Script to execute when the node is switched to master state.
on-fail (string; Default: )	Script to execute when the node fails.
password (string; Default: )	Password required for authentication. Can be ignored if authentication is not used.
preemption-mode (yes | no; Default: yes)	Whether the master node always has the priority. When set to 'no' the backup node will not be elected to be a master until the current master fails, even if the backup node has higher priority than the current master. This setting is ignored if the owner router becomes available.
priority (integer: 1..254; Default: 100)	Priority of VRRP node used in Master election algorithm. A higher number means higher priority. '255' is reserved for the router that owns VR IP and '0' is reserved for the Master router to indicate that it is releasing responsibility.
remote-address (IPv4; Default: )	

Specifies the remote address of the other VRRP router for syncing connection tracking. If not set, the system autodetects the remote address via VRRP. The remote address is used only if sync-connection-tracking=yes. Explicitly setting a remote address has the following benefits:

    Connection syncing starts faster since there is no need to wait for VRRP's initial message exchange to detect the remote address;
    Faster VRRP Master election;
    Allows sending connection tracking data via a different network interface (e.g., a dedicated secure line between two routers). 

Sync connection tracking uses UDP port 8275.
v3-protocol (ipv4 | ipv6; Default: ipv4)	A protocol that will be used by VRRPv3. Valid only if the version is 3.
version (integer [2, 3]; Default: 3)	Which VRRP version to use.
vrid (integer: 1..255; Default: 1)	Virtual Router identifier. Each Virtual router must have a unique id number.
sync-connection-tracking (string; Default: no)	Synchronize connection tracking entries from Master to Backup device. The VRRP connection tracking synchronization requires that RouterOS connection tracking is running.





    Creado por Usuario desconocido (emils), actualizado por última vez por Serhii T. el ene 26, 2023 3 min de lectura

    Basic Setup
        Configuration
        Testing
    Load sharing
        Configuration
    VRRP without Preemption
        Configuration
        Testing

Basic Setup

This is the basic VRRP configuration example.

Note

It is recommended to use the same version of RouterOS for all devices with the same VRID used to implement VRRP.



According to this configuration, as long as the master, R1, is functional, all traffic destined to the external network gets directed to R1. But as soon as R1 fails, R2 takes over as the master and starts handling packets forwarded to the interface associated with IP(R1). In this setup router "R2" is completely idle during the Backup period.
Configuration

R1 configuration:
/ip address add address=192.168.1.10/24 interface=ether1
/interface vrrp add interface=ether1 vrid=49 priority=254
/ip address add address=192.168.1.1/32 interface=vrrp1

R2 configuration:
/ip address add address=192.168.1.20/24 interface=ether1
/interface vrrp add interface=ether1 vrid=49
/ip address add address=192.168.1.1/32 interface=vrrp1
Testing

First of all, check if both routers have correct flags at VRRP interfaces. On router R1 it should look like this
/interface vrrp print detail
 0   RM name="vrrp1" mtu=1500 mac-address=00:00:5E:00:01:31 arp=enabled interface=ether1 vrid=49 
        priority=254 interval=1 preemption-mode=yes authentication=none password="" on-backup="" 
        on-master="" version=3 v3-protocol=ipv4

and on router R2:
/interface vrrp print detail
 0    B name="vrrp1" mtu=1500 mac-address=00:00:5E:00:01:31 arp=enabled interface=ether1 vrid=49 
        priority=100 interval=1 preemption-mode=yes authentication=none password=""
        on-backup="" on-master=" version=3 v3-protocol=ipv4

As you can see VRRP interface MAC addresses are identical on both routers. Now to check if VRRP is working correctly, try to ping the virtual address from a client and check ARP entries:
[admin@client] > /ping 192.168.1.1
192.168.1.254 64 byte ping: ttl=64 time=10 ms
192.168.1.254 64 byte ping: ttl=64 time=8 ms
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 8/9.0/10 ms
[admin@client] /ip arp> print
Flags: X - disabled, I - invalid, H - DHCP, D - dynamic
 #   ADDRESS         MAC-ADDRESS       INTERFACE
 ...
 1 D 192.168.1.1   00:00:5E:00:01:31 bridge1

Now unplug the ether1 cable on router R1. R2 will become VRRP master, and the ARP table on a client will not change but traffic will start to flow over the R2 router.

In case VRRP is used with Reverse Path Filtering, then it is recommended that rp-filter is set to loose, otherwise, the VRRP interface might not be reachable.
Load sharing

In the basic configuration example, R2 is completely idle during the Backup state. This behavior may be considered a waste of valuable resources. In such circumstances, the R2 router can be set as the gateway for some clients.
The obvious advantage of this configuration is the establishment of a load-sharing scheme. But by doing so R2 router is not protected by the current VRRP setup.
To make this setup work we need two virtual routers.

Configuration for V1 virtual router will be identical to a configuration in basic example - R1 is the Master and R2 is the Backup router. In V2 Master is R2 and Backup is R1.
With this configuration, we establish load-sharing between R1 and R2; moreover, we create a protection setup by having two routers acting as backups for each other.
Configuration

R1 configuration:
/ip address add address=192.168.1.1/24 interface=ether1
/interface vrrp add interface=ether1 vrid=49 priority=254
/interface vrrp add interface=ether1 vrid=77 
/ip address add address=192.168.1.253/32 interface=vrrp1
/ip address add address=192.168.1.254/32 interface=vrrp2

R2 configuration:
/ip address add address=192.168.1.2/24 interface=ether1
/interface vrrp add interface=ether1 vrid=49
/interface vrrp add interface=ether1 vrid=77 priority=254
/ip address add address=192.168.1.253/32 interface=vrrp1
/ip address add address=192.168.1.254/32 interface=vrrp2
VRRP without Preemption

Each time when the router with a higher priority becomes available it becomes the Master router. Sometimes this is not the desired behavior and can be turned off by setting preemption-mode=no in VRRP configuration.
Configuration

We will be using the same setup as in the basic example. The only difference is during configuration set preemption-mode=no. It can be done easily by modifying the existing configuration:
/interface vrrp set [find] preemption-mode=no
Testing

Try turning off the R1 router, R2 will become the Master router because it has the highest priority among available routers.

Now turn the R1 router on and you will see that the R2 router continues to be the Master even if R1 has the higher priority.





Mobile Networking

    Creado por Usuario desconocido (emils), actualizado por última vez el may 31, 2022 1 min de lectura

In This Section:

        GPS
        LTE
        PPP
        SMS
        Dual SIM Application





    Creado por Deniss M., actualizado por última vez por GG el abr 26, 2024 3 min de lectura

    Summary
    Configuration Properties
    Monitoring Status
    Basic examples
    Troubleshooting

Summary

Package requirement: gps
Sub-menu: /system gps
Standards: GPS, NMEA 0183, Simple Text Output Protocol

Global Positioning System (GPS) is used for determining the precise location of a GPS receiver. 
Configuration Properties
channel (integer [0..4294967295]; Default: 0)	Port channel used by the device
coordinate-format (dd | dms | ddmm; Default: no)	Which coordinate format to use, "Decimal Degrees", "Degrees Minutes Seconds" or "NMEA format DDDMM.MM[MM]"
enabled (yes | no; Default: no)	Whether GPS is enabled
gps-antenna-select (external | internal; Default: internal)	Depending on the model. Internal antenna can be selected, if the device has one installed.
init-channel (integer [0..4294967295]; Default: )	Channel for init-string execution
init-string (string; Default: )	AT init string for GPS initialization
port (string; Default: )	Name of the USB/Serial port where the GPS receiver is connected
set-system-time (yes | no; Default: no)	Whether to set the router's date and time to one received from GPS.
Monitoring Status

Command: /system gps monitor

This command is used for monitoring the data received from a GPS receiver.

Parameters:

Starting with the 7.1rc3 firmware release, a new parameter was added, called "data-age" (measured in seconds). This parameter displays the time that has passed since the device received the last NMEA message.
date-and-time (date)	Date and time received from GPS
latitude (none | string)	Latitude in DM (Degrees Minute decimal) format
longitude (none | string)	Longitude in DM (Degrees Minute decimal) format
altitude (none | string)	Altitude based on GPS data
speed (none | string)	The current moving speed of the GPS unit
destination-bearing (none | string)	The direction toward which a GPS is moving
true-bearing (none | string)	The direction toward which a GPS is moving
magnetic-bearing (none | string)	The direction toward which a GPS is moving
valid (yes | no)	
satellites (integer)	Number of satellites seen by the device.
fix-quality (integer)	Quality of the signal
horizontal-dilution (integer)	Horizontal dilution of precision (HDOP);
data-age (integer)	The time that has passed since the device received the last NMEA message
Basic examples

Check port usage, as only one instance can use the serial port simultaneously:
[admin@MikroTik] /port print
Flags: I - inactive 
 #   DEVICE NAME                     CHANNELS USED-BY                   BAUD-RATE
 0          serial0                         1 Serial Console            auto    

In case there is one port and it is used by the console, release it from the console menu:
[admin@MikroTik] > /system console print 
Flags: X - disabled, U - used, F - free
 #   PORT                                                                       TERM                                                                     
 0 U serial0                                                                    vt102 

[admin@MikroTik] > /system console disable 0   

Adjust port settings specifically for your device (leave "auto" for LtAP mini):
[admin@MikroTik] /port> set 0 baud-rate=4800 parity=odd
[admin@MikroTik] /port> print detail 
Flags: I - inactive 
 0   name="usb1" used-by="" channels=1 baud-rate=4800 data-bits=8 parity=odd stop-bits=1 flow-control=none

Enable GPS:
[admin@MikroTik] /system gps> set enable=yes port=usb1
[admin@MikroTik] /system gps> print 
          enabled: yes
             port: usb1
          channel: 0
     init-channel: 0
      init-string:
  set-system-time: no

Monitor status:
[admin@MikroTik] /system gps> monitor  
        date-and-time: sep/07/2021 08:26:26
             latitude: 56.969689
            longitude: 24.162471
             altitude: 25.799999m
                speed: 0.759320 km/h
  destination-bearing: none
         true-bearing: 185.500000 deg. True
     magnetic-bearing: 0.000000 deg. Mag
                valid: yes
           satellites: 6
          fix-quality: 1
  horizontal-dilution: 1.3

Port and GPS settings for LtAP
/port set serial1 baud-rate=115200
/system gps set port=serial1 channel=0 enabled=yes

We have also created an in-depth article about live GPS tracking, using scripting and a web server: GPS-tracking.
Troubleshooting

Note that sometimes to make the GPS module recognized in RouterOS you need to change the baud-rate setting in the '/port' menu.

LtAP mini has a low-gain GPS antenna built-in and for a better experience, we suggest using an additional external antenna.

Switch between internal and external antennas under the GPS menu:
[admin@MikroTik] > /system gps set gps-antenna-select=external

On some modems with GPS support, you need to send multiple init commands for continuous GPS monitoring, for example, for Huawei cards you need to send "AT^WPDST=1,AT^WPDGP" init string to get continuous monitoring.





    Creado por Deniss M., actualizado por última vez por GG el abr 26, 2024 2 min de lectura

The following article explains how to create a simple vehicle tracking system using the RouterOS GPS function and scripting.
Method

This approach uses HTTP POST capability of RouterOS Fetch tool. It allows you to POST any kind of data to a webserver, right from the RouterOS command line. Of course, you can use scripting, to fill the POST data with variables. The posted data will be written to an SQLITE3 database (file is created, if it doesn't exist) and then, read from the database and fed into a Leaflet.js PolyLine array. This is a proof of concept example, there is no authentication, security, or error handling.
Requirements

    Web server of your choice
    PHP
    SQLite3 module for PHP
    RouterOS device with a working GPS module
    RouterOS
    Set GPS format in RouterOS to dd

RouterOS script

You can run this script in the Scheduler tool, with an interval of 1s, to have your coordinates sent every 1 second.
{
:global lat
:global lon
/system gps monitor once do={
:set $lat $("latitude")
:set $lon $("longitude")
}
tool fetch mode=http url="http://YOURSERVER.com/index.php" port=80 http-method=post http-data=("{\"lat\":\"" . $lat . "\",\"lon\":\"" . $lon . "\"}") http-header-field="Content-Type: application/json" 
:put ("{\"lat\":\"" . $lat . "\",\"lon\":\"" . $lon . "\"}")
}
index.php file

Create an empty directory called sqlite_db next to the index.php file. Make sure that directory and files are writable by the group with chmod -R a+w sqlite_db/
<?php
$loc = dirname(__FILE__).'/sqlite_db/coord.db';
$db = new SQLite3($loc,SQLITE3_OPEN_READWRITE | SQLITE3_OPEN_CREATE);
$raw = file_get_contents('php://input');
$raw = preg_replace('/\\x00/','',$raw);
$data = json_decode($raw);

if (!empty($data) && is_object($data) && property_exists($data,'lat') && property_exists($data,'lon')){
    if(file_exists($loc)) echo 'exists!'.chr(0xa);
    $src = 'SELECT name FROM sqlite_master WHERE type=\'table\' AND name=\'coordinates\'';
    $res = $db->querySingle($src);
    if (count($res)==0){
            $db->exec('CREATE TABLE coordinates (latitude TEXT, longitude TEXT, time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, added TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ');
    }
    
$regex = '/^(|\-)([0-9]{2,3}\.[0-9]{0,8})$/';

if (preg_match($regex,$data->lat) && preg_match($regex,$data->lon) )
	{
		$lat = $data->lat;
		$lon = $data->lon;
	}
	$ins = 'INSERT INTO coordinates (latitude,longitude) VALUES (\''.SQLite3::escapeString($lat).'\',\''.SQLite3::escapeString($lon).'\')';
	$db->exec($ins);
	die();
}
?>

<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js" integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw==" crossorigin=""></script>
</head>
<body>
<div id="map" style="width: 800px; height: 600px;"></div>
<script>
var map = L.map('map').setView([0,0], 4);
L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {attribution: '<a href="http://osm.org/copyright">OSM</a>'}).addTo(map);

<?php
    if($result = $db->query('SELECT latitude,longitude FROM coordinates')){
    echo ' var latlngs = [ ';
    while($obj = $result->fetchArray()){
    	if (!is_array($obj) || !isset($obj['latitude']) || !isset($obj['longitude']) || empty($obj['latitude']) || empty($obj['longitude'])) continue;
    	echo '["'. $obj['latitude'].'","'.$obj['longitude'].'"],';
    }
    echo ']; ';
    } else
     echo('//'.$db->lastErrorMsg().chr(0xa));  
	 echo($data);
?>
var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
map.fitBounds(polyline.getBounds());
</script>
</body>
</html>
Result





    Creado por Deniss M., actualizado por última vez por GG el abr 26, 2024 6 min de lectura

    Introduction
    Configuration
        ThingsBoard preparation
        MQTT broker configuration
        MQTT publish
    Result verification
    Data visualization using maps

Introduction

Many RouterOS devices have GPS support. It allows RouterOS to determine the precise location of its GPS receiver. GPS coordinates will indicate the latitude and the longitude values (among other parameters) of the current position.

Let's say, you have LTAP (or any other RouterOS device with GPS support) and you wish to track its location. You want the router to send this data to a server, where the data will be stored and integrated into a map, as it is more convenient to monitor. In this guide, we will showcase how you can do that. This scenario will utilize MQTT protocol communication with a platform called ThingsBoard.

ThingsBoard has a cloud solution and different local installation options (on different OS).

Since we've added a container feature, it became possible to also run the platform within the RouterOS. Meaning, you can build this scenario, solely on RouterOS units → devices with GPS support that you wish to track (for example, cars equipped with LTAPs → RouterOS devices that act as MQTT publishers), and a ThingsBoard server run within a more powerful RouterOS device (like a CHR machine → RouterOS device that acts as an MQTT broker).

If you want to choose this route (container route), make sure to pick the devices that you plan on using as a "server" carefully, because this implementation can be heavy on RAM usage (it is suggested to have a device that has at least 2 GB RAM or 1 GB RAM with minimal load and is either ARM64 or AMD64 architecture).
Configuration

In this guide, we will demonstrate how to configure a GPS receiver (MQTT publisher) and how to set up ThingsBoard.

In case you want to use the container feature to run the ThingsBoard instance (MQTT broker), check the guide over here. General guidelines on ThingsBoard and MQTT configuration can be found in the guide over here. Make sure to explore both guides as they will have additional useful information.

Before proceeding, make sure that the ThingsBoard is up and running and that you can access its WEB management portal. Confirm that the MQTT port is open and/or port-forwarded properly.

Package requirement: gps, iot
ThingsBoard preparation

This example will showcase access-token and one-way SSL communication via access-token scenarios for simplicity reasons, but you can use other available options as well.

Navigate to the "Devices" menu and add a new device via the "Add new device" button → name it and create it (for example, LTAP):

Click on the device you've just added, go to the "Details" section, and generate an access token under the "Manage credentials/Device Credentials" setting:

MQTT broker configuration

In case it is a local test or the broker is available through the VPN, you can use non-SSL MQTT:
/iot/mqtt/brokers/add name=tb address=x.x.x.x port=1883 username=access_token

Where:

    name is the name that you wish to give to the broker and this name will be used later in the script;
    address is the IP address of the broker;
    port is the TCP port that the broker is listening for → for non-SSL it is typically TCP 1883;
    username is dictated by the MQTT broker and, in our case, it is an "access token" that was generated in the ThingsBoard management portal.

In case it is public access (when you want to access the broker via its public IP address), we advise you to use SSL MQTT:
/iot/mqtt/brokers/add name=tb address=x.x.x.x port=8883 username=access_token ssl=yes

Where:

    name is the name that you wish to give to the broker and this name will be used later in the script;
    address is the IP address of the broker;
    port is the TCP port that the broker is listening for → for SSL it is typically TCP 8883;
    username is dictated by the MQTT broker, and, in our case, it is an "access token" that was generated in the ThingsBoard management portal;
    ssl enables SSL MQTT communication.

MQTT publish

You can test MQTT publish with a static message by using the command:
/iot/mqtt/publish broker="tb" topic="v1/devices/me/telemetry" message="{\"test\":\"123\"}"

To post GPS coordinates, import the script shown below:
/system/script/add dont-require-permissions=no name=mqttgps owner=admin policy="ftp,re\
    boot,read,write,policy,test,password,sniff,sensitive,romon" \
    source="    ###Configuration###\r\
    \n    #Enter pre-configured broker's name within \"\":\r\
    \n    :local broker \"tb\"\r\
    \n    #Enter the topic name within \"\", per the broker's config\
    uration:\r\
    \n    :local topic \"v1/devices/me/telemetry\"\r\
    \n\r\
    \n    ###Variables####\r\
    \n    :global lat\r\
    \n    :global lon\r\
    \n    :global alt1\r\
    \n    :global alt2\r\
    \n\r\
    \n    ###GPS####\r\
    \n    :put (\"[*] Capturing GPS coordinates...\")\r\
    \n    /system gps monitor once do={\r\
    \n    :set \$lat \$(\"latitude\");\r\
    \n    :set \$lon \$(\"longitude\");\r\
    \n    :set \$alt1 \$(\"altitude\")}\r\
    \n    ###remove \"meters\" from the value because JSON format wi\
    ll not understand it###\r\
    \n    :set \$alt2 [:pick \$alt1 0 [find \$alt1 \" m\"]]\r\
    \n\r\
    \n    :local message \\\r\
    \n    \"{\\\"latitude\\\":\$lat,\\\r\
    \n    \\\"longitude\\\":\$lon,\\\r\
    \n    \\\"altitude\\\":\$alt2}\"\r\
    \n\r\
    \n    ###MQTT###\r\
    \n    :if (\$lat != \"none\") do={\\\r\
    \n    :put (\"[*] Sending message to MQTT broker...\");\r\
    \n    /iot mqtt publish broker=\$broker topic=\$topic message=\$\
    message} else={:put (\"[*] Lattitude=none, not posting anything!\
    \");:log info \"Latitude=none, not posting anything!\"}"

In short, the script captures GPS information, specifically the latitude, longitude, and altitude values. Then it structures a JSON message out of them. In case, at the moment when the script is initiated, the latitude value equals anything other than "none" (equals any actual value-number) → it sends the JSON message via MQTT to the broker named "tb". In case, the GPS data can not be captured →  "latitude" is recognized as "none" →  the script just logs that nothing could be captured and does nothing else.

This is a very basic example. Feel free to alter the script and add your own "if" (maybe an email notification if there is no GPS signal) and additional parameters (any other RouterOS captured value, like, maybe, its firmware version) per your requirements.

Run the script with the command:
/system/script/run mqttgps 
[*] Capturing GPS coordinates...
        date-and-time: feb/01/2023 10:39:37
             latitude: 56.969862
            longitude: 24.162425
             altitude: 31.799999 m
                speed: 1.000080 km/h
  destination-bearing: none
         true-bearing: 153.089996 deg. True
     magnetic-bearing: 0.000000 deg. Mag
                valid: yes
           satellites: 6
          fix-quality: 1
  horizontal-dilution: 1.42
             data-age: 0s
[*] Sending message to MQTT broker...

To automate the process, add a scheduler (to run the script, for example, every 30 seconds):
/system/scheduler/add name=mqttgpsscheduler interval=30s on-event="/system/script/run mqttgps"
Result verification

Go the the "Latest telemetry" section under your created device and confirm that the data was posted:

Data visualization using maps

ThingsBoard allows you to use Widgets to create visually appealing dashboards. In our case, we want to track our LTAP GPS coordinates, so we will need a map widget.

Select the latitude and longitude values and click on the "Show on widget" button:

Find the "Maps" bundle and click on the "Add to dashboard":

Select an existing dashboard or create a new one and name it however you like:

Run the script via the scheduler or manually and check the result:

Now, we can install it on a moving target and track its location:

