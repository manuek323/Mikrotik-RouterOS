

    Creado por Māris B., actualizado por última vez el jul 06, 2021 1 min de lectura

Fantasy menu is a fancy way to generate large amount of routes for testing purposes. Main benefits of this approach compared to script is the generation speed and simplicity. It is easy to remove all fantasy generated routes just by disabling fantasy rule.

Fantasy uses random generator from hashed route sequence number, seed and other parameters. 
Configuration Options
comment (string)	
count (integer:[0..4294967295])	How many routes to generate.
dealer-id (start-[end]:: integer:[0..4294967295])	
disabled (yes | no)	ID reference is not used.
dst-address(Prefix)	Prefix from which route will be generated. 
gateway (string)	
instance-id (start-[end]:: integer:[0..4294967295])	
name (string)	Reference name
offset (integer:[0..4294967295])	Route sequence number offset
prefix-length (start-[end]:: integer:[0..4294967295] )	Prefix length for generated route (can be specified as integer range). For example dst-address 192.168.0.0/16 and prefix-length 24 will generate /24 routes from 192.168.0.0/16 subnet.
priv-offset (start-[end]:: integer: [0..4294967295])	
priv-size (start-[end]:: integer: [0..100000])	
scope (start-[end]:: integer: [0..255])	Scope to be set, can be set as range
seed (string)	Random generator seed
target-scope (start-[end]:: integer: [0..255])	Target scope to be set, can be set as range
use-hold (yes | no)	





    Creado por Māris B., actualizado por última vez el feb 04, 2022 4 min de lectura

A read-only table that lists routes from all the address families as well as all filtered routes with all possible route attributes.


Default example output of the table with various route types:
[admin@MikroTik] /routing/route> print 
Flags: A - ACTIVE; c, s, a, l, y - COPY; H - HW-OFFLOADED
Columns: DST-ADDRESS, GATEWAY, AFI, DISTANCE, SCOPE, TARGET-SCOPE, IMMEDIATE-GW
    DST-ADDRESS                 GATEWAY           AFI   D  SCOPE  TA  IMMEDIATE-GW       
 lH 10.0.0.0/8                                    ip4   0                                
;;; defconf
As  10.0.0.0/8                  10.155.130.1      ip4   1     30  10  10.155.130.1%ether1
 lH 10.155.130.0/25                               ip4   0                                
Ac  10.155.130.0/25             ether1            ip4   0     10      ether1             
 aH 10.155.130.12/32                              ip4   0                                
 lH 111.13.0.0/24                                 ip4   0                                
Ac  111.13.0.0/24               ether2            ip4   0     10      ether2             
 aH 111.13.0.1/32                                 ip4   0                                
Ac  111.111.111.2/32            loopback@vrfTest  ip4   0     10      loopback           
Ac  2111:4::/64                 ether2            ip6   0     10      ether2             
Ac  fe80::%ether1/64            ether1            ip6   0     10      ether1             
Ac  fe80::%ether2/64            ether2            ip6   0     10      ether2             
Ac  fe80::%ether3/64            ether3            ip6   0     10      ether3             
Ac  fe80::%ether4/64            ether4            ip6   0     10      ether4             
Ac  3333::2/128                 loopback@vrfTest  ip6   0     10      loopback           
Ac  fe80::%loopback/64          loopback@vrfTest  ip6   0     10      loopback           
Ay  111.111.111.2/32&65530:100  loopback@vrfTest  vpn4  0     10   5  loopback           
Ay  3333::2/128&65530:100       loopback@vrfTest  vpn6  0     10   5  loopback           
A H ether1                                        link  0                                
A H ether2                                        link  0                                
A H ether3                                        link  0                                
A H ether4                                        link  0                                
A H loopback                                      link  0 


Detailed example output with some BGP, OSPF, and other routes:
[admin@MikroTik] /routing/route> print detail 
Flags: X - disabled, F - filtered, U - unreachable, A - active; 
c - connect, s - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn, m - modem, a - ldp-address, l - ldp-mapping, y - copy; H - hw-offloaded; 
+ - ecmp, B - blackhole 
  o   afi=ip4 contribution=best-candidate dst-address=0.0.0.0/0 routing-table=main gateway=10.155.101.1%ether1 immediate-gw=10.155.101.1%ether1 
       distance=110 scope=20 target-scope=10 belongs-to="OSPF route" 
       ospf.metric=2 .tag=111 .type=ext-type-1 
       debug.fwp-ptr=0x203425A0 

 Ad + afi=ip4 contribution=active dst-address=0.0.0.0/0 routing-table=main pref-src="" gateway=10.155.101.1 immediate-gw=10.155.101.1%ether1 
       distance=1 scope=30 target-scope=10 vrf-interface=ether1 belongs-to="DHCP route" 
       debug.fwp-ptr=0x20342060 

 As + afi=ip4 contribution=active dst-address=0.0.0.0/0 routing-table=main pref-src="" gateway=10.155.101.1 immediate-gw=10.155.101.1%ether1 
       distance=1 scope=30 target-scope=10 belongs-to="Static route" 
       debug.fwp-ptr=0x20342060 

 Fb   afi=ip4 contribution=filtered dst-address=1.0.0.0/24 routing-table=main gateway=10.155.101.1 immediate-gw=10.155.101.1%ether1 distance=20 
       scope=40 target-scope=10 belongs-to="BGP IP routes from 10.155.101.217" rpki=valid 
       bgp.peer-cache-id=*B000002 .aggregator="13335:172.68.180.1" .as-path="65530,100,9002,13335" .atomic-aggregate=yes .origin=igp 
       debug.fwp-ptr=0x20342960 



Property	Description
active (yes | no)	A flag indicates whether the route is elected as Active and eligible to be added to the FIB.
afi (ip4 | ip6 | link)	Address family this route belongs to.
belongs-to (string)	Descriptive info showing from where the route was received.
bgp (yes | no)	A flag indicates whether this route was added by the BGP protocol.
bgp - a group of parameters associated with the BGP protocol

	.as-path(string)	value of the AS_PATH BGP attribute

	.aggregator (string)	

	.atomic-aggregate (yes | no)	

	.cluster-list (string)	

	.communities (string)	value of the COMMUNITIES BGP attribute

	.ext-communities (string)	value of the EXTENDED_COMMUNITIES BGP attribute

	.igp-metric(string)	value of the IGP_METRIC BGP attribute

	.large-communities (string)	value of the LARGE_COMMUNITIES BGP attribute

	.local-pref (string)	value of the LOCAL_PREF BGP attribute

	.med (string)	value of the MED BGP attribute

	.nexthop (string)	

	.origin (string)	

	.originator-id (string)	

	.out-nexthop(string)	

	.peer-cache-id (string)	The ID of the BGP session that installed the route. See /routing/bgp/session menu.

	.unknown (string)	hex blob of unknown BGP attributes

	.weight (string)	
blackhole (yes | no)	A flag indicates whether it is a blackhole route
check-gateway (ping | arp | bfd)	Currently used check-gateway option.
comment (string)	
connect (yes | no)	A flag indicates whether it is a connected network route.
contribution (string)	Shows the route status contributing to the election process, e.g "filtered, active, candidate"
copy (yes | no)	A flag indicates a copy of the route to be redistributed as the L3VPN route. VPNv4/6 related attributes are attached to this "copy" route.
create-time (string)	
debug - a group of debugging parameters

	
	
dhcp (yes | no)	A flag indicates whether the route was added by the DHCP service.
disabled (yes | no)	A flag indicates whether the route is disabled.
distance (integer)	
dst-address (prefix)	Route destination.
ecmp (yes | no)	A flag indicates whether the route is added as an Equal-Cost Multi-Path route in the FIB. Read more>>
filtered (yes | no)	A flag indicates whether the route was filtered by routing filters and excluded from being used as the best route.
gateway (string)	Configured gateway, for the actually resolved gateway, see immediate-gw parameter.
hw-offloaded (yes | no)	Indicates whether the route is eligible to be hardware offloaded on supported hardware.
immediate-gw (string)	Shows actual (resolved) gateway and interface that will be used for packet forwarding. Displayed in format [ip%interface].
label (integer)	
ldp-address (yes | no)	A flag indicates whether the route entry is an LDP address.
ldp-mapping (yes | no)	A flag indicates whether the route entry is the LDP mapping
ldp - a group of parameters associated with the LDP protocol

	.label (integer)	LDP mapped MPLS label.

	.peer-id ()	
local-address (IP)	Local IP address of the connected network.
modem (yes | no)	A flag indicates whether the route is added by the LTE or 3g modems.
mpls - group of generic parameters associated with the MPLS

	.in-label ()	Mapped MPLS ingress label

	.labels ()	

	.out-label ()	Mapped MPLS egress label
nexthop-id ()	
ospf (yes | no)	A flag indicates whether the route was added by the OSPF routing protocol.
ospf - group of parameters associated with the OSPF protocol

	.metric (integer)	

	.type (string)	
pref-src ()	
received-from ()	
rip (yes | no)	A flag indicates whether the route was added by the RIP routing protocol
rip - group of parameters associated with the RIP protocol

	.metric ()	

	.route-tag ()	
route-cost ()	
routing-table ()	Routing table this route belongs to.
rpki (valid | invalid | unknown)	Current status of the prefix from the RPKI validation process.
scope (integer)	Scope used in the next-hop lookup process. Read more>>
static (yes | no)	A flag indicates statically added routes.
target-scope (integer)	Target scope used in next-hop lookup process. Read more>>
te-tunnel-id ()	Traffic Engineering tunnel ID
total-cost ()	
unreachable (yes | no)	A flag indicates whether the route next-hop is unreachable.
update-time ()	

	ve-block-offset	

	ve-block-size	

	ve-id	
vpn (yes | no)	A flag indicates whether the route was added by one of the VPN protocols (PPPoE, L2TP, SSTP, etc.)
vrf-interface ()	Internal use only parameter which allows identifying to which VRF route should be added. Used by services that add routes dynamically, for example, DHCP client. Shown for debugging purposes.




    Creado por Māris B., actualizado por última vez el jul 04, 2024 1 min de lectura

Global Router ID election configuration. ID can be configured explicitly or set to be elected from one of the Routers IP addresses.

For each VRF table RouterOS adds dynamic ID instance, that elects the ID from one of the IP addresses belonging to a particular VRF:
[admin@rack1_b33_CCR1036] /routing/id> print 
Flags: D - DYNAMIC, I - INACTIVE
Columns: NAME, DYNAMIC-ID, SELECT-DYNAMIC-ID, SELECT-FROM-VRF
#   NAME   DYNAMIC-ID      SELECT-D   SELE
0 D main   111.111.111.2   only-vrf   main
Configuration Options
comment (string)	
disabled (yes | no)	ID reference is not used.
id(IP)	Parameter to explicitly set the Router ID. If ID is not explicitly specified, then it can be elected from one of the configured IP addresses on the router. See parameters select-dynamic-id and select-from-vrf.
name (string)	Reference name
select-dynamic-id(any | lowest | only-active | only-loopback | only-static | only-vrf)	States what IP addresses to use for the ID election:

    any - any address found on the router can be elected as the Router ID.
    lowest - pick the lowest IP address.
    only-active - pick an ID only from active IP addresses.
    only-loopback - pick an ID only from loopback addresses (loopback address is considered any non point to point /32 address).
    only-vrf - pick an ID only from selected VRF. Works with select-from-vrf property.

select-from-vrf (name)	VRF from which to select IP addresses for the ID election.


Read-only Properties
dynamic (yes | no)	
dynamic-id (IP)	Currently selected ID.
inactive (yes | no)	If there was a problem to get a valid ID, then item can become inactive.

    Sin etiquetas 





    Creado por Māris B., actualizado por última vez el jun 16, 2023 2 min de lectura

Summary

Bidirectional Forwarding Detection (BFD) is a low-overhead and short-duration protocol intended to detect faults in the bidirectional path between two forwarding engines, including physical interfaces, sub-interfaces, data link(s), and to the extent possible the forwarding engines themselves, with potentially very low latency. It operates independently of media, data protocols, and routing protocols.

BFD is basically a hello protocol for checking bidirectional neighbor reachability. It provides sub-second link failure detection support. BFD is not routing protocol specific, unlike protocol hello timers or such.

BFD Control packets are transmitted in UDP packets with destination port 3784, BFD also uses port 4784 for multihop paths. The source port is in the range 49152 through 65535. And BFD Echo packets are encapsulated in UDP packets with destination port 3785.

Standards and Technologies:

    RFC 5880 Bidirectional Forwarding Detection (BFD)
    RFC 5881 BFD for IPv4 and IPv6
    RFC 5882 Generic Application of BFD
    RFC 5883 Bidirectional Forwarding Detection (BFD) for Multihop Paths


Features not yet supported

    echo mode
    enabling BFD for ip route gateways
    authentication


Configuration

Allowing or forbidding BFD sessions can be done from the /routing bfd configuration menu. For example:
/routing bfd configuration
add interfaces=sfp12 forbid-bfd=yes
add interfaces=static

Configuration entries are order sensitive, which means that in the example above we are forbidding BFD sessions explicitly on the "sfp12" interface and allowing on the rest of the interfaces belonging to the "static" interface list.


To be able to filter multi-hop sessions, addresses or address-list properties can be used to match the destination, as well as the appropriate VRF, if a session is not running in the "main" VRF.
/ip firewall address-list
add address=10.155.255.183 list=bgp_allow_bfd
add address=10.155.255.217 list=bgp_allow_bfd

/routing bfd configuration
add addresses=111.111.0.0/16 vrf=vrf1
add address-list=bgp_allow_bfd


Everything else that is not explicitly listed in the configuration by default is forbidden.
BFD with BGP

To enable the use of BFD for BGP sessions, enable use-bfd for required entries in /routing bgp connection menu.

A useful feature is that the BGP session will show that the BFD session for that particular BGP session is down:
[admin@dr_02_BGP_MUM] /routing/bgp/session> print 
Flags: E - established 
 0 E ;;; BFD session down
     name="ovpn_test1-1" 
     remote.address=111.111.11.11@vrf1 .as=65530 .id=10.155.101.217 
     .capabilities=mp,rr,as4 .hold-time=infinity .messages=40717 
     .bytes=3436281 .eor="" 
     local.address=111.111.11.12@vrf1 .as=555 .id=111.111.11.12 
     .capabilities=mp,rr,gr,as4 .messages=1 .bytes=19 .eor="" 
     output.procid=20 
     input.procid=20 .filter=bgp-in ebgp 
     hold-time=infinity use-bfd=yes uptime=3s210ms 
     last-started=2023-05-19 09:54:04 prefix-count=3853 
BFD with OSPF

To enable the use of BFD for OSPF neighbors, enable use-bfd for required entries in /routing ospf interface-template menu.
Session Status

The status of the currently available sessions can be observed from /routing bfd session menu:
[admin@dr_02_BGP_MUM] /routing/bfd/session> print 
Flags: U - up, I - inactive 
 0 I ;;; BFD forbidden for destination address
     multihop=yes remote-address=10.155.101.183 local-address="" desired-tx-interval=0ms required-min-rx=0ms 
     multiplier=0 

 1   multihop=no remote-address=111.111.11.11%ovpn-out1@vrf1 local-address=111.111.11.12@vrf1 state=down 
     state-changes=0 desired-tx-interval=200ms required-min-rx=200ms remote-min-rx=1us multiplier=5 
     packets-rx=0 packets-tx=7674 


BFD is picking the highest value between the local tx interval and remote minimum rx interval as desired transmit interval. If the session is not established then desired minimum tx interval is set to 1 second.




    Creado por Māris B., actualizado por última vez el ene 27, 2025 3 min de lectura

    Overview
    IS-IS Terminology
    Basic Configuration Example
    Troubleshooting
        ISIS does not work and prints warning message "invalid 3way tlv"

Overview

The IS-IS (Intermediate System - Intermediate System) protocol is an Interior Gateway Protocol (IGP) used to distribute IP routing information throughout a single Autonomous System.

It was originally developed as a routing protocol for CLNP but later extended to include IP routing when IP became popular.  An extended version is sometimes referred to as Integrated IS-IS.

IS-IS belongs to the link-state protocol family, which exchanges topology information between nearest neighbors and floods it throughout the AS. The main advantage is that complete knowledge of the network topology allows one to choose the best path to the destination. It can also be useful for traffic engineering purposes.

Neighbours periodically exchange Hello packets, forms adjacency and selects designated IS based on the negotiation. Hello packets are sent individually for Level-1 and Level-2.

Standards and Technologies:

    RFC 1195 Use of OSI IS-IS for Routing in TCP/IP and Dual Environments
    RFC 5302 Domain-Wide Prefix Distribution with Two-Level IS-IS
    RFC 5303 Three-Way Handshake for IS-IS Point-to-Point Adjacencies
    RFC 5305 IS-IS Extensions for Traffic Engineering (only wide metric support)
    RFC 5308 Routing IPv6 with IS-IS

IS-IS Terminology


    IS - Intermediate System is a router capable of forwarding traffic between distantly located hosts.
    LSP - Link State PDU contains information on the router's local state (usable interfaces, reachable neighbours, and the cost of the interfaces)
    SPF - Shortest-path-first algorithm
    DIS - designated intermediate system. DIS ensures that all routes in the network maintain synchronised database. Separate DISs are elected for L1 and L2 routing. Election of the DIS is based on the highest interface priority.
    Level-1 (L1) routing - Controls distribution of routing information within an IS-IS area. L1 routing is based on system ID.
    Level-2 (L2) routing - Controls distribution of routing information between IS-IS areas. L2 routing is based on area ID.
    IS-IS Adjacency - link between IS-IS neighbours. The type of adjacency formed depends on the parameters exchanged in the IS-IS Hello packets. Each of the the adjacent routers runs the DIS election process to determine whether it is eligible to be an L1 or L2 DIS on the broadcast network.


Basic Configuration Example

Basic IS-IS setup between three routers.

R1:
/routing isis instance
add afi=ip areas=49.2222 disabled=no name=isis-instance-1 system-id=90ab.cdef.0001
/routing isis interface-template
add instance=isis-instance-1 interfaces=ether1 levels=l1,l2


[] /routing/isis/neighbor> print 
 0 instance=isis-instance-1 interface=ether1 level-type=l2 snpa=08:00:27:22:B4:A2 srcid="1111.2222.aded" state=up 

 1 instance=isis-instance-1 interface=ether1 level-type=l2 snpa=D4:CA:6D:78:2F:2E srcid="1111.2222.cded" state=up 

 2 instance=isis-instance-1 interface=ether1 level-type=l1 snpa=08:00:27:22:B4:A2 srcid="1111.2222.aded" state=up 

 3 instance=isis-instance-1 interface=ether1 level-type=l1 snpa=D4:CA:6D:78:2F:2E srcid="1111.2222.cded" state=up 


[] /routing/route> print where is-is
Flags: A - ACTIVE; i - IS-IS
Columns: DST-ADDRESS, GATEWAY, AFI, DISTANCE, SCOPE, TARGET-SCOPE, IMMEDIATE-GW
   DST-ADDRESS        GATEWAY                AFI  DISTANCE  SCOPE  TARGET-SCOPE  IMMEDIATE-GW         
 i 0.0.0.0/0          10.155.101.214%ether1  ip4       115     20            10  10.155.101.214%ether1
 i 10.155.101.0/24    10.155.101.216%ether1  ip4       115     20            10  10.155.101.216%ether1
Ai 10.255.255.162/32  10.155.101.216%ether1  ip4       115     20            10  10.155.101.216%ether1


R2:
/routing isis instance
add afi=ip areas=49.2222 disabled=no l1.originate-default=always l2.originate-default=always name=isis-instance-1 \
    system-id=1111.2222.cded
/routing isis interface-template
add instance=isis-instance-1 interfaces=sfp12 levels=l1,l2
add instance=isis-instance-1 interfaces=lo levels=l2


[] /routing/isis/neighbor> print 
 0 instance=isis-instance-1 interface=sfp12 level-type=l1 snpa=08:00:27:22:B4:A2 srcid="1111.2222.aded" state=up 

 1 instance=isis-instance-1 interface=sfp12 level-type=l1 snpa=C4:AD:34:43:EA:5C srcid="90ab.cdef.0001" state=up 

 2 instance=isis-instance-1 interface=sfp12 level-type=l2 snpa=08:00:27:22:B4:A2 srcid="1111.2222.aded" state=up 

 3 instance=isis-instance-1 interface=sfp12 level-type=l2 snpa=C4:AD:34:43:EA:5C srcid="90ab.cdef.0001" state=up 



R3 Cisco:
interface Loopback0
 ip address 10.255.255.162 255.255.255.255
 ip router isis 
!
interface GigabitEthernet1
 ip address dhcp
 ip router isis 
 negotiation auto
!
router isis
 net 49.2222.1111.2222.aded.00
!



# show isis neighbors 

Tag null:
System Id      Type Interface   IP Address      State Holdtime Circuit Id
90AB.CDEF.0001 L1   Gi1         10.155.101.183  UP    27       1111.2222.CDED.01  
90AB.CDEF.0001 L2   Gi1         10.155.101.183  UP    27       1111.2222.CDED.01  
1111.2222.CDED L1   Gi1         10.155.101.214  UP    9        1111.2222.CDED.01  
1111.2222.CDED L2   Gi1         10.155.101.214  UP    9        1111.2222.CDED.01 

# show ip route

i*L1  0.0.0.0/0 [115/11] via 10.155.101.214, 4w5d, GigabitEthernet1
      10.0.0.0/8 is variably subnetted, 5 subnets, 2 masks
C        10.155.101.0/24 is directly connected, GigabitEthernet1
L        10.155.101.216/32 is directly connected, GigabitEthernet1
i L2     10.155.255.214/32 [115/10] via 10.155.101.183, 2w3d, GigabitEthernet1


Troubleshooting
ISIS does not work and prints warning message "invalid 3way tlv"
This warning indicates that most likely remote neighbor does not comply  to 3-way handshake for point-to-point networks from RFC 5302. For example, on Cisco you have to enable "isis three-way-handshake ietf" on interface to have 15byte TLV.



    Creado por Māris B., actualizado por última vez el jun 26, 2025 11 min de lectura

    Overview
    Terminology
    Route list
    Configuration Examples
        Basic Configuration Example
        Bridged EVPN VXLAN Overlay with Arista's Eos and ROS
            Topology
            Underlay Configuration
                Ros_Spine
                Ros_Leaf_3
                Eos_Leaf
            BGP EVPN Overlay
                Ros_Spine
                Ros_Leaf_3
                Eos_Leaf
                Verify BGP Connectivity
            VXLAN and EVPN configuration
                Ros_Leaf_3
                Eos_Leaf
                Host_1
                Host_3
            Validate L2VPN Service 
        Bridged EVPN Overlay with Arista ESI LAG
            Topology
            Configuration Prerequisities
            Port Channel configuration
            Validate setup

Overview

Ethernet Virtual Private Network (EVPN) is a technology to extend Layer 2 and 3 connectivity between different network segments. MPLS or VXLAN encapsulations can be used to transfer ethernet frames over MPLS or IP-based networks.

BGP EVPN  is used as a control plane for multiple data-planes encapsulations (for both Layer2 and Layer3 VPN services). MP-BGP carries MAC addresses, MAC/IP bindings and IP prefixes. 

RFC7432 is initial EVPN standard thad defines BGP as control plane for MPLS data plane. RFC8365 extends the use of additional data planes, VXLAN, NVGRE and MPLS over GRE and defines the use of EVPN as Network Virtualization Overlay (NVO).
Terminology

    NVO: Network Virtualization Overlay used to deliver Layer2 and Layer 3 VPN services.
    NVE: Network Virtualization Endpoint is Provider Edge (PE) node within the NVO environment. It is responsible for encapsulation/decapsulation of VPN traffic. In case of VXLAN this defines VTEP (Virtual Tunnel End Point).
    VNI: Virtual Network Identifier 
    EVI: EVPN Instance
    RD: Route Distinguisher is a 64-bit prefix appended to IP prefix to make it unique, multiple tenants can use overlapping IP range.
    RT: Route Target is BGP extended community used to control import and export of routes. Typically, RT is based on the AS number and the VNI of the MAC-VRF
    MAC-VRF: VRF table for MAC addresses on a PE (VTEP). Requires RD and RT.
    BUM:  Broadcast, unknown Unicast and Multicast traffic is a multi-destination layer2 traffic in vxlan networks.
    Ingress replication: unicast approach to handle BUM traffic. It uses IMET routes to auto-discover remote peers.  Ingress device replicates BUM traffic to all the VTEPS associated with the Layer-2 VNI.
    ESI - Ethernet Segment Identifier

For MP-BGP to carry EVPN, new AFI/SAFI was defined 25(L2 VPN)/70(EVPN). Next-hop address within the NLRI is an IP address of the VTEP advertising the EVPN route.

There are five EVPN route types:

    Type-1: (Ethernet A-D) announces reachability of multi-homed ethernet segment
    Type-2:( MAC advertisement MACIP) advertises MAC address of MAC/IP binding learned by specific EVI
    Type-3: (Inclusive multicast IMET) advertises membership of a Layer 2 domain, allowing to auto discover VTEPs 
    Type-4: (Ethernet segment) is used to discover VTEPs attached to the same shared Ethernet Segment for EVPN multi-homing model (active-active, active-standby forwarding)
    Type-5: (IP prefix) Advertising IP prefix into the EVPN domain allows to create classic Layer 3 VPN. 

Data plane encapsulation is defined with encapsulation extended community value:

    8 - VXLAN (currently only one supported by ROS)
    9 - NVGRE
    10 - MPLS
    11 - MPLSoGRE

There are two methods for supporting inter-subnet routing with EVPN: symmetric and asymmetric integrated routing and bridging (IRB). The main difference between the two methods is that the symmetric method supports both routing and bridged on both the ingress and egress VTEPs, where the asymmetric method supports routing on the ingress, but only bridging on the egress.


Route list

RouterOS will show local and received EVPN routes in the /routing/route list

Locally generated routes will hace e-evpn flag. for example:
[admin@ros_leaf_3] /routing/route> print where evpn 
Flags: e - EVPN
Columns: DST-ADDRESS, GATEWAY, AFI, DISTANCE, SCOPE, TARGET-SCOPE
  DST-ADDRESS                                     GATEWAY        AFI   DISTANCE  SCOPE  TARGET-SCOPE
e [10.155.101.133:1010]macip:0|0C:50:85:84:00:01  203.0.255.133  evpn       200     40            10
e [10.155.101.133:1010]imet:0|203.0.255.133       203.0.255.133  evpn       200     40            10
e [203.0.255.133:4]imet:0|203.0.255.133           203.0.255.133  evpn       200     40            10


EVPN data is encoded in dst-address parameter:

    Dst [rd]type:x|y
         ^  ^    ^ 
         |  |    + - where x - tag or ESI; y - type specific data (can show mac addresses, ip addresses, ethernet segments etc.)
         |  +------- name of the EVPN route type (macip, imet, es, ad, prefix)
         +---------- route distinguisher in square brackets



Configuration Examples
Basic Configuration Example

Basic Layer2 EVPN Vxlan configuration:
/interface bridge
add name=bridge1 vlan-filtering=yes pvid=40
/interface bridge port
add bridge=bridge1 interface=sfp-sfpplus3 pvid=40

/ip address 
add address=203.0.113.1 interface=lo

/interface vxlan
add bridge=bridge1 bridge-pvid=40 local-address=203.0.113.1 name=vxlan1 vni=100040 learning=no

/routing bgp instance
add as=65000 name=evpn-inst

/routing bgp connection
add afi=evpn instance=evpn-inst local.address=203.0.113.1 .role=ebgp multihop=yes name=to-leaf-lo remote.address=203.0.113.2 .as=65001

/routing bgp evpn
add instance=evpn-inst name=bgp-evpn-1o vni=100040

For simple setups with only one vni, there is no need to set route distinguisher and import/export route targets.
 
When RTs or RD are not specified, values are derived automatically. Route targets are set to <PE ASN>:<VNI>, route distinguishers <PE address>:<num derived from config id>).

EVPN configuration is directly mapped to VXLAN configurations with matching VNIs


Bridged EVPN VXLAN Overlay with Arista's Eos and ROS
Topology

For this example we will use the following topology:


    203.0.255.0/24 address range is used for loopback addresses
    Subnets from 172.16.0.0/16 range is used for underlay connectivity of leaf and spine routers
    Subnets from 192.168.0.0/16 range is used for host addressing on vlans.

Underlay Configuration

Underly connectivity can depend on already existing setups, it can be eBGP, OSPF, ISIS or even static routing. In this case we will be using OSPF as underly routing protocol to advertise routes for addresses associated with loopback interfaces.
Ros_Spine
/ip address
add address=203.0.255.138 interface=lo
add address=172.16.1.1/30 interface=ether3
add address=172.16.2.1/30 interface=ether4
add address=172.16.3.1/30 interface=ether5
add address=172.16.4.1/30 interface=ether6
add address=172.16.5.1/30 interface=ether7

/routing ospf instance
add name=evpn_underlay
/routing ospf area
add disabled=no instance=evpn_underlay name=evpn-underlay-bb
/routing ospf interface-template
add area=evpn-underlay-bb disabled=no networks=172.16.0.0/16
add area=evpn-underlay-bb disabled=no interfaces=lo passive


Ros_Leaf_3
/ip address
add address=203.0.255.133 interface=lo
add address=172.16.3.2/30 interface=ether10

/routing ospf instance
add name=evpn_underlay
/routing ospf area
add disabled=no instance=evpn_underlay name=evpn-underlay-bb
/routing ospf interface-template
add area=evpn-underlay-bb disabled=no networks=172.16.0.0/16
add area=evpn-underlay-bb disabled=no interfaces=lo passive


Eos_Leaf
interface Ethernet1
   no switchport
   ip address 172.16.5.2/30
!
interface Loopback0
   ip address 203.0.255.128/32
!
ip routing
!
router ospf 100
   router-id 203.0.255.135
   redistribute connected
   network 172.16.1.0/30 area 0.0.0.0
!


BGP EVPN Overlay

For BGP overly we will be using multihop eBGP that uses loopback addresses.

To simplify configuration we will utilize BGP template to set common parameters and set connection to listen on all loopback address range. This is great for scalability, if we will want to add more leaf routers we won't need to configure anything on the spine routers.

Also it is recommended to set nexthop-choice to propagate especially if there is more than one spine. In case if iBGP is used as overlay then spines should be route reflectors and nexthop propagation is happening by default.
Ros_Spine
/routing bgp instance
add as=65000 name=bgp-instance-1
/routing bgp template
set default afi=evpn multihop=yes nexthop-choice=propagate
/routing bgp connection
add instance=bgp-instance-1 local.address=203.0.255.138 .role=ebgp name=evpn_leafs remote.address=\
    203.0.255.0/24 templates=default


Ros_Leaf_3
/routing bgp instance
add as=65003 disabled=no name=bgp-instance-1
/routing bgp connection
add afi=evpn instance=bgp-instance-1 local.address=203.0.255.133 .role=ebgp multihop=yes name=to_spine remote.address=\
    203.0.255.138


Eos_Leaf
service routing protocols model multi-agent
!
router bgp 65005
   neighbor SPINE_EVPN peer group
   neighbor SPINE_EVPN remote-as 65000
   neighbor SPINE_EVPN update-source Loopback0
   neighbor SPINE_EVPN ebgp-multihop 10
   neighbor SPINE_EVPN send-community extended
   neighbor 203.0.255.138 peer group SPINE_EVPN
   !
   address-family evpn
      neighbor SPINE_EVPN activate
!


Verify BGP Connectivity

Eos_Leaf
localhost#show bgp summary 
BGP summary information for VRF default
Router identifier 203.0.255.128, local AS number 65005
Neighbor               AS Session State AFI/SAFI                AFI/SAFI State   NLRI Rcd   NLRI Acc
------------- ----------- ------------- ----------------------- -------------- ---------- ----------
203.0.255.138       65000 Established   IPv4 Unicast            Advertised              0          0
203.0.255.138       65000 Established   L2VPN EVPN              Negotiated              6          6

Ros_Leaf_3
[admin@ros_leaf_3] /routing/bgp/session> print 
Flags: E - established 
 0 E name="to_spine-1" instance=bgp-instance-1 
     remote.address=203.0.255.138 .as=65000 .id=203.0.255.138 .capabilities=mp,rr,gr,as4 .afi=evpn .messages=7 .bytes=682 .eor="" 
     local.address=203.0.255.133 .as=65003 .id=203.0.255.133 .cluster-id=203.0.255.133 .capabilities=mp,rr,gr,as4 .afi=evpn .messages=7 
     .bytes=698 .eor="" 
     output.procid=20 
     input.procid=20 ebgp 
     multihop=yes hold-time=3m keepalive-time=1m uptime=1s620ms last-started=2025-05-29 11:01:38 prefix-count=0 



VXLAN and EVPN configuration
Ros_Leaf_3

Just for demonstration purposes, on RouterOS leaf we will be sending vlan tagged traffic to the host.

VXLAN learning should be disabled as we are using BGP EVPN for discovery.
/interface bridge
add name=bridge1 pvid=10 vlan-filtering=yes
/interface vxlan
add bridge=bridge1 bridge-pvid=10 learning=no local-address=203.0.255.133 mac-address=C2:16:F6:B2:CC:D3 name=vxlan1 vni=1010
/interface bridge port
add bridge=bridge1 interface=ether11 pvid=10
/ip address
add address=192.168.10.133/24 interface=bridge1
/routing bgp evpn
add disabled=no export.route-targets=1010:1010 import.route-targets=1010:1010 instance=bgp-instance-1 name=bgp-evpn-1 vni=1010


Eos_Leaf

On the Arista router we are setting vlan trunk, untagged traffic will be sent to the host
vlan 10
!
interface Ethernet2
   switchport trunk allowed vlan 10
   switchport mode trunk
!
interface Vlan10
   ip address 192.168.10.128/24
!
interface Vxlan1
   vxlan source-interface Loopback0
   vxlan vlan 10 vni 1010
!
router bgp 65501
   vlan 10
      rd 203.0.255.128:1010
      route-target both 1010:1010
      redistribute learned


Host_1
/ip address
add address=192.168.10.132/24 interface=ether2


Host_3
/interface vlan
add interface=ether2 name=vlan10 vlan-id=10
/ip address
add address=192.168.10.129/24 interface=vlan10


Validate L2VPN Service 

Lets verify that IMET routes are present on leaf routers and that vteps are discovered
[admin@ros_leaf_3] /routing/route> print where dst-address~"imet"
Flags: A - ACTIVE; b - BGP, e - EVPN
Columns: DST-ADDRESS, GATEWAY, AFI, DISTANCE, SCOPE, TARGET-SCOPE, IMMEDIATE-GW
   DST-ADDRESS                               GATEWAY        AFI   DISTANCE  SCOPE  TARGET-SCOPE  IMMEDIATE-GW      
Ab [203.0.255.128:1010]imet:0|203.0.255.128  203.0.255.128  evpn        20     40            30  172.16.3.1%ether10
 e [203.0.255.133:256]imet:0|203.0.255.133   203.0.255.133  evpn       200     40            10                    


[admin@ros_leaf_3] /interface/vxlan/vteps> print 
Flags: D - DYNAMIC
Columns: INTERFACE, REMOTE-IP
#   INTERFACE  REMOTE-IP    
0 D vxlan1     203.0.255.128

On Arista:
localhost#show bgp evpn route-type imet
BGP routing table information for VRF default
Router identifier 203.0.255.135, local AS number 65501
Route status codes: * - valid, > - active, S - Stale, E - ECMP head, e - ECMP
                    c - Contributing to ECMP, % - Pending BGP convergence
Origin codes: i - IGP, e - EGP, ? - incomplete
AS Path Attributes: Or-ID - Originator ID, C-LST - Cluster List, LL Nexthop - Link Local Nexthop

          Network                Next Hop              Metric  LocPref Weight  Path
 * >      RD: 203.0.255.128:1010 imet 203.0.255.128
                                 -                     -       -       0       i
 * >      RD: 203.0.255.133:256 imet 203.0.255.133
                                 203.0.255.133         -       100     0       65000 65003 i

localhost#show interfaces vxlan1
Vxlan1 is up, line protocol is up (connected)
  Hardware is Vxlan
  Source interface is Loopback0 and is active with 203.0.255.128
  Listening on UDP port 4789
  Replication/Flood Mode is headend with Flood List Source: EVPN
  Remote MAC learning via EVPN
  VNI mapping to VLANs
  Static VLAN to VNI mapping is 
    [10, 1010]       
  Note: All Dynamic VLANs used by VCS are internal VLANs.
        Use 'show vxlan vni' for details.
  Static VRF to VNI mapping is not configured
  Headend replication flood vtep list is:
    10 203.0.255.133 
  Shared Router MAC is 0000.0000.0000


localhost#show vxlan flood vtep vlan 10
          VXLAN Flood VTEP Table
--------------------------------------------------------------------------------

VLANS                            Ip Address
-----------------------------   ------------------------------------------------
10                              203.0.255.133  
                                



At this point we can try to ping host_3 from host_1:
[admin@host_1] /interface> print 
...
1 R ether2  ether           1500  0C:50:85:84:00:01

[admin@host_1] /ip/address> /ping 192.168.10.129
  SEQ HOST                                     SIZE TTL TIME       STATUS                                                 
    0 192.168.10.129                             56  64 17ms26us  
    1 192.168.10.129                             56  64 13ms119us 
    2 192.168.10.129                             56  64 17ms192us 

host-3
[admin@host_1] /interface> print 
...
1 R ether2  ether           1500  0C:74:39:88:00:01



Now we should be able to see that EVPN is used to learn remote MAC addresses by looking at MACIP routes.

If we look at routes on ros_leaf, we can see that router 203.0.255.128 sent the macip route for 0C:74:39:88:00:01 mac address which is the host_1 mac address located behind eos_leaf.

Eos also sends MAC/IP binding which is used for arp/nd suppression. Unfortunately at the time of writing this article RouterOS does not have this functionality.
[admin@ros_leaf_3] /routing/route> print where dst-address~"macip"    
Flags: A - ACTIVE; b - BGP, e - EVPN
Columns: DST-ADDRESS, GATEWAY, AFI, DISTANCE, SCOPE, TARGET-SCOPE, IMMEDIATE-GW
   DST-ADDRESS                                                   GATEWAY        AFI   DISTANCE  SCOPE  TARGET-SCOPE  IMMEDIATE-GW      
Ab [203.0.255.128:1010]macip:0|0C:74:39:88:00:01                 203.0.255.128  evpn        20     40            30  172.16.3.1%ether10
 e [203.0.255.133:256]macip:0|0C:50:85:84:00:01                  203.0.255.133  evpn       200     40            10                    
Ab [203.0.255.128:1010]macip:0|0C:74:39:88:00:01|192.168.10.129  203.0.255.128  evpn        20     40            30  172.16.3.1%ether10


Arista allows additionally to see remotely learned mac addresses in "vxlan mac table" and "vlan mac-address table" includes local mac addresses as well:
localhost#show bgp evpn route-type mac-ip detail 
BGP routing table information for VRF default
Router identifier 203.0.255.128, local AS number 65005
BGP routing table entry for mac-ip 0c50.8584.0001, Route Distinguisher: 203.0.255.133:256
 Paths: 1 available
  65000 65003
    203.0.255.133 from 203.0.255.138 (203.0.255.138)
      Origin IGP, metric -, localpref 100, weight 0, tag 0, valid, external, best
      Extended Community: Route-Target-AS:1010:1010 TunnelEncap:tunnelTypeVxlan
      VNI: 0 ESI: 0000:0000:0000:0000:0000
BGP routing table entry for mac-ip 0c74.3988.0001, Route Distinguisher: 203.0.255.128:1010
 Paths: 1 available
  Local
    - from - (0.0.0.0)
      Origin IGP, metric -, localpref -, weight 0, tag 0, valid, local, best
      Extended Community: Route-Target-AS:1010:1010 TunnelEncap:tunnelTypeVxlan
      VNI: 1010 ESI: 0000:0000:0000:0000:0000
BGP routing table entry for mac-ip 0c74.3988.0001 192.168.10.129, Route Distinguisher: 203.0.255.128:1010
 Paths: 1 available
  Local
    - from - (0.0.0.0)
      Origin IGP, metric -, localpref -, weight 0, tag 0, valid, local, best
      Extended Community: Route-Target-AS:1010:1010 TunnelEncap:tunnelTypeVxlan
      VNI: 1010 ESI: 0000:0000:0000:0000:0000


localhost#show vxlan address-table vlan 10
          Vxlan Mac Address Table
----------------------------------------------------------------------

VLAN  Mac Address     Type      Prt  VTEP             Moves   Last Move
----  -----------     ----      ---  ----             -----   ---------
  10  0c50.8584.0001  EVPN      Vx1  203.0.255.133    1       1:30:49 ago
Total Remote Mac Addresses for this criterion: 1



localhost#show mac address-table vlan 10
          Mac Address Table
------------------------------------------------------------------

Vlan    Mac Address       Type        Ports      Moves   Last Move
----    -----------       ----        -----      -----   ---------
  10    0c50.8584.0001    DYNAMIC     Vx1        1       1:31:17 ago
  10    0c74.3988.0001    DYNAMIC     Et2        1       1 day, 23:45:18 ago
Total Mac Addresses for this criterion: 2

          Multicast Mac Address Table
------------------------------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       ----        -----
Total Mac Addresses for this criterion: 0



Bridged EVPN Overlay with Arista ESI LAG

ESI-LAG (Ethernet Segment Identifier - Link Aggregation) or EVPN-LAG  is a networking concept that enables multihoming using EVPN (Ethernet Virtual Private Network) technology, where client devices (like access switches) can connect to core devices (like distribution switches) through multiple links, forming a logical LAG interface.
Topology

Lets extend the topology from the previous example. Host_2 is a RouterOS device with LACP enabled on links connecting to two ARISTA Leafs, forming active-active multihoming setup.


Configuration Prerequisities

On how to set up underly and EVPN overly configuration refer to example above. In this example we will focus on ESI LAG configuration and setup validation.


Port Channel configuration

Assuming that underly and overly is configured, and is up and running, we will proceed to port channel configuration on Arista switches:

leaf_2 and leaf_4 config is exactly the same
interface Port-Channel3
   switchport access vlan 10
   switchport trunk allowed vlan 10
   switchport mode trunk
   !
   evpn ethernet-segment
      identifier 0000:0000:0000:0333:3333
      route-target import 00:00:03:33:33:33
   lacp system-id 0000.0333.3333
!
interface Ethernet2
   channel-group 3 mode active


ros_host_2
/interface bonding
add mode=802.3ad name=bond1 slaves=ether2,ether3
/interface vlan
add interface=bond1 mtu=1496 name=vlan10 vlan-id=10
/ip address
add address=192.168.10.130/24 interface=vlan10


Validate setup

Now if we look at evpn routes we should see some new route types. Both Arista switches are advertising Type-1 AD routes and Type-4 Ethernet Segment (ES) routes to discover multihoming VTEPs 
[admin@gns3_spine1_ros] /routing/route>  print where afi=evpn dst-address~"(ad|es)"
Flags: A - ACTIVE; b - BGP
Columns: DST-ADDRESS, GATEWAY, AFI, DISTANCE, SCOPE, TARGET-SCOPE
   DST-ADDRESS                                                      GATEWAY        AFI   DISTANCE  SCOPE  TA
Ab [203.0.255.127:1]ad:4294967295|00:00:00:00:00:00:03:33:33:33     203.0.255.127  evpn        20     40  30
Ab [203.0.255.127:1]es:00:00:00:00:00:00:03:33:33:33|203.0.255.127  203.0.255.127  evpn        20     40  30
Ab [203.0.255.127:1010]ad:0|00:00:00:00:00:00:03:33:33:33           203.0.255.127  evpn        20     40  30

Ab [203.0.255.134:1]ad:4294967295|00:00:00:00:00:00:03:33:33:33     203.0.255.134  evpn        20     40  30
Ab [203.0.255.134:1]es:00:00:00:00:00:00:03:33:33:33|203.0.255.134  203.0.255.134  evpn        20     40  30
Ab [203.0.255.134:1010]ad:0|00:00:00:00:00:00:03:33:33:33           203.0.255.134  evpn        20     40  30



If we check both Eos leafs, we will see that designated forwarder 203.0.255.127 (eos_leaf_4) is selected:
eos_leaf_2#show bgp evpn instance vlan 10
EVPN instance: VLAN 10
  Route distinguisher: 203.0.255.134:1010
  Route target import: Route-Target-AS:1010:1010
  Route target export: Route-Target-AS:1010:1010
  Service interface: VLAN-based
  Local VXLAN IP address: 203.0.255.134
  VXLAN: enabled
  MPLS: disabled
  Local ethernet segment:
    ESI: 0000:0000:0000:0333:3333
      Type: 0 (administratively configured)
      Interface: Port-Channel3
      Mode: all-active
      State: up
      ES-Import RT: 00:00:03:33:33:33
      DF election algorithm: modulus
      Designated forwarder: 203.0.255.127
      Non-Designated forwarder: 203.0.255.134


Lets suspend the link from host2 to eos_leaf_4 and see what happens:

eos_leaf_2#show bgp evpn instance vlan 10
EVPN instance: VLAN 10
  Route distinguisher: 203.0.255.134:1010
  Route target import: Route-Target-AS:1010:1010
  Route target export: Route-Target-AS:1010:1010
  Service interface: VLAN-based
  Local VXLAN IP address: 203.0.255.134
  VXLAN: enabled
  MPLS: disabled
  Local ethernet segment:
    ESI: 0000:0000:0000:0333:3333
      Type: 0 (administratively configured)
      Interface: Port-Channel3
      Mode: all-active
      State: up
      ES-Import RT: 00:00:03:33:33:33
      DF election algorithm: modulus
      Designated forwarder: 203.0.255.134



[admin@spine1_ros] /routing/route>  print interval=1 where dst-address~"ad|es"
Flags: A - ACTIVE; b - BGP
Columns: DST-ADDRESS, GATEWAY, AFI, DISTANCE, SCOPE, TARGET-SCOPE
   DST-ADDRESS                                                      GATEWAY        AFI   DISTANCE  SCOPE  TA
Ab [203.0.255.134:1]ad:4294967295|00:00:00:00:00:00:03:33:33:33     203.0.255.134  evpn        20     40  30
Ab [203.0.255.134:1]es:00:00:00:00:00:00:03:33:33:33|203.0.255.134  203.0.255.134  evpn        20     40  30
Ab [203.0.255.134:1010]ad:0|00:00:00:00:00:00:03:33:33:33           203.0.255.134  evpn        20     40  30


[admin@host_2] /interface/bonding> /ping 192.168.10.132 interval=500ms
  SEQ HOST                                     SIZE TTL TIME       STATUS                                    
    0 192.168.10.132                             56  64 2ms90us   
    1 192.168.10.132                             56  64 2ms172us  
    2 192.168.10.132                             56  64 2ms503us  
    3 192.168.10.132                                               timeout                                   
    4 192.168.10.132                                               timeout                                   
    5 192.168.10.132                                               timeout                                   
    6 192.168.10.132                             56  64 2ms191us  
    7 192.168.10.132                             56  64 2ms31us   

eos_leaf_2 became forwarder, eos_leaf_4 withdraw  ES and AD routes and traffic switched to other LACP link.







    Creado por Oskars K., actualizado por última vez por Lība Klepecka el jun 02, 2025 21 min de lectura

Scripting language manual

This manual provides an introduction to RouterOS's built-in powerful scripting language.

Scripting host provides a way to automate some router maintenance tasks by means of executing user-defined scripts bounded to some event occurrence.

Scripts can be stored in the Script repository or can be written directly to the console. The events used to trigger script execution include, but are not limited to the System Scheduler, the Traffic Monitoring Tool, and the Netwatch Tool generated events.

If you are already familiar with scripting in RouterOS, you might want to see our Tips & Tricks.
Line structure

The RouterOS script is divided into a number of command lines. Command lines are executed one by one until the end of the script or until a runtime error occurs.
Command-line

The RouterOS console uses the following command syntax:

[prefix] [path] command [uparam] [param=[value]] .. [param=[value]]

    [prefix] - ":" or "/" character which indicates if a command is ICE or path. It may not be required.
    [path] - relative path to the desired menu level. It may not be required.
    command - one of the commands available at the specified menu level.
    [uparam] - unnamed parameter, must be specified if the command requires it.
    [params] - a sequence of named parameters followed by respective values

The end of the command line is represented by the token “;” or NEWLINE. Sometimes “;” or NEWLINE is not required to end the command line.

Single command inside (), [] or {} does not require any end-of-command character. The end of the command is determined by the content of the whole script
:if ( true ) do={ :put "lala" }

Each command line inside another command line starts and ends with square brackets "[ ]" (command concatenation).
:put [/ip route get [find gateway=1.1.1.1]]; 

Notice that the code above contains three command lines:

    :put
    /ip route get
    find gateway=1.1.1.1

Command-line can be constructed from more than one physical line by following line joining rules.
Physical Line

A physical line is a sequence of characters terminated by an end-of-line (EOL) sequence. Any of the standard platform line termination sequences can be used:

    Unix – ASCII LF;
    Windows – ASCII CR LF;
    mac – ASCII CR;

Standard C conventions for newline characters can be used ( the \n character).
Comments

The following rules apply to a comment:

    A comment starts with a hash character (#) and ends at the end of the physical line.
    RouterOS does not support multiline comments.
    If a # character appears inside the string it is not considered a comment.

Example
# this is a comment 
# next line comment
:global a; # another valid comment

:global myStr "part of the string # is not a comment"
Line joining

Two or more physical lines may be joined into logical lines using the backslash character (\).

The following rules apply to using backslash as a line-joining tool:

    A line ending in a backslash cannot carry a comment.
    A backslash does not continue a comment.
    A backslash does not continue a token except for string literals.
    A backslash is illegal elsewhere on a line outside a string literal.

Example
:if ($a = true \
	and $b=false) do={ :put "$a $b"; } 
:if ($a = true \ # bad comment 
	and $b=false) do={ :put "$a $b"; }
# comment \
	continued - invalid (syntax error)
Whitespace between tokens

Whitespace can be used to separate tokens. Whitespace is necessary between two tokens only if their concatenation could be interpreted as a different token. Example:
{  
	:local a true; :local b false;
# whitespace is not required 
	:put (a&&b); 
# whitespace is required  
	:put (a and b); 
}

Whitespace characters are not allowed

    between '<parameter>='
    between 'from=' 'to=' 'step=' 'in=' 'do=' 'else='

Example:
#incorrect: 
:for i from = 1 to = 2 do = { :put $i } 
#correct syntax: 
:for i from=1 to=2 do={ :put $i } 
:for i from= 1 to= 2 do={ :put $i } 

#incorrect 
/ip route add gateway = 3.3.3.3 
#correct 
/ip route add gateway=3.3.3.3
Scopes

Variables can be used only in certain regions of the script called scopes. These regions determine the visibility of the variable. There are two types of scopes - global and local. A variable declared within a block is accessible only within that block and blocks enclosed by it, and only after the point of declaration.
Global scope

Global scope or root scope is the default scope of the script. It is created automatically and can not be turned off.
Previously set global variable can be used in scripts by declaring it without setting the value.
Local scope

User can define their own groups to block access to certain variables, these scopes are called local scopes. Each local scope is enclosed in curly braces ("{ }").
{  
	:local a 3;
	{  
		:local b 4;  
		:put ($a+$b); 
	} #line below will show variable b in light red color since it is not defined in scope  
	:put ($a+$b); 
}

In the code above variable, b has local scope and will not be accessible after a closing curly brace.
Each line written in the terminal is treated as local scope

So for example, the defined local variable will not be visible in the next command line and will generate a syntax error

[admin@MikroTik] > :local myVar a;
[admin@MikroTik] > :put $myVar
syntax error (line 1 column 7)

Do not define global variables inside local scopes.

Note that even variable can be defined as global, it will be available only from its scope unless it is not referenced to be visible outside of the scope.
{  
	:local a 3; 
	{  
		:global b 4; 
	}  
	:put ($a+$b); 
}

The code above will output 3, because outside of the scope b is not visible. 

The following code will fix the problem and will output 7:
{  
	:local a 3; 
	{  
		:global b 4; 
	}
	:global b;  
	:put ($a+$b); 
}


Keywords

The following words are keywords and cannot be used as variable and function names:

and       or       in

Delimiters

The following tokens serve as delimiters in the grammar:

()  []  {}  :   ;   $   / 

Data types

RouterOS scripting language has the following data types:
num (number)	- 64bit signed integer, possible hexadecimal input;
bool (boolean)	- values can bee true or false;
str (string)	- character sequence;
ip	- IP address;
ip-prefix	- IP prefix;
ip6	- IPv6 address
ip6-prefix	- IPv6 prefix
id (internal ID)	- hexadecimal value prefixed by '*' sign. Each menu item has an assigned unique number - internal ID;
time	- date and time value;
array	- sequence of values organized in an array;
nil	- default variable type if no value is assigned;
Constant Escape Sequences

Following escape sequences can be used to define certain special characters within a string:
\"	Insert double quote
\\	Insert backslash
\n	Insert newline
\r	Insert carriage return
\t	Insert horizontal tab
\$	Output $ character. Otherwise, $ is used to link the variable.
\?	Output ? character. Otherwise ? is used to print "help" in the console. Removed since v7.1rc2
\_	- space
\a	- BEL (0x07)
\b	- backspace (0x08)
\f	- form feed (0xFF)
\v	Insert vertical tab
\xx	A print character from hex value. Hex numbers should use capital letters.
Example

:put "\48\45\4C\4C\4F\r\nThis\r\nis\r\na\r\ntest";

which will show on the display
HELLO
This
is
a
test
Operators
Arithmetic Operators

Usual arithmetic operators are supported in the RouterOS scripting language
"+"	binary addition	:put (3+4);
"-"	binary subtraction	:put (1-6);
"*"	binary multiplication	:put (4*5);
"/"	binary division	:put (10 / 2); :put ((10)/2)
"%"	modulo operation	:put (5 % 3);
"-"	unary negation	{ :local a 1; :put (-a); }

Note: for the division to work you have to use braces or spaces around the dividend so it is not mistaken as an IP address
Relational Operators
"<"	less	:put (3<4);
">"	greater	:put (3>4);
"="	equal	:put (2=2);
"<="	less or equal	
">="	greater or equal	
"!="	not equal	

To negate an expression, you can use "expression=false". To print all interfaces that are not "ethernet", you can use expression negation like this:
/interface/print where (name~"ether")=false

Or to do the opposite, you can use "expression=true":
/interface/print where (name~"ether")=true
Logical Operators
“!”	logical NOT	:put (!true);
“&&”, “and”	logical AND	:put (true&&true)
“||”, “or”	logical OR	:put (true||false);
“in”	
	:put (1.1.1.1/32 in 1.0.0.0/8);
Bitwise Operators

Bitwise operators are working on number, IP, and IPv6 address data types.
“~”	bit inversion	:put (~0.0.0.0)
:put (~::ffff)
“|”	bitwise OR. Performs logical OR operation on each pair of corresponding bits. In each pair the result is “1” if one of the bits or both bits is “1”, otherwise the result is “0”.	:put (192.168.88.0|0.0.0.255)
:put (2001::1|::ffff)
“^”	bitwise XOR. The same as OR, but the result in each position is “1” if two bits are not equal, and “0” if the bits are equal.	:put (1.1.1.1^255.255.0.0)
:put (2001::ffff:1^::ffff:0)
“&”	bitwise AND. In each pair, the result is “1” if the first and second bit is “1”. Otherwise, the result is “0”.	:put (192.168.88.77&255.255.255.0)
:put (2001::1111&ffff::)
“<<”	left shift by a given amount of bits, not supported for IPv6 address data type	:put (192.168.88.77<<8)
“>>”	right shift by a given amount of bits, not supported for IPv6 address data type	:put (192.168.88.77>>24)

Calculate the subnet address from the given IP and CIDR Netmask using the "&" operator:
{ 
:local IP 192.168.88.77; 
:local CIDRnetmask 255.255.255.0; 
:put ($IP&$CIDRnetmask); 
}

Get the last 8 bits from the given IP addresses:
 :put (192.168.88.77&0.0.0.255);

Use the "|" operator and inverted CIDR mask to calculate the broadcast address:
{ 
:local IP 192.168.88.77; 
:local Network 192.168.88.0; 
:local CIDRnetmask 255.255.255.0; 
:local InvertedCIDR (~$CIDRnetmask); 
:put ($Network|$InvertedCIDR) 
}
Concatenation Operators
"."	concatenates two strings	:put ("concatenate" . " " . "string");
","	concatenates two arrays or adds an element to the array	:put ({1;2;3} , 5 );

It is possible to add variable values to strings without a concatenation operator:
:global myVar "world"; 

:put ("Hello " . $myVar); 
# next line does the same as above 
:put "Hello $myVar";

By using $[] and $() in the string it is possible to add expressions inside strings:
:local a 5; 
:local b 6; 
:put " 5x6 = $($a * $b)"; 

:put " We have $[ :len [/ip route find] ] routes";
Other Operators


“[]”	command substitution. Can contain only a single command line	:put [ :len "my test string"; ];
“()”	subexpression or grouping operator	:put ( "value is " . (4+5));
“$”	substitution operator	:global a 5; :put $a;
“~”	the binary operator that matches value against POSIX extended regular expression	Print all routes whose gateway ends with 202:
/ip route print where gateway~"^[0-9 \\.]*202\$"
“->”	Get an array element by key	

[admin@x86] >:global aaa {a=1;b=2}
[admin@x86] > :put ($aaa->"a")
1
[admin@x86] > :put ($aaa->"b")
2

Variables

The scripting language has two types of variables:

    global - accessible from all scripts created by the current user, defined by global keyword;
    local - accessible only within the current scope, defined by local keyword.

There can be undefined variables. When a variable is undefined, the parser will try to look for variables set, for example, by DHCP lease-script or Hotspot on-login

Every variable, except for built-in RouterOS variables, must be declared before usage by local or global keywords. Undefined variables will be marked as undefined and will result in a compilation error. Example:
# following code will result in compilation error, because myVar is used without declaration 
:set myVar "my value"; 
:put $myVar

Correct code:
:local myVar; 
:set myVar "my value"; 
:put $myVar;

The exception is when using variables set, for example, by DHCP lease-script
/system script 
add name=myLeaseScript policy=\ 
	ftp,reboot,read,write,policy,test,winbox,password,sniff,sensitive,api \ 
	source=":log info \$leaseActIP\r\ 
	\n:log info \$leaseActMAC\r\ 
	\n:log info \$leaseServerName\r\ 
	\n:log info \$leaseBound" 

/ip dhcp-server set myServer lease-script=myLeaseScript

Valid characters in variable names are letters and digits. If the variable name contains any other character, then the variable name should be put in double quotes. Example:
#valid variable name 
:local myVar; 
#invalid variable name 
:local my-var; 
#valid because double quoted 
:global "my-var";

If a variable is initially defined without value then the variable data type is set to nil, otherwise, a data type is determined automatically by the scripting engine. Sometimes conversion from one data type to another is required. It can be achieved using data conversion commands. Example:
#convert string to array 
:local myStr "1,2,3,4,5"; 
:put [:typeof $myStr]; 
:local myArr [:toarray $myStr]; 
:put [:typeof $myArr]

Variable names are case-sensitive.
:local myVar "hello" 
# following line will generate error, because variable myVAr is not defined 
:put $myVAr 
# correct code 
:put $myVar

Set command without value will un-define the variable (remove from environment, new in v6.2)
#remove variable from environment 
:global myVar "myValue" 
:set myVar;

Use quotes on the full variable name when the name of the variable contains operators. Example:
:local "my-Var";
:set "my-Var" "my value";
:put $"my-Var";
Reserved variable names

All built-in RouterOS properties are reserved variables. Variables that will be defined the same as the RouterOS built-in properties can cause errors. To avoid such errors, use custom designations.

For example, the following script will not work:
{ 
:local type "ether1"; 
/interface print where name=$type; 
}

But will work with different defined variables:
 { 
:local customname "ether1"; 
/interface print where name=$customname; 
}
Commands
Global commands

Every global command should start with the ":" token, otherwise, it will be treated as a variable.
/	
	go to the root menu	
..	
	go back by one menu level	
?	
	list all available menu commands and brief descriptions	
global	:global <var> [<value>]	define a global variable	:global myVar "something"; :put $myVar;
local	:local <var> [<value>]	define the local variable	{ :local myLocalVar "I am local"; :put $myVar; }
beep	:beep frequency=[num] length=[num]	beep built-in speaker	
convert	:convert from=[arg] to=[arg]	

Converts specified value from one format to another. By default uses an automatically parsed value, if the "from" format is not specified (for example, "001" becomes "1", "10.1" becomes "10.0.0.1", etc.).

from specifies the format of the value - base32, base64, byte-array, hex, num, raw, url.

to specifies the format of the output value - base32, base64, bit-array-lsb, bit-array-msb, byte-array, hex, num, raw, url.

transform to transform values - lc (transforms value to be in lowercases), uc (uppercases), lcfirst (first value to lowercase), ucfirst (first value to uppercase), crlf, ed25519-private-to-x25519-private, none, rot 13, x25519-private-to-x25519-public, ed25519-private-to-ed25519-public, ed25519-public-to-x25519-public, md5, reverse (reverses text), sha512.
	

:put [:convert 001 to=hex ]

31

:put [:convert [/ip dhcp-client/option/get hostname raw-value] from=hex to=raw ]

MikroTik

:put [convert transform=lc "AAA"]         

aaa
delay	:delay <time>	do nothing for a given period of time	
environment	:environment print <start>	print initialized variable information	:global myVar true; :environment print;
error	:error <output>	Generate console error and stop executing the script	
execute	:execute <expression>	

Execute the script in the background. The result can be written in the file by setting a "file" parameter or printed to the CLI by setting "as-string".

When using the "as-string" parameter executed script is blocked (not executed in the background).

Executed script can not be larger than 64kB
	
{
:local j [:execute {/interface print follow where [:log info ~Sname~]}];
:delay 10s;
:onerror e {/system script job remove $j}
}
find	:find <arg> <arg> <start>	return position of a substring or array element	:put [:find "abc" "a" -1];
grep	:grep script=[str] pattern=[expression] after=[num] before=[num] filename=[str]

	Command ":grep" executes "script" part of a command in terminal and provides just the output which matches "pattern". Additional options "after" and "before" allow to print out specific number of lines of script output which are available also after/before matched pattern. Results can be directly saved into a file with "filename" parameter.	

:grep script="/interface print" pattern="ether" after=1 before=1 filename=results.txt
jobname
	:jobname	return current script name	
Limit script execution to single instance
:if ([/system script job print count-only as-value where script=[:jobname] ] > 1) do={
  :error "script instance already running"
  }


len	:len <expression>	return string length or array element count	:put [:len "length=8"];
log	:log <topic> <message>	write a message to the system log. Available topics are "debug, error, info and warning"	:log info "Hello from script";
onerror	:onerror <var_name> in={<command>} do={<expression>}	

The command used to catch errors and get error details. The do={...} block is executed, when in={...} block has an error,  and error details are written in <var_name> variable. 

Parameter order is important. The "error" parameter must be set before "do" block, otherwise do block will not see the local variable. 


:onerror will return false (if there is no error) and true (if there is an error) unless otherwise specified (with commands such as :return or :error), so it can be used in :if condition statement scripts.
	 :onerror errorName in={ :error "failure" } do={ :put "Critical $errorName" }
parse	:parse <expression>	parse the string and return parsed console commands. Can be used as a function.	:global myFunc [:parse ":put hello!"];
$myFunc;
pick	:pick <var> <start> [<end>]	

return range of elements or substring. If the count is not specified, will return only one element from an array.

    var - value to pick elements from
    start - element to start picking from (the first element index is 0)
    end - terminating index (element at this index is not included)

	


[admin@MikroTik] > :put [:pick "abcde" 1 3]
bc


put	:put <expression>	put the supplied argument into the console	:put "Hello world"
range	:range <var> <var>	creates an array from the specified range	

:put [:range 2 8]
2;3;4;5;6;7;8

resolve	:resolve <arg> [<domain-name>][<server>][<server-port>][<type>]	

return the IP address of the given DNS name

    domain-name - DNS name that needs to be resolved;
    server - specific server that will be used to resolve DNS name (returned results will not be cached);
    server-port - server port;
    type - any/any6/ipv4/ipv6:
        any - first tries to resolve ipv4, if fails tries ipv6;
        any6 - first tries to resolve ipv6, if fails tries ipv4;
        ipv4 - tries to resolve only ipv4;
        ipv6 - tries to resolve only ipv6

	

:put [:resolve "www.mikrotik.com"];

:put [:resolve domain-name="www.mikrotik.com"];

:put [:resolve domain-name="www.mikrotik.com" server=192.168.88.1 port=53];

:put [:resolve domain-name="www.mikrotik.com" type=ipv6];
retry	

:onerror e {:retry command=<expr> delay=[num] max=[num]} do={<expr>}
	Try to execute the given command "max" amount of times with a given "delay" in seconds between tries. On failure, execute the command in the do={} block.	
:onerror e {:retry command={abc} delay=1 max=2} do={:put "got error"}
got error
typeof	:typeof <var>	the return data type of variable	:put [:typeof 4];
rndnum	:rndnum from=[num] to=[num]	random number generator	:put [:rndnum from=1 to=99];
rndstr	:rndstr from=[str] length=[num]	

Random string generator.

from specifies characters to construct the string from and defaults to all ASCII letters and numerals.
length specifies the length of the string to create and defaults to 16.
	

:put [:rndstr from="abcdef%^&" length=33];



set	:set <var> [<value>]	assign value to a declared variable.	:global a; :set a true;
serialize	:serialize [<value>] to=[arg]	

Serialize specified value/array to JSON or dsv (delimiter separated values) format.

value specifues which values to process.

to specifies the format - json, dsv

delimiter sets the "separator".

order specifies the order for variables.

options specifies additional options:

    json.pretty  - makes the JSON output more visually appealing;

    json.no-string-conversion - prevents implict conversions from console string type to json number type;
    dsv.wrap-strings - wraps string values inside quatation marks;
    dsv.ignore-size - if array values have different sizes, e.g. a=(1,2);b=(3,4);c=(5,6,7), this option will work around array size mismatch error and set "empty" values in those slots.
    dsv.remap - merges array of dictionaries into a single dictionary (useful when working with "print as-value")

file-name enables the option to generate command's output into a file (available for download in the "/files" section).
	


:put [:serialize value=a,b,c to=json]                 
["a","b","c"]

:local test {a=(1,2,3);b=(4,5,6);c=(7,"text",9)}; :put [ :serialize to=dsv delimiter=";" value=$test order=("c","a","b") ]     
c;a;b
7;1;4
text;2;5
9;3;6

:global var ({ "string"="1234"; "number"=1234 });:put [ :serialize to=json value=$var ]
{"number":1234,"string":1234.000000}
:put [ :serialize to=json value=$var options=json.no-string-conversion  ]
{"number":1234,"string":"1234"}

:put [:serialize to=dsv options=dsv.remap delimiter="#" [/ip/address/print as-value]]  
.id#address#comment#interface#network
*1#192.168.88.1/24#defconf#bridge#192.168.88.0
*2#192.168.69.190/24##ether1#192.168.69.0


deserialize	:deserialize [<value>] from=[arg]	

Deserialize specified value/array from JSON or dsv (delimiter separated values) format.

from specifies the format - json, dsv

delimiter sets the "separator".

options specifies additional options:

    dsv.plain - deserializes every line as an array (input does not have a header or column names);
    dsv.array - expects a header (column names) and will return an array of dictionaries, where values are mapped to column names provided in the header.
    json.no-string-conversion - prevents implicit conversions from json string type to console values (number, ip, etc.).

	
:put [:deserialize from=json value="[\"a\",\"b\",\"c\"]"]
a;b;c

:put ([ :deserialize from=dsv delimiter=";" value="a;b;c\n1;findme;3" options=dsv.plain ]->1->1) 
findme

:put ([ :deserialize from=dsv delimiter=";" value="a;b;c\n1;findme;3" options=dsv.plain ]->0->1)   
b

:put ([:deserialize from=dsv "a;b;c\n1;2;3\n4;5;6" delimiter=";" options=dsv.array]->1->"b") 
5

:put ([:deserialize from=dsv "a;b;c\n1;2;3\n4;5;6" delimiter=";" options=dsv.array]->0->"c")    
3

:put [typeof ([:deserialize "{ \"str\": \"123\" }" from=json options=json.no-string-conversion]->"str")]
str

:deserialize [/file/get file.json contents] from=json
time	:time <expression>	return interval of time needed to execute the command	:put [:time {:for i from=1 to=10 do={ :delay 100ms }}];
timestamp	:timestamp	returns the time since epoch, where epoch is January 1, 1970 (Thursday), not counting leap seconds	
[admin@MikroTik] > :put [:timestamp]
2735w21:41:43.481891543
or
[admin@MikroTik] > :put [:timestamp]
2735w1d21:41:43.481891543
with the day offset
toarray	:toarray <var>	convert a variable to the array	
tobool	:tobool <var>	convert a variable to boolean	
toid	:toid <var>	convert a variable to internal ID	
toip	:toip <var>	convert a variable to IP address	
toip6	:toip6 <var>	convert a variable to IPv6 address	
tonum	:tonum <var>	convert a variable to an integer	
tostr	:tostr <var>	convert a variable to a string	
totime	:totime <var>	convert a variable to time	
tonsec	:tonsec <var>	convert time to nanoseconds	

:put [:tonsec value=10:00]               
36000000000000

tocrlf	:tocrlf <var>	converts line endings to CRLF	

:put [:tocrlf  "AAA\r\nBBB\r\nCCC" ]                                                                                                             
AAA                                              
BBB
CCC

tolf	:tolf <var>	converts line endings to LF	

:put [:tolf  "AAA\nBBB\nCCC" ]      
AAA
   BBB
      CCC

nothing	:nothing	return a value of nothing	

:if ([:nothing] = 0) do={:put true} else={:put false}
false
:if ([:nothing] > 0) do={:put true} else={:put false} 
false
:if ([:nothing] < 0) do={:put true} else={:put false} 
true

Menu specific commands
Common commands

The following commands are available from most sub-menus:
add	add <param>=<value>..<param>=<value>	add new item
remove	remove <id>	remove selected item
enable	enable <id>	enable selected item
disable	disable <id>	disable selected item
set	set <id> <param>=<value>..<param>=<value>	change selected items parameter, more than one parameter can be specified at the time. The parameter can be unset by specifying '!' before the parameter.

Example:
/ip firewall filter add chain=blah action=accept protocol=tcp port=123 nth=4,2
print
set 0 !port chain=blah2 !nth protocol=udp
get	get <id> <param>=<value>	get the selected item's parameter value
print	print <param><param>=[<value>]	print menu items. Output depends on the print parameters specified. The most common print parameters are described here
export	export [file=<value>]	export configuration from the current menu and its sub-menus (if present). If the file parameter is specified output will be written to the file with the extension '.rsc', otherwise the output will be printed to the console. Exported commands can be imported by import command
edit	edit <id> <param>	edit selected items property in the built-in text editor
find	find <expression>	Returns list of internal numbers for items that are matched by given expression. For example:  :put [/interface find name~"ether"]
import

The import command is available from the root menu and is used to import configuration from files created by an export command or written manually by hand.

Starting from 7.16.x version, its possible to catch syntax errors:
[admin@admin] > do { import test.rsc } on-error={ :put "Failure" }  
Failure

New parameter onerror can be used:
[admin@admin] > onerror e in={ import test.rsc } do={ :put "Failure - $e" }       
Failure - Script Error: bad command name this (line 1 column 1)

In addition, the import command has new options in verbose mode - the dry-run parameter is specially designed for debugging and can find multiple errors without changing the configuration.
[admin@admin] > import test.rsc verbose=yes dry-run 
#line 1
this
bad command name this (line 1 column 1)
...
Script Error: found 5 error(s) in import file
print parameters

Several parameters are available for print command:
append	
	
as-value	print output as an array of parameters and its values	:put [/ip address print as-value]
brief	print brief description	
detail	print detailed description, the output is not as readable as brief output but may be useful to view all parameters	
count-only	print only count of menu items	
file	print output to a file	
follow	print all current entries and track new entries until ctrl-c is pressed, very useful when viewing log entries	/log print follow
follow-only	print and track only new entries until ctrl-c is pressed, very useful when viewing log entries	/log print follow-only
from	print parameters only from specified item	/user print from=admin
interval	continuously print output in a selected time interval, useful to track down changes where follow is not acceptable	/interface print interval=2
terse	show details in a compact and machine-friendly format	
value-list	show values single per line (good for parsing purposes)	
without-paging	If the output does not fit in the console screen then do not stop, print all information in one piece	
where	expressions followed by where parameters can be used to filter outmatched entries	

/ip route print where interface="ether1"
about	returns entries that have the "about" parameter, such as "managed by CAPsMAN "information or warnings	

/interface wifi print where about

More than one parameter can be specified at a time, for example, /ip route print count-only interval=1 where interface="ether1"
Loops and conditional statements
Loops
do..while	:do { <commands> } while=( <conditions> ); :while ( <conditions> ) do={ <commands> };	execute commands until a given condition is met.
for	:for <var> from=<int> to=<int> step=<int> do={ <commands> }	execute commands over a given number of iterations
foreach	:foreach <var> in=<array> do={ <commands> };	execute commands for each element in a list
Conditional statement
if	:if (<condition>) do={<commands>} else={<commands>}	If a given condition is true then execute commands in the do block, otherwise execute commands in the else block if specified.

Example:
{  
	:local myBool true;  
	:if ($myBool = false) do={ :put "value is false" } else={ :put "value is true" } 
}
Functions

Scripting language does not allow you to create functions directly, however, you could use :parse command as a workaround.

Starting from v6.2 new syntax is added to easier define such functions and even pass parameters. It is also possible to return function value with :return command.

See examples below:
#define function and run it
:global myFunc do={:put "hello from function"}
$myFunc

output:
hello from function

#pass arguments to the function
:global myFunc do={:put "arg a=$a"; :put "arg '1'=$1"} 
$myFunc a="this is arg a value" "this is arg1 value"

output:
arg a=this is arg a value
arg '1'=this is arg1 value

Notice that there are two ways how to pass arguments:

    pass arg with a specific name ("a" in our example)
    pass value without arg name, in such case arg "1", "2" .. "n" is used.

Return example
:global myFunc do={ :return ($a + $b)} 
:put [$myFunc a=6 b=2] 

output: 
8

You can even clone an existing script from the script environment and use it as a function.
#add script
/system script add name=myScript source=":put \"Hello $myVar !\""

:global myFunc [:parse [/system script get myScript source]]
$myFunc myVar=world

output:
Hello world !
If the function contains a defined global variable that names match the name of the passed parameter, then the globally defined variable is ignored, for compatibility with scripts written for older versions. This feature can change in future versions. Avoid using parameters with the same name as global variables.

For example:
:global my2 "123" 

:global myFunc do={ :global my2; :put $my2; :set my2 "lala"; :put $my2 } 
$myFunc my2=1234 
:put "global value $my2"

The output will be:

1234
lala
global value 123

Nested function example

Note: to call another function its name needs to be declared (the same as for variables)
:global funcA do={ :return 5 } 
:global funcB do={  
	:global funcA;  
	:return ([$funcA] + 4) 
} 
:put [$funcB] 

Output: 
9
Catch run-time errors

Starting from v6.2 scripting has the ability to catch run-time errors.

For example, the [code]:reslove[/code] command if failed will throw an error and break the script.

[admin@MikroTik] > { :put [:resolve www.example.com]; :put "lala";}
failure: dns name does not exist

Now we want to catch this error and proceed with our script:
:onerror e {:put [:resolve www.example.com]} do={:put "resolver failed"}
:put "lalala"

output: 

resolver failed 
lala
Operations with Arrays

Warning: Key name in the array contains any character other than a lowercase character, it should be put in quotes

For example:
[admin@ce0] > {:local a { "aX"=1; ay=2 }; :put ($a->"aX")} 
1

Loop through keys and values

"foreach" command can be used to loop through keys and elements:
[admin@ce0] > :foreach k,v in={2; "aX"=1; y=2; 5} do={:put ("$k=$v")} 

0=2 
1=5 
aX=1 
y=2

If the "foreach" command is used with one argument, then the element value will be returned:
[admin@ce0] > :foreach v in={2; "aX"=1; y=2; 5} do={:put ("$v")} 

2 
5 
1 
2

Note: If the array element has a key then these elements are sorted in alphabetical order, elements without keys are moved before elements with keys and their order is not changed (see example above).

Change the value of a single array element

[admin@MikroTik] > :global a {x=1; y=2}
[admin@MikroTik] > :set ($a->"x") 5 
[admin@MikroTik] > :environment print 
a={x=5; y=2}

Script repository

Sub-menu level: /system script

Contains all user-created scripts. Scripts can be executed in several different ways:

    on event - scripts are executed automatically on some facility events ( scheduler, netwatch, VRRP)
    by another script - running script within the script is allowed
    manually - from console executing a run command or in winbox


Only scripts (including schedulers, netwatch, etc) with equal or higher permission rights can execute other scripts.


When executing script from GUI or CLI, user permissions are used. To run a script with script permissions, a script must be executed from CLI with additional "use-script-permissions" parameter.


comment (string; Default: )	Descriptive comment for the script
dont-require-permissions (yes | no; Default: no)	Bypass permissions check when the script is being executed, useful when scripts are being executed from services that have limited permissions, such as Netwatch
name (string; Default: "Script[num]")	name of the script
policy (string; Default: ftp,reboot,read,write,policy,test,password,sniff,sensitive,romon)	list of applicable policies:

    ftp - can log on remotely via FTP and send and retrieve files from the router
    password - change passwords
    policy - manage user policies, add and remove user
    read - can retrieve the configuration
    reboot - can reboot the router
    sensitive - allows changing "hide sensitive" parameter
    sniff - can run sniffer, torch, etc
    test - can run ping, traceroute, bandwidth test
    write - can change the configuration

Read more detailed policy descriptions here
source (string;)	Script source code

Read-only status properties:
last-started (date)	Date and time when the script was last invoked.
owner (string)	The user who created the script
run-count (integer)	Counter that counts how many times the script has been executed

Menu specific commands
run (run [id|name])	

Execute the specified script by ID or name using user permissions.
use-script-permissions	

Additional parameter to execute script using script permissions.
Environment

Sub-menu level:

    /system script environment
    /environment

Contains all user-defined variables and their assigned values.

[admin@MikroTik] > :global example;
[admin@MikroTik] > :set example 123
[admin@MikroTik] > /environment print  
"example"=123


Read-only status properties:
name (string)	Variable name
user (string)	The user who defined variable
value ()	The value assigned to a variable
Job

Sub-menu level: /system script job

Contains a list of all currently running scripts.
Read-only status properties:
owner (string)	The user who is running the script
policy (array)	List of all policies applied to the script
started (date)	Local date and time when the script was started
See also

    Scripting Examples
    Manual: Scripting Tips and Tricks


Videos on Scripting

Scripting pt1

Scripting pt2

Scripting: Data Types

Scripting: Arrays


