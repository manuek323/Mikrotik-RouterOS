

    Creado por Usuario desconocido (emils), actualizado por última vez por GG el feb 09, 2024 14 min de lectura

In This Section:

        IP Addressing
        IPv6 Neighbor Discovery
        IP Pools
        IP Routing
        IP Settings


    Networking Models
        OSI Model
        TCP/IP Model
    Ethernet
    IP Networking
    ARP and Tying It All Together
        ARP Modes
            Enabled
            Disabled
            Reply Only
            Proxy ARP
                Local Proxy ARP
    TCP/IP
        TCP Session Establishment and Termination
            Connection establishment process
            Connection termination
        TCP Segments transmission (windowing)

Networking Models

Computer networks consist of many different components and protocols working together. To understand the concept of how node to node communication happens, let's get familiar to the OSI model and TCP/IP model. Both models help to visualize how communication between nodes is happening.
OSI Model

The Open Systems Interconnection (OSI) model is a 7-layer model that today is used as a teaching tool. The OSI model was originally conceived as a standard architecture for building network systems, but in real-world networks are much less defined than the OSI model suggests.


    Layer 7 (Application) - a protocol that defines the communication between the server and the client, for example, HTTP protocol. If the web browser wants to download an image, the protocol will organize and execute the request;
    Layer 6 (Presentation) - ensures data is received in a usable format. Encryption is done here (but in reality it may not be true, for example, IPSec);
    Layer 5 (Session) - responsible for setting up, managing and closing sessions between client and server;
    Layer 4 (Transport) - transport layers primary responsibility is assembly and reassembly, a data stream is divided into chunks (segments), assigned sequence numbers and encapsulated into protocol header (TCP, UDP, etc.);
    Layer 3 (Network) - responsible for logical device addressing, data is encapsulated within an IP header and now called "packet";
    Layer 2 (Data link) - Data is encapsulated within a custom header, either 802.3 (Ethernet) or 802.11 (wireless) and is called "frame", handles flow control;
    Layer 1 (Physical) - Communication media that sends and receives bits, electric signaling, and hardware interface;

TCP/IP Model

This model has the same purpose as the OSI model but fits better into modern network troubleshooting. Comparing to the OSI model, TCP/IP is a 4-layer model:

    Application layer (4) - includes application, presentation and session layers of the OSI model, which significantly simplifies network troubleshooting;
    Transport layer (3) - same as a transport layer in the OSI model (TCP, UDP protocols);
    Internet layer (2) - does the same as Network layer in the OSI model (include ARP, IP protocols);
    Link layer (1) - also called the Network Access layer. Includes both Layer1 and 2 of the OSI model, therefore its primary concern is physical data exchange between network nodes;



TCP/IP	OSI Model	Protocols
Application Layer	Application Layer	DNS, DHCP,HTTP,SSH etc.
Presentation Layer	JPEG,MPEG,PICT etc.
Session Layer	PAP, SCP, ZIP etc.
Transport Layer	Transport Layer	TCP, UDP
Internet Layer	Network Layer	ICMP, IGMP, IPv4, IPv6, IPSec
Link Layer	Data Link Layer	ARP, CDP, MPLS, PPP etc.
Physical Layer	Bluetooth, Ethernet, Wi-Fi etc.




Ethernet

The most commonly used link layer protocol (OSI Layer2) in computer networks is the Ethernet protocol. In order to communicate, each node has a unique assigned address, called MAC (Media Access Control address) sometimes it is also called an Ethernet address.

It is 48-bit long and typically fixed by the manufacturer (cannot be changed), but in recent years customization of MAC addresses is widely used, RouterOS also allows to set custom MAC address.

Most commonly used MAC format is 6 hexadecimal numbers separated by colons (D4:CA:6D:01:22:96)

RouterOS shows MAC address in a configuration for all Ethernet-like interfaces (Wireless, 60G, VPLS, etc.)
[admin@rack1_b32_CCR1036] /interface ethernet> print 
Flags: X - disabled, R - running, S - slave 
 #    NAME                  MTU MAC-ADDRESS       ARP             SWITCH               
 0 R  ether1               1500 D4:CA:6D:01:22:96 enabled        
 1 R  ether2               1500 D4:CA:6D:01:22:97 enabled        
 2 R  ether3               1500 D4:CA:6D:01:22:98 enabled        
 3    ether4               1500 D4:CA:6D:01:22:99 enabled        
 4    ether5               1500 D4:CA:6D:01:22:9A enabled        
 5    ether6               1500 D4:CA:6D:01:22:9B enabled        
 6    ether7               1500 D4:CA:6D:01:22:9C enabled        
 7 R  ether8               1500 D4:CA:6D:01:22:9D enabled        
 8    sfp-sfpplus1         1500 D4:CA:6D:01:22:94 enabled        
 9    sfp-sfpplus2         1500 D4:CA:6D:01:22:95 enabled 


There are three types of addresses:

    Unicast address is sent to all nodes within the collision domain, which typically is Ethernet cable between two nodes or in case of wireless all receivers that can detect wireless signals. Only remote node with matching MAC address will accept the frame (unless the promiscuous mode is enabled)

    One of the special addresses is broadcast address (FF:FF:FF:FF:FF:FF), a broadcast frame is accepted and forwarded over Layer2 network by all nodes

    Another special address is multicast. Frames with multicast addresses are received by all nodes configured to receive frames with this address.


IP Networking

Ethernet protocol is sufficient to get data between two nodes on an Ethernet network, but it is not used on its own. For Internet/Networking layer (OSI Layer 3) IP (Internet Protocol) is used to identify hosts with unique logical addresses.

Most of the current networks use IPv4 addresses, which are 32bit address written in dotted-decimal notation (192.168.88.1)

There can be multiple logical networks and to identify which network IP address belongs to, the netmask is used. Netmask typically is specified as a number of bits used to identify a logical network. The format can also be in decimal notation, for example, the 24-bit netmask can be written as 255.255.255.0

Let's take a closer look at 192.168.3.24/24:
11000000 10101000 00000011 00011000 => 192.168.3.24
11111111 11111111 11111111 00000000 => /24 or 255.255.255.0


As can be seen from the illustration above high 24 bits are masked, leaving us with a range of 0-255.

From this range, the first address is used to identify the network (in our example network address would be 192.168.3.0) and the last one is used for network broadcast (192.168.3.255). That leaves us with a range from 1 to 254 for host identification which is called unicast addresses.

The same as in Ethernet protocol there can be also special addresses:

    broadcast - address to send data to all possible destinations ("all-hosts broadcast"), which permits the sender to send the data only once, and all receivers receive a copy of it. In the IPv4 protocol, the address 255.255.255.255 is used for local broadcast. In addition, a directed (limited) broadcast can be made to network broadcast address;
    multicast - address associated with a group of interested receivers. In IPv4, addresses 224.0.0.0 through 239.255.255.255 are designated as multicast addresses. The sender sends a single datagram from its unicast address to the multicast group address and the intermediary routers take care of making copies and sending them to all receivers that have joined the corresponding multicast group;

In case of logical IP network, unicast, broadcast and multicast visualization would look a bit different

There are also address ranges reserved for a special purpose, for example, private address range, that should be used only in local networks and typically are dropped when forwarded to the internet:

    10.0.0.0/8 - start: 10.0.0.0; end: 10.255.255.255
    172.16.0.0/12 - start: 172.16.0.0; end:172.31.255.255
    192.168.0.0/16 - start: 192.168.0.0; end: 192.168.255.255

ARP and Tying It All Together

Even though IP packets are addressed using IP addresses, hardware addresses must be used to actually transport data from one host to another.

This brings us to Address Resolution Protocol (ARP) which is used for mapping the IP address of the host to the hardware address (MAC). ARP protocol is referenced in RFC 826.

Each network device has a table of currently used ARP entries. Normally the table is built dynamically, but to increase network security, it can be partially or completely built statically by means of adding static entries.

Address Resolution Protocol is a thing of the past. IPv6 completely eliminates use of the ARP.


When a host on the local area network wants to send an IP packet to another host in this network, it must look for the Ethernet MAC address of destination host in its ARP cache. If the destination host’s MAC address is not in the ARP table, then the ARP request is sent to find the device with a corresponding IP address. ARP sends a broadcast request message to all devices on the LAN by asking the devices with the specified IP address to reply with its MAC address. A device that recognizes the IP address as its own returns ARP response with its own MAC address:

Let's make a simple configuration and take a closer look at processes when Host A tries to ping Host C.

At first, we add IP addresses on Host A:
/ip address add address=10.155.101.225 interface=ether1

Host B:
/ip address add address=10.155.101.221 interface=ether1

Host C:
/ip address add address=10.155.101.217 interface=ether1

Now, let's run a packet sniffer that saves packet dump to the file and run the ping command on Host A:
/tool sniffer
  set file-name=arp.pcap filter-interface=ether1
  start 
/ping 10.155.101.217 count=1
  stop

Now you can download arp.pcap file from the router and open it in Wireshark for analyzing:


    Host A sends ARP message asking who has "10.155.101.217"
    Host C responds that 10.155.101.217 can be reached at 08:00:27:3C:79:3A MAC address
    Both Host A and Host C now have updated their ARP tables and now ICMP (ping) packets can be sent

If we look at ARP tables of both host we can see relevant entries, in RouterOS ARP table can be viewed by running command: /ip arp print
[admin@host_a] /ip arp> print 
Flags: X - disabled, I - invalid, H - DHCP, D - dynamic, P - published, 
C - complete 
 #    ADDRESS         MAC-ADDRESS       INTERFACE                          
 0 DC 10.155.101.217  08:00:27:3C:79:3A ether1  

 [admin@host_b] /ip arp> print 
Flags: X - disabled, I - invalid, H - DHCP, D - dynamic, P - published, 
C - complete 
 #    ADDRESS         MAC-ADDRESS       INTERFACE                     
 0 DC 10.155.101.225  08:00:27:85:69:B5 ether1  
ARP Modes

Now the example above demonstrated default behavior, where ARP is enabled on interfaces, but there might be scenarios where different ARP behavior is necessary. RouterOS allows configuring different ARP modes for interfaces that support ARP.
Enabled

ARPs will be discovered automatically and new dynamic entries will be added to the ARP table. This is a default mode for interfaces in RouterOS and illustrated in the example above.
Disabled

If the ARP feature is turned off on the interface, i.e., arp=disabled is used, ARP requests from clients are not answered by the router. Therefore, static ARP entry should be added to the clients as well. For example, the router's IP and MAC addresses should be added:
[admin@host_a] > /ip arp add mac-address=08:00:27:3C:79:3A address=10.155.101.217 interface=ether1
Reply Only

If the ARP property is set to reply-only on the interface, then the router only replies to ARP requests. Neighbour MAC addresses will be resolved using /ip arp statically, but there will be no need to add the router's MAC address to other hosts' ARP tables like in cases where ARP is disabled.
Proxy ARP

A router with properly configured proxy ARP feature acts as a transparent ARP proxy between directly connected networks. This behavior can be useful, for example, if you want to assign dial-in (PPP, PPPoE, PPTP) clients IP addresses from the same address space as used on the connected LAN.

Let's look at the example setup from the image above. Host A (172.16.1.2) on Subnet A wants to send packets to Host D (172.16.2.3) on Subnet B. Host A has a /16 subnet mask which means that Host A believes that it is directly connected to all 172.16.0.0/16 network (the same LAN). Since the Host A believes that is directly connected it sends an ARP request to the destination to clarify the MAC address of Host D. (in the case when Host A finds that destination IP address is not from the same subnet it sends a packet to the default gateway.). Host A broadcasts an ARP request on Subnet A.

Info from packet analyzer software:
 No.     Time   Source             Destination       Protocol  Info

 12   5.133205  00:1b:38:24:fc:13  ff:ff:ff:ff:ff:ff  ARP      Who has 173.16.2.3?  Tell 173.16.1.2


Packet details:

Ethernet II, Src: (00:1b:38:24:fc:13), Dst: (ff:ff:ff:ff:ff:ff)
    Destination: Broadcast (ff:ff:ff:ff:ff:ff)
    Source: (00:1b:38:24:fc:13)
    Type: ARP (0x0806)
Address Resolution Protocol (request)
    Hardware type: Ethernet (0x0001)
    Protocol type: IP (0x0800)
    Hardware size: 6
    Protocol size: 4
    Opcode: request (0x0001)
    [Is gratuitous: False]
    Sender MAC address: 00:1b:38:24:fc:13
    Sender IP address: 173.16.1.2
    Target MAC address: 00:00:00:00:00:00
    Target IP address: 173.16.2.3


With this ARP request, Host A (172.16.1.2) is asking Host D (172.16.2.3) to send its MAC address. The ARP request packet is then encapsulated in an Ethernet frame with the MAC address of Host A as the source address and a broadcast (FF:FF:FF:FF:FF:FF) as the destination address. Layer 2 broadcast means that frame will be sent to all hosts in the same layer 2 broadcast domain which includes the ether0 interface of the router, but does not reach Host D, because router by default does not forward layer 2 broadcasts.

Since the router knows that the target address (172.16.2.3) is on another subnet but it can reach Host D, it replies with its own MAC address to Host A.
No.     Time   Source            Destination         Protocol   Info

13   5.133378  00:0c:42:52:2e:cf  00:1b:38:24:fc:13   ARP        172.16.2.3 is at 00:0c:42:52:2e:cf

Packet details:

Ethernet II, Src: 00:0c:42:52:2e:cf, Dst: 00:1b:38:24:fc:13
   Destination: 00:1b:38:24:fc:13
   Source: 00:0c:42:52:2e:cf
   Type: ARP (0x0806)
Address Resolution Protocol (reply)
   Hardware type: Ethernet (0x0001)
   Protocol type: IP (0x0800)
   Hardware size: 6
   Protocol size: 4
   Opcode: reply (0x0002)
   [Is gratuitous: False]
   Sender MAC address: 00:0c:42:52:2e:cf
   Sender IP address: 172.16.1.254
   Target MAC address: 00:1b:38:24:fc:13
   Target IP address: 172.16.1.2


This is the Proxy ARP reply that the router sends to Host A. Router sends back unicast proxy ARP reply with its own MAC address as the source address and the MAC address of Host A as the destination address, by saying "send these packets to me, and I'll get it to where it needs to go."

When Host A receives ARP response it updates its ARP table, as shown:
C:\Users\And>arp -a
Interface: 173.16.2.1 --- 0x8
  Internet Address      Physical Address      Type
  173.16.1.254          00-0c-42-52-2e-cf    dynamic
  173.16.2.3            00-0c-42-52-2e-cf    dynamic
  173.16.2.2            00-0c-42-52-2e-cf    dynamic


After MAC table update, Host A forwards all the packets intended for Host D (172.16.2.3) directly to router interface ether0 (00:0c:42:52:2e:cf) and the router forwards packets to Host D. The ARP cache on the hosts in Subnet A is populated with the MAC address of the router for all the hosts on Subnet B. Hence, all packets destined to Subnet B are sent to the router. The router forwards those packets to the hosts in Subnet B.

Multiple IP addresses by the host are mapped to a single MAC address (the MAC address of this router) when proxy ARP is used.

Proxy ARP can be enabled on each interface individually with command arp=proxy-arp:
 [admin@MikroTik] /interface ethernet> set 1 arp=proxy-arp
 [admin@MikroTik] /interface ethernet> print
 Flags: X - disabled, R - running
   #    NAME                 MTU   MAC-ADDRESS         ARP
   0  R ether1              1500  00:30:4F:0B:7B:C1 enabled
   1  R ether2              1500  00:30:4F:06:62:12 proxy-arp
 [admin@MikroTik] interface ethernet>


Local Proxy ARP

if the arp property is set to local-proxy-arp on an interface, then the router performs proxy ARP to/from this interface only. I.e. for traffic that comes in and goes out of the same interface. In a normal LAN, the default behavior is for two network hosts to communicate directly with each other, without involving the router.

This is done to support (Ethernet) switch features, like RFC 3069, where the individual ports are NOT allowed to communicate with each other, but they are allowed to talk to the upstream router. As described in RFC 3069, it is possible to allow these hosts to communicate through the upstream router by proxy_arp'ing. Don't need to be used together with proxy_arp. This technology is known by different names:

    In RFC 3069 it is called VLAN Aggregation;
    Cisco and Allied Telesis call it Private VLAN;
    Hewlett-Packard calls it Source-Port filtering or port-isolation;
    Ericsson calls it MAC-Forced Forwarding (RFC Draft).

TCP/IP
TCP Session Establishment and Termination

TCP is a connection-oriented protocol. The difference between a connection-oriented protocol and a connection-less protocol is that a connection-oriented protocol does not send any data until a proper connection is established.

TCP uses a three-way handshake whenever the transmitting device tries to establish a connection to the remote node. As a result end-to-end virtual (logical) circuit is created where flow control and acknowledgment for reliable delivery are used. TCP has several message types used in connection establishment and termination process.
Connection establishment process

    The host A who needs to initialize a connection sends out an SYN (Synchronize) packet with a proposed initial sequence number to the destination "host B";
    When the host B receives an SYN message, it returns a packet with both SYN and ACK flags set in the TCP header (SYN-ACK);
    When the host A receives the SYN-ACK, it sends back the ACK (Acknowledgment) packet;
    Host B receives ACK and at this stage, the connection is ESTABLISHED;

Connection-oriented protocol services are often sending acknowledgments (ACKs) after successful delivery. After the packet with data is transmitted, the sender waits for acknowledgment from the receiver. If time expires and the sender did not receive ACK, a packet is retransmitted.
Connection termination

When the data transmission is complete and the host wants to terminate the connection, the termination process is initiated. Unlike TCP Connection establishment, which uses a three-way handshake, connection termination uses four-way massages. A connection is terminated when both sides have finished the shutdown procedure by sending a FIN (finish) and receiving an ACK (Acknowledgment).

    The host A, who needs to terminate the connection, sends a special message with the FIN flag, indicating that it has finished sending the data;
    The host B, who receives the FIN segment, does not terminate the connection but enters into a "passive close" (CLOSE_WAIT) state and sends the ACK for the FIN back to the host A. If host B does not have any data to transmit to the host A it will also send the FIN message. Now the host B enters into LAST_ACK state. At this point host B will no longer accept data from host A, but can continue to transmit data to host A.
    When the host A receives the last FIN from the host B, it enters into a (TIME_WAIT) state, and sends an ACK back to the host B;
    Host B gets the ACK from the host A and connection is terminated;

TCP Segments transmission (windowing)

Now that we know how the TCP connection is established we need to understand how data transmission is managed and maintained. In TCP/IP networks transmission between hosts is handled by TCP protocol.

Let’s think about what happens when data-grams are sent out faster than the receiving device can process. The receiver stores them in memory called a buffer. But since buffer space is not unlimited, when its capacity is exceeded receiver starts to drop the frames. All dropped frames must be re-transmitted again which is the reason for low transmission performance.

To address this problem, TCP uses a flow control protocol. The window mechanism is used to control the flow of the data. When a connection is established, the receiver specifies the window field in each TCP frame. Window size represents the amount of received data that the receiver is willing to store in the buffer. Window size (in bytes) is sent together with acknowledgments to the sender. So the size of the window controls how much information can be transmitted from one host to another without receiving an acknowledgment. The sender will send only the amount of bytes specified in window size and then will wait for acknowledgments with updated window size.

If the receiving application can process data as quickly as it arrives from the sender, then the receiver will send a positive window advertisement (increase the size of the window) with each acknowledgment. It works until the sender becomes faster than the receiver and incoming data will eventually fill the receiver's buffer, causing the receiver to advertise acknowledgment with a zero window. A sender that receives a zero window advertisement must stop transmit until it receives a positive window.  Let's take a look at the illustrated windowing process:





    The "host A" starts to transmit with a window size of 1000, one 1000byte frame is transmitted;
    Receiver "host B" returns ACK with window size to increase to 2000;
    The host A receives ACK and transmits two frames (1000 bytes each);
    After that, the receiver advertises an initial window size to 3000. Now sender transmits three frames and waits for an acknowledgement;
    The first three segments fill the receiver's buffer faster than the receiving application can process the data, so the advertised window size reaches zero indicating that it is necessary to wait before further transmission is possible;
    The size of the window and how fast to increase or decrease the window size is available in various TCP congestion avoidance algorithms such as Reno, Vegas, Tahoe, etc;
	
	

    Creado por Māris B., actualizado por última vez por Mārtiņš S. el ene 22, 2025 12 min de lectura

    Overview
    IPv4 Addressing
        Private Address Range
        Other Reserved Address Ranges
        Adding IP Address
    IPv6 Addressing
        Address Types
            Unicast Addresses
                Link-local Address
                Unique Local Address
                Special Purpose Address
                Compatibility Address
            Multicast Address
            Anycast Address
        Interface Identifier
            EUI-64
        Configuring IPv6 Address
        SLAAC IPv6 Address
        Properties
        Read-only properties
        Frequently asked questions

Overview

IP addresses serve for general host identification purposes in IP networks (RFC 791). A typical (IPv4) address consists of four octets. For proper addressing the router also needs the network mask value, id est which bits of the complete IP address refer to the address of the host, and which - to the address of the network. The network address value is calculated by binary AND operation from a network mask and IP address values. It's also possible to specify an IP address followed by a slash "/" and the number of bits that form the network address.

In most cases, it is enough to specify the address, the netmask, and the interface arguments. The network prefix and the broadcast address are calculated automatically.

It is possible to add multiple IP addresses to an interface or to leave the interface without any addresses assigned to it. In the case of bridging or PPPoE connection, the physical interface may not have any address assigned, yet be perfectly usable. Configuring an IP address to a physical interface included in a bridge would mean actually setting it on the bridge interface itself.

You can use /ip address print detail to see which interface the address belongs to.
IPv4 Addressing

IPv4 uses 4-byte addresses which are segmented in four 8-bit fields called octets. Each octet is converted to a decimal format and separated by a dot. For example:
11000000 10101000 00000011 00011000 => 192.168.3.24

The IPv4 network consists of three addresses:

    network address - a standard way to refer to an IPv4 address assigned to a network. For example, we could refer to the network 192.168.1.0 or 172.16.0.0 as a “Network Address.”
    broadcast address - a special address for each network that allows communication to all the hosts in that network. The broadcast address uses the highest address in the network range. for example, broadcast address if 192.168.1.0/24 network will be 192.168.1.255
    host address - any other address that is not a network address and broadcast address can be used as a host address. For example, 192.168.1.2 - 254 host addresses can be used from 192.168.1.0/24 address range

There are several types of IP addressing

    unicast - normally refers to a single sender or a single receiver, and can be used for both sending and receiving. Usually, a unicast address is associated with a single device or host, but it is not a one-to-one correspondence.
    broadcast - address to send data to all possible destinations ("all-hosts broadcast"), which permits the sender to send the data only once, and all receivers receive a copy of it. In the IPv4 protocol, the address 255.255.255.255 is used for local broadcast. In addition, a directed (limited) broadcast can be made by combining the network prefix with a host suffix composed entirely of binary 1s. For example, the destination address used for directed broadcast to devices on the 192.0.2.0/24 network is 192.0.2.255
    multicast - address associated with a group of interested receivers. In IPv4, addresses 224.0.0.0 through 239.255.255.255 are designated as multicast addresses. The sender sends a single datagram from its unicast address to the multicast group address and the intermediary routers take care of making copies and sending them to all receivers that have joined the corresponding multicast group.

Private Address Range

The following IP address ranges are reserved (RFC 6890) for private addressing. These addresses are not routed in the global routing table and should be translated to global addresses with network address translation (NAT):

    10.0.0.0/8 - start: 10.0.0.0; end: 10.255.255.255
    172.16.0.0/12 - start: 172.16.0.0; end:172.31.255.255
    192.168.0.0/16 - start: 192.168.0.0; end: 192.168.255.255

Other Reserved Address Ranges

    198.18.0.0/15 - benchmarking
    192.88.99.0/24 - 6to4 relay anycast address range
    192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24 - documentation
    169.254.0.0/16 - auto-configuration address range

Adding IP Address

Consider a setup where two routers are directly connected with the cable and we do not want to waste address space:

R1 configuration:
/ip address
add address=10.1.1.1/32 interface=ether1 network=172.16.1.1

R2 configuration:
/ip address
add address=172.16.1.1/32 interface=ether1 network=10.1.1.1
IPv6 Addressing

Internet Protocol version 6 (IPv6) is the newer version of the Internet Protocol (IP). It was initially expected to replace IPv4 in a short enough time, but for now, it seems that these two versions will coexist on the Internet in foreseeable future. Nevertheless, IPv6 becomes more important, as the date of the unallocated IPv4 address pool's exhaustion approaches.

The two main benefits of IPv6 over IPv4 are:

    much larger address space;
    support of stateless and stateful address auto-configuration;
    built-in security;
    new header format (faster forwarding).

IPv6 uses 16 bytes addresses compared to 4-byte addresses in IPv4. IPv6 address syntax and types are described in RFC 4291.

There are multiple IPv6 address types, that can be recognized by their prefix. RouterOS distinguishes the following:

    multicast (with prefix ff00::/8)
    link-local (with prefix fe80::/10)
    unique local addresses (with prefix fc00::/7)
    loopback (the address::1/128)
    unspecified (the address::/128)
    other (all other addresses, including the obsoleted site-local addresses, and RFC 4193 unique local addresses; they all are treated as global unicast).


One difference between IPv6 and IPv4 addresses is that IPv6 automatically generates a link-local IPv6 address for each active interface that has IPv6 support.

IPv6 addresses are represented a little bit differently than IPv4 addresses. For IPv6, the 128-bit address is divided into eight 16-bit blocks, and each 16-bit block is converted to a 4-digit hexadecimal number and separated by colons. The resulting representation is called colon-hexadecimal.

In the example below IPv6 address in binary format is converted to a colon-hexadecimal representation
0010000000000001 0000010001110000 0001111100001001 0000000100110001
0000000000000000 0000000000000000 0000000000000000 0000000000001001
2001:0470:1f09:0131:0000:0000:0000:0009

The IPv6 address can be further simplified by removing leading zeros in each block:
2001:470:1f09:131:0:0:0:9

As you can see IPv6 addresses can have long sequences of zeros. This contiguous sequence can be compressed to ::
2001:470:1f09:131::9

Zero compression can only be used once. Otherwise, you could not determine the number of 0 bits represented by each instance of a double-colon


IPv6 prefix is written in address/prefix-length format. Compared to IPv4 decimal representation of a network mask cannot be used. Prefix examples:
2001:470:1f09:131::/64
2001:db8:1234::/48
2607:f580::/32
2000::/3
Address Types

Several IPv6 address types exist:

    Unicast
    Anycast
    Multicast

As you can see there are no Broadcast addresses in the IPv6 network, compared to the IPv4 broadcast functionality was completely replaced with multicast.
Unicast Addresses

Packets addressed to a unicast address are delivered only to a single interface. To this group belong:

    globally unique addresses and can be used to connect to addresses with global scope anywhere;
    link-local addresses;
    unique local addresses (ULA RFC4193)
    site-local addresses (FEC0::/48) - deprecated;
    special-purpose addresses;
    compatibility addresses;

A global unicast address can be automatically assigned to the node by Stateless Address auto-configuration.
Link-local Address

A link-local address is required on every IPv6-enabled interface, applications may rely on the existence of a link-local address even when there is no IPv6 routing, that is why the link-local address is generated automatically for every active interface using its interface identifier (calculated EUI-64 from MAC address if present). The address prefix is always FE80::/64 and IPv6 router never forwards link-local traffic beyond the link.

These addresses are comparable to the auto-configuration addresses 169.254.0.0/16 of IPv4.

A link-local address is also required for IPv6 Neighbor Discovery processes.

If the interface is set as a bridge port, an interface-specific link-local address is removed leaving only the bridge link-local address
Unique Local Address

Unique Local Address (ULA) is reserved for local use in the home and enterprise environments not routed in public address space and is equivalent to IPv4 private address ranges.

The reserved address range is fc00::/7


Special Purpose Address
Unspecified address (::/128)	Never assigned to an interface or used as a destination address, used only to indicate the absence of an address. Equivalent to IPv4 0.0.0.0 address.
loopback address (::1/128)	Used to identify a loopback interface, enabling a node to send packets to itself. It is equivalent to the IPv4 loopback address of 127.0.0.1.
2002::/16	This prefix is used for 6to4 addressing. Here, an address from the IPv4 network 192.88.99.0/24 is also used.
2001:db8::/32	Address range reserved for documentation. These should never be seen as the source or destination.
2001:0010::/28	Orchid fixed term experiment. Should not be seen as a source or destination
2001:0002::/48	Used for benchmarking, should not be seen as source or destination
2001:0000::/32	Teredo
Compatibility Address
IPv4 compatible address	used by dual-stack nodes that are communicating with IPv6 over an IPv4 infrastructure. When the IPv4-compatible address is used as an IPv6 destination, IPv6 traffic is automatically encapsulated with an IPv4 header and sent to the destination by using the IPv4 infrastructure. The address is written in the following format ::w.x.y.z, where w.x.y.z is the dotted decimal representation of a public IPv4 address.
IPv4 mapped address	used to represent an IPv4-only node to an IPv6 node. It is used only for internal representation. The IPv4-mapped address is never used as a source or destination address for an IPv6 packet. The IPv6 protocol does not support the use of IPv4-mapped addresses. The address is written in the following format: ::ffff:w.x.y.z, where w.x.y.z is the dotted-decimal representation of a public IPv4 address.
Multicast Address

The most important multicast aspects are:

    traffic is sent to a single address but is processed by multiple hosts;
    group membership is dynamic, allowing hosts to join and leave the group at any time;
    in IPv6, Multicast Listener Discovery (MLD) messages are used to determine group membership on a network segment, also known as a link or subnet;
    a host can send traffic to the group's address without belonging to the corresponding group.


A single IPv6 multicast address identifies each multicast group. Each group's reserved IPv6 address is shared by all host members of the group who listen and receive any IPv6 messages sent to the group's address.

The multicast address consists of the following parts:

    The first 8 bits in the multicast address are always 1111 1111 (which is FF in hexadecimal format).
    The flag uses the 9th to 12th bit and shows if this multicast address is predefined (well-known) or not. If it is well-known, all bits are 0s.
    Scope ID indicates to which scope multicast address belongs, for example, Scope ID=2 is link-local scope.
    The group ID is used to specify a multicast group. There are predefined group IDs, such as Group ID=1 - all nodes. Therefore, if the multicast address is ff02::1, that means Scope ID=2 and Group ID=1, indicating all nodes in link-local scope. This is analogous to broadcast on IPv4.


Here is the table of reserved IPV6 addresses for multicast:
FF02::1	The all-nodes address is used to reach all nodes on the same link.
FF02::2	The all-routers address is used to reach all routers on the same link.
FF02::5	The all-Open Shortest Path First (OSPF) router address is used to reach all OSPF routers on the same link.
FF02::6	The all-OSPF-designated router's address is used to reach all OSPF-designated routers on the same link.
FF02::1:FFXX:XXXX	The solicited-node address is used in the address resolution process to resolve the IPv6 address of a link-local node to its link-layer address. The last 24 bits (XX:XXXX) of the solicited-node address are the last 24 bits of an IPv6 unicast address.



The following table is a partial list of IPv6 multicast addresses that are reserved for IPv6 multicasting and registered with the Internet Assigned Numbers Authority (IANA). For a complete list of assigned addresses read IANA document.

Multicast addresses can be used to discover nodes in a network. For example, discover all nodes
mrz@bumba:/media/aaa/ver$ ping6 ff02::1%eth0
PING ff02::1%eth0(ff02::1) 56 data bytes
64 bytes from fe80::21a:4dff:fe5d:8e56: icmp_seq=1 ttl=64 time=0.037 ms
64 bytes from fe80::20c:42ff:fe0d:2c38: icmp_seq=1 ttl=64 time=4.03 ms (DUP!)
64 bytes from fe80::20c:42ff:fe28:7945: icmp_seq=1 ttl=64 time=5.59 ms (DUP!)
64 bytes from fe80::20c:42ff:fe49:fce5: icmp_seq=1 ttl=64 time=5.60 ms (DUP!)
64 bytes from fe80::20c:42ff:fe21:f1ec: icmp_seq=1 ttl=64 time=5.88 ms (DUP!)
64 bytes from fe80::20c:42ff:fe72:a1b0: icmp_seq=1 ttl=64 time=6.70 ms (DUP!)

discover all routers
mrz@bumba:/media/aaa/ver$ ping6 ff02::2%eth0
PING ff02::2%eth0(ff02::2) 56 data bytes
64 bytes from fe80::20c:42ff:fe28:7945: icmp_seq=1 ttl=64 time=0.672 ms
64 bytes from fe80::20c:42ff:fe0d:2c38: icmp_seq=1 ttl=64 time=1.44 ms (DUP!)

Anycast Address

An anycast address is a new type of address incorporated in IPv6.

Anycasting is a new networking paradigm supporting service-oriented Addresses where an identical address can be assigned to multiple nodes providing a specific service. An anycast packet (i.e., one with an anycast destination address) is delivered to one of these nodes with the same anycast address.

An anycast address is not assigned a specific address range. It is assigned from the unicast address range.
Interface Identifier

The last 64 bits of an IPv6 address are the interface identifier that is unique to the 64-bit prefix of the IPv6 address. There are several ways how to determine interface identifier:

    EUI-64;
    randomly generated to provide a level of anonymity;
    manually configured.

EUI-64

Traditional interface identifiers for network adapters are 48-bit MAC addresses. This address consists of a 24-bit manufacturer ID and a 24-bit board ID.

IEEE EUI-64 is a new standard for network interface addresses. The company ID is still 24 bits in length, but the extension ID is 40 bits, creating a much larger address space for network adapters.

To create a EUI-64 address from the interface MAC address:

    0xFFFE is inserted into the MAC address between the manufacturer ID and the board ID.
    The seventh bit of the first byte is reversed.


Let's make an example with the following MAC address 00:0C:42:28:79:45.

The image above illustrates the conversion process. When the result is converted to colon-hexadecimal notation, we get the interface identifier 20C:42FF:FE28:7945. As a result, the corresponding link-local address is
FE80::20C:42FF:FE28:7945/64

In RouterOS, if the EUI-64 parameter of an address is configured, the last 64 bits of that address will be automatically generated and updated using interface identifier. The last bits must be configured to be zero for this case. Example:
[admin@MikroTik] > ipv6 address add address=fc00:3::/64 interface=ether3 eui-64=yes
[admin@MikroTik] > ipv6 address print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
#    ADDRESS                                     INTERFACE                  ADVERTISE
...
5  G fc00:3::20c:42ff:fe1d:3d4/64                ether3                     yes
[admin@MikroTik] > interface ethernet set ether3 mac-address=10:00:00:00:00:01
[admin@MikroTik] > ipv6 address print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
#    ADDRESS                                     INTERFACE                  ADVERTISE
...
5  G fc00:3::1200:ff:fe00:1/64                   ether3                     yes
Configuring IPv6 Address

This example shows how to set up simple addressing with global IPv6 addresses between two routers.

R1 configuration:
/ipv6 address
add address=2001:DB8::1/64 interface=ether1 advertise=no

R2 configuration:
/ipv6 address
add address=2001:DB8::2/64 interface=ether1 advertise=no

Check the address list:
[admin@R1] /ipv6 address> print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
#    ADDRESS                                     FROM-POOL INTERFACE     ADVERTISE
0  G 2001:db8::1/64                                        ether1        no
3 DL fe80::219:d1ff:fe39:3535/64                           ether1        no


Notice that our added address has a G flag indicating that this address can be globally routed. We also have a link-local address on the interface which is created automatically for every IPv6-capable interface.

Test connectivity:
[admin@R1] /ipv6 address> /ping 2001:DB8::2
HOST                                     SIZE TTL TIME  STATUS
2001:db8::2                 56  64 12ms  echo reply
2001:db8::2                 56  64 0ms   echo reply
    sent=2 received=2 packet-loss=0% min-rtt=0ms avg-rtt=6ms max-rtt=12ms
SLAAC IPv6 Address

If under IPv6/Settings menu "accept-router-advertisements" option is enabled and the router receives a Router Advertisement packet, then the SLAAC IPv6 address will be automatically assigned to the interface on which the advertisements were received. This address will have DG flags meaning that the address is dynamic and global. Such addresses will show valid and lifetime parameters.
[admin@R1] /ipv6/address/print detail where dynamic && global 
Flags: X - disabled, I - invalid, D - dynamic; G - global, L - link-local 
 0 DG address=2001:db8::::ba69:f4ff:fe84:545/64 from-pool="" interface=ether1 
      actual-interface=test_fp eui-64=no advertise=no no-dad=no valid=4w2d 
      preferred=1w 

If SLAAC addresses are accepted, then also dynamic route toward the Internet will be generated. It will also contain a few limitations if specified on the advertisement packet. For example, hop-limit and MTU. If multiple addresses are received on the same interface, then the lowest of the MTU values per interface will be used.
[admin@R1] /routing/route/print detail where slaac 
Flags: X - disabled, F - filtered, U - unreachable, A - active; 
c - connect, s - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn, m - modem, a - ldp-address, l - ldp-mapping, g - slaac, y - bgp-mpls-vpn; 
H - hw-offloaded; + - ecmp, B - blackhole 
 Ag + afi=ip6 contribution=active dst-address=::/0 routing-table=main 
       pref-src="" gateway=fe80::ba69:f4ff:fe84:7b2%ether1
       immediate-gw=fe80::ba69:f4ff:fe84:7b2%ether1 distance=1 scope=30 
       target-scope=10 belongs-to="slaac" mtu=1400 hoplimit=10 
       debug.fwp-ptr=0x201C2C00 
Properties
address (Address/Netmask; Default: )	Ipv6 address. Allowed netmask range is 0..128. Address can also be constructed from the pool if from-pool property is specified.
For example if address is set to ::1/64 then address will be constructed as follows <prefix_from_pool>::1/64
advertise (yes | no; Default: no)	Whether to enable stateless address configuration. The prefix of that address is automatically advertised three times to hosts using ICMPv6 protocol. The option is set by default for addresses with prefix length 64. If address is removed or changed, then old prefix will be deprecated by automatically advertising the old prefix with lifetime set to "0s" three times to hosts using ICMPv6 protocol
comment comment (string; Default: )	Descriptive name of an item
disabled (yes | no; Default: no)	Whether address is disabled or not. By default it is not disabled
eui-64 (yes | no; Default: no)	Whether to calculate EUI-64 address and use it as last 64 bits of the IPv6 address. 
from-pool (string; Default: )	Name of the pool from which prefix will be taken to construct IPv6 address taking last part of the address from address property.
no-dad (yes | no; Default: no)	If enabled (yes) - disables Duplicate Address Detection (DAD) for IPv6 addresses on an interface. This can be useful in scenarios where you want to assign static IPv6 addresses to devices and avoid the delay caused by DAD.
interface (string; Default: )	Name of an interface on which Ipv6 address is set.
auto-link-local (yes | no; Default: yes)	If newly created address is manual link-local address this setting allows to override dynamically created IPv6 link-local address.
Read-only properties
actual-interface (string)	Actual interface on which address is set up. For example, if address was configured on ethernet interface and ethernet interface was added to bridge, then actual interface is bridge not ethernet.
dynamic (yes | no)	Whether address is dynamically created
global (yes | no)	Whether address is global
invalid (yes | no)	Whether address is invalid
link-local (yes | no)	Whether address is link local
deprecated (yes | no)	Whether address is deprecated
slave (yes | no)	Whether address belongs to an interface which is a slave port to some other master interface
Frequently asked questions

Q: Does RouterOS support NAT64?
A: No, currently NAT64 is not implemented in RouterOS






    Creado por Usuario desconocido (olga), actualizado por última vez por Gļebs K. el mar 10, 2025 9 min de lectura

    Summary
    Node description
    Stateless address autoconfiguration
        Address states
    Neighbor discovery
        Properties
    Prefix
        Properties
    Neighbors List
    Examples
        Stateless autoconfiguration example

Summary

Standards: RFC 2462, RFC 2461, RFC 4861

RouterOS has IPv6 Neighbor Discovery and stateless address autoconfiguration support using Router Advertisement Daemon (RADVD).
Node description

Node is a device that implements IPv6. In IPv6 networks nodes are divided into two types:

    Routers - a node that forwards IPv6 packets not explicitly addressed to itself.
    Hosts - any node that is not a router.

Routers and hosts are strictly separated, meaning that routers cannot be hosts and hosts cannot be routers at the same time.
Stateless address autoconfiguration

There are several types of autoconfiguration:

    stateless - address configuration is done by receiving Router Advertisement messages. These messages include stateless address prefixes and require that host is not using stateful address configuration protocol.
    stateful - address configuration is done by using the stateful address configuration protocol (DHCPv6). The stateful protocol is used if RA messages do not include address prefixes.
    both - RA messages include stateless address prefixes and require that hosts use a stateful address configuration protocol.

A highly useful feature of IPv6 is the ability to automatically configure itself without the use of a stateful configuration protocol like DHCP ( See example).

Address autoconfiguration can only be performed on multicast-capable interfaces.


It is called stateless address autoconfiguration since there is no need to manage the state on the router side. It is a very simple, robust, and effective autoconfiguration mechanism.

RouterOS uses RADVD to periodically advertise information about the link to all nodes on the same link. The information is carried by ICMPv6 "router advertisement" packet, and includes the following fields:

    IPv6 subnet prefix
    Default router link-local address
    Other parameters that may be optional: are link MTU, default hop limit, and router lifetime.

Then host catches the advertisement, and configures the global IPv6 address and the default router. Global IPv6 address is generated from the advertised subnet prefix and EUI-64 interface identifier.

Optionally, the host can ask for an advertisement from the router by sending an ICMPv6 "router solicitation" packet. On Linux rtsol utility transmits the router solicitation packet. If you are running a mobile node, you may want to transmit router solicitations periodically.
Address states

When an auto-configuration address is assigned it can be in one of the following states:

    tentative - in this state host verifies that the address is unique. Verification occurs through duplicate address detection.
    preferred - at this state address is verified as unique and the node can send and receive unicast traffic to and from a preferred address. The period of time of the preferred state is included in the RA message.
    deprecated - the address is still valid, but is not used for new connections.
    invalid - node can no longer send or receive unicast traffic. An address enters the invalid state after the valid lifetime expires.

The image above illustrates the relation between states and lifetimes. 
Neighbor discovery

Sub-menu: /ipv6 nd

In this submenu, IPv6 Neighbor Discovery (ND) protocol is configured.

Neighbor Discovery (ND) is a set of messages and processes that determine relationships between neighboring nodes. ND, compared to IPv4, replaces Address Resolution Protocol (ARP), Internet Control Message Protocol (ICMP) Router Discovery, and ICMP Redirect and provides additional functionality.

ND is used by hosts to:

    Discover neighboring routers.
    Discover addresses, address prefixes, and other configuration parameters.

ND is used by routers to:

    Advertise their presence, host configuration parameters, and on-link prefixes.
    Inform hosts of a better next-hop address to forward packets to a specific destination.

ND is used by nodes to:

    Both resolve the link-layer address of a neighboring node to which an IPv6 packet is being forwarded and determine when the link-layer address of a neighboring node has changed.
    Determine whether IPv6 packets can be sent to and received from a neighbor.

Properties
advertise-dns (yes | no; Default: yes)	Option to redistribute DNS server information using RADVD. You will need a running client-side software with Router Advertisement DNS support to take advantage of the advertised DNS information. Read more >>
advertise-mac-address (yes | no; Default: yes)	When set, the link-layer address of the outgoing interface is included in the RA.
comment (string; Default: )	Descriptive name of an item
dns-servers (unspecified | ipv6 addresses; Default: unspecified)	Specify a single IPv6 address or list of addresses that will be provided to hosts for DNS server configuration.
disabled (yes | no; Default: no)	Whether an item is disabled or not. By default, entry is enabled.
hop-limit (unspecified | integer[0..255]; Default: unspecified)	The default value that should be placed in the Hop Count field of the IP header for outgoing (unicast) IP packets.
interface (all | string; Default: )	The interface on which to run neighbor discovery.

    all - run ND on all running interfaces.

managed-address-configuration (yes | no; Default: no)	The flag indicates whether hosts should use stateful autoconfiguration (DHCPv6) to obtain addresses.
mtu (unspecified | integer[0..4294967295]; Default: unspecified)	The MTU option is used in router advertisement messages to ensure that all nodes on a link use the same MTU value in those cases where the link MTU is not well known.

    unspecified - do not send the MTU option.

other-configuration (yes | no; Default: no)	The flag indicates whether hosts should use stateful autoconfiguration to obtain additional information (excluding addresses).
pref64-prefixes (unspecified | ipv6 prefixes; Default: unspecified)	Specify IPv6 prefix or list of prefixes within /32, /40. /48, /56, /64, or /96 subnet that will be provided to hosts as NAT64 prefixes.
ra-delay (time; Default: 3s)	The minimum time allowed between sending multicast router advertisements from the interface.
ra-interval (time[3s..20m50s]-time[4s..30m]; Default: 3m20s-10m)	The min-max interval allowed between sending unsolicited multicast router advertisements from the interface.
ra-preference (low | medium | high; Default: medium)	Specify the router preference that is communicated to IPv6 hosts through router advertisements. The preference value in the router advertisements enables IPv6 hosts to select a default router to reach a remote destination
ra-lifetime (none | time; Default: 30m)	Sets the RA lifetime. A Lifetime of 0 indicates that the router is not a default router.(see Section 6.2.3 of RFC 4861)
reachable-time (unspecified | time[0..1h]; Default: unspecified)	The time that a node assumes a neighbor is reachable after having received a reachability confirmation. Used by the Neighbor Unreachability Detection algorithm (see Section 7.3 of RFC 2461)
retransmit-interval (unspecified | time; Default: unspecified)	The time between retransmitted Neighbor Solicitation messages. Used by address resolution and the Neighbor Unreachability Detection algorithm (see Sections 7.2 and 7.3 of RFC 2461)

If ND is automatically generated by LTE configuration, then the maximum lifetime for RA will be capped at 1 hour.
Prefix

Sub-menu: /ipv6 nd prefix

Prefix information sent in RA messages used by stateless address auto-configuration.

Note: The autoconfiguration process applies only to hosts and not routers.
Properties
6to4-interface (none | string; Default: )	If this option is specified, this prefix will be combined with the IPv4 address of the interface name to produce a valid 6to4 prefix. The first 16 bits of this prefix will be replaced by 2002 and the next 32 bits of this prefix will be replaced by the IPv4 address assigned to the interface name at configuration time. The remaining 80 bits of the prefix (including the SLA ID) will be advertised as specified in the configuration file.
autonomous (yes | no; Default: yes)	When set, indicates that this prefix can be used for autonomous address configuration. Otherwise, prefix information is silently ignored.
comment (string; Default: )	Descriptive name of an item
disabled (yes | no; Default: no)	Whether an item is disabled or not. By default, entry is enabled.
on-link (yes | no; Default: yes)	When set, indicates that this prefix can be used for on-link determination. When not set the advertisement makes no statement about the on-link or off-link properties of the prefix. For instance, the prefix might be used for address configuration with some of the addresses belonging to the prefix being on-link and others being off-link.
preferred-lifetime (infinity | time; Default: 1w)	Timeframe (relative to the time the packet is sent) after which generated address becomes "deprecated". Deprecated is used only for already existing connections and is usable until valid lifetime expires. Read more >>
prefix (ipv6 prefix; Default: ::/64)	A prefix from which stateless address autoconfiguration generates the valid address.
valid-lifetime (infinity | time; Default: 4w2d)	The length of time (relative to the time the packet is sent) an address remains in the valid state. The valid lifetime must be greater than or equal to the preferred lifetime. Read more >>
interface (string; Default: )	Interface name on which stateless auto-configuration will be running.
Neighbors List

Sub-menu: /ipv6 neighbor

List of all discovered nodes by IPv6 neighbor discovery protocol (neighbor cache) or manually added by configuration.
address (ipv6 address; Default: )	IPv6 address of the neighbour.
interface (string; Default: )	interface name to which this neighbour is attached.
mac-address (MAC; Default: 00:00:00:00:00:00)	MAC address of the device to be added.

Read-only Properties
address (ipv6 address)	IPv6 address of the node.
interface (string)	The interface on which the node was detected.
mac-address (string)	Mac address of the discovered node.
router (yes | no)	Whether the discovered node is a router
status (noarp | incomplete | stale | reachable | delay | probe | failed)	Status of the cached entry:

    noarp - the neighbor entry is valid. No attempts to validate this entry will be made but it can be removed when its lifetime expires

    incomplete - address resolution is in progress and the link-layer address of the neighbor has not yet been determined;

    reachable - the neighbor is known to have been reachable recently (within tens of seconds ago);

    stale - the neighbor is no longer known to be reachable but until traffic is sent to the neighbor, no attempt should be made to verify its reachability;

    delay - the neighbor is no longer known to be reachable, and traffic has recently been sent to the neighbor, probes are delayed for a short period in order to give upper layer protocol a chance to provide reachability confirmation;

    probe - the neighbor is no longer known to be reachable, and unicast Neighbor Solicitation probes are being sent to verify reachability.
    failed - the router was unable to resolve the neighbor’s MAC address using neighbor discovery protocol.

The default maximum number of neighbor entries depends on the installed amount of RAM. It can be adjusted with the command "/ipv6 settings set max-neighbor-entries=x", see more details on IPv6 Settings.
Examples
Stateless autoconfiguration example


[admin@MikroTik] > ipv6 address print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
# ADDRESS INTERFACE ADVERTISE
0 G 2001:db8::1/64 ether1 yes

As an example, the advertise flag is enabled which indicates that dynamic/ipv6 nd prefixentry is added.


[admin@MikroTik] > ipv6 nd prefix print 
Flags: X - disabled, I - invalid, D - dynamic 
0 D prefix=2001:db8::/64 interface=ether1 on-link=yes autonomous=yes
 valid-lifetime=4w2d preferred-lifetime=1w


On a host that is directly attached to the router, we see that an address was added. The address consists of the prefix part (first 64 bits) that takes the prefix from the prefix advertisement, and the host part (last 64 bits) that is automatically generated from the local MAC address:
atis@atis-desktop:~$ ip -6 addr
 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 
inet6 ::1/128 scope host 
valid_lft forever preferred_lft forever 
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qlen 1000 
inet6 2001:db8::21a:4dff:fe56:1f4d/64 scope global dynamic
 valid_lft 2588363sec preferred_lft 601163sec 
inet6 fe80::21a:4dff:fe56:1f4d/64 scope link 
valid_lft forever preferred_lft forever


The host has received the 2001:db8::/64 prefix from the router and configured an address with it.

There is also an option to redistribute DNS server information using RADVD:


[admin@MikroTik] > ip dns set server=2001:db8::2 
[admin@MikroTik] > ip dns print servers: 2001:db8::2
 ... 
[admin@MikroTik] > ipv6 nd set [f] advertise-dns=yes


You will need a running client-side software with Router Advertisement DNS support to take advantage of the advertised DNS information.

On Ubuntu/Debian Linux distributions you can install rdnssd package which is capable of receiving the advertised DNS addresses.
mrz@bumba:/$ sudo apt-get install rdnssd


mrz@bumba:/$ cat /etc/resolv.conf 
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
 # DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
 nameserver 2001:db8::2 

mrz@bumba:/$ ping6 www.mikrotik.com 
PING www.mikrotik.com(2a02:610:7501:1000::2) 56 data bytes
 64 bytes from 2a02:610:7501:1000::2: icmp_seq=1 ttl=61 time=2.11 ms
 64 bytes from 2a02:610:7501:1000::2: icmp_seq=2 ttl=61 time=1.33 ms 
^C
 --- www.mikrotik.com ping statistics --- 
2 packets transmitted, 2 received, 0% packet loss, time 1001ms 
rtt min/avg/max/mdev = 1.334/1.725/2.117/0.393 ms 
mrz@bumba:/$




    Creado por Usuario desconocido (emils), actualizado por última vez por GG el feb 28, 2024 2 min de lectura

    Summary
    IPv4 Pool
        Example
        Used addresses
    IPv6 Pool
        Example
        Used addresses

Summary

IP pools are used to define range of IP addresses that can be used by various RouterOS utilities, for example, DHCP server, Point-to-Point servers and more. Separate lists for IPv4 and IPv6 are available. Whenever possible, the same IP address is given out to each client (OWNER/INFO pair).
IPv4 Pool

Sub-menu: /ip pool
comment (string; Default: )	Short description of the pool

name (string; Default: )
	Unique identifier of the pool
next-pool (string; Default: )	When IP address acquisition is performed a pool that has no free addresses, and the next-pool property is set, then IP address will be acquired from next-pool
ranges (IP; Default: )	IP address list of non-overlapping IP address ranges in the form of: from1-to1,from2-to2,...,fromN-toN. For example, 10.0.0.1-10.0.0.27,10.0.0.32-10.0.0.47
Example

To define a pool named "my-pool" with the 10.0.0.1-10.0.0.126 address range excluding gateway's address 10.0.0.1 and server's address 10.0.0.100, and the other pool dhcp-pool, with the 10.0.0.200-10.0.0.250 address range:
[admin@MikroTik] ip pool> add name=my-pool ranges=10.0.0.2-10.0.0.99,10.0.0.101-10.0.0.126
[admin@MikroTik] ip pool> add name=dhcp-pool ranges=10.0.0.200-10.0.0.250
[admin@MikroTik] ip pool> print
  # NAME                                        RANGES
  0 ip-pool                                     10.0.0.2-10.0.0.99
                                                10.0.0.101-10.0.0.126
  1 dhcp-pool                                   10.0.0.200-10.0.0.250
Used addresses

Sub-menu: /ip pool used

Here you can see all used IP addresses from IP pools.


Read-only properties
address (IP)	IP address that is assigned to client from the pool

info (string)
	For DHCP MAC address from leases menu and for PPP connections username of PPP type client
owner (string)	Service which is using this IP address
pool (string)	

Name of the IP pool
IPv6 Pool

Sub-menu: /ipv6 pool


name (string; Default: )	Descriptive name of the pool.
prefix (IPv6/0..128; Default: )	Ipv6 address prefix
prefix-length (integer [1..128]; Default: )	The option represents the prefix size that will be given out to the client.

Read-only properties
dynamic (yes | no)	Whether the pool is dynamic.
expire-time (time)	Expire time is set to dynamic pools added by DHCPv6 client.
Example

The example will create a pool of "2001::/60" to give out /62 prefixes:
[admin@test-host] /ipv6 pool> add
name: test prefix: 2001::/60
prefix-length: 62
[admin@test-host] /ipv6 pool> print
# NAME PREFIX PREFIX-LENGTH
0 test 2001::/60 62bits
Used addresses

Sub-menu: /ipv6 pool used

Read-only properties
info (string)	Shows DUID related information received from the client (value in hex). Can contain also a raw timestamp in hex.
owner (string)	What reserved the prefix ("DHCP", etc.)
pool (string)	Name of the pool.
prefix (IPv6/0..128)	IPv6 prefix that is assigned to the client from the pool.





    Creado por Normunds R., actualizado por última vez por Māris B. el jul 21, 2024 15 min de lectura

    Overview
    How Routing Works
    Routing Information
        Routing Information Base
            Connected Routes
            Default Route
            Hardware Offloaded Route
            Multipath (ECMP) routes
            Route Selection
            Nexthop Lookup
            Route Storage
        Forwarding Information Base
            Routing table lookup
    Show Routes

Overview

Routing is the process of selecting paths across the networks to move packets from one host to another. 
How Routing Works

Let's look at a basic configuration example to illustrate how routing is used to forward packets between two local networks and to the Internet.

In this setup, we have several networks:

    two client networks (192.168.2.0/24 and 192.168.1.0/24);
    one network to connect routers (172.16.1.0/30), usually called backbone;
    the last network (10.1.1.0/24) connects our gateway router (Router1) to the internet. 


 Router 2:
/ip address
add address=172.16.1.2/30 interface=ether1
add address=192.168.2.1/24 interface=bridge2


Router1 (gateway) where ether1 connects to the internet:
/ip address
add address=10.1.1.2/24 interface=ether1
add address=172.16.1.1/30 interface=ether2
add address=192.168.1.1/24 interface=bridge1

If we look, for example, at the Router1 routing table, we can see that the router knows only about directly connected networks. At this point, when the Client from LAN1 tries to reach the client from LAN2 (192.168.2.0/24), a packet will be dropped on the router, because the destination is unknown for the particular router:
[admin@MikroTik] > /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - static, r - ri
p, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY, Distance
    DST-ADDRESS    GATEWAY D
DAC 10.1.1.0/24    ether1  0
DAC 172.16.1.0/30  ether2  0
DAC 192.168.1.0/24 bridge1 0

To fix this we need to add a route that tells the router what is the next device in the network to reach the destination.  In our example next hop is Router2, so we need to add a route with the gateway that points to the Router's 2 connected address. This type of route is known as a static route:
[admin@MikroTik] > /ip route add dst-address=192.168.2.0/24 gateway=172.16.1.2
[admin@MikroTik] > /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - static, r - ri
p, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY,       Distance
        DST-ADDRESS    GATEWAY       D
    DAC 10.1.1.0/24    ether1        0
    DAC 172.16.1.0/30  ether2        0
    DAC 192.168.1.0/24 bridge1       0
0   AS  192.168.2.0/24 172.16.1.2    

At this point packet from LAN1 will be successfully forwarded to LAN2, but we are not over yet. Router2 does not know how to reach LAN1, so any packet from LAN2 will be dropped on Router2.

If we look again at the network diagram, we can clearly see that Router2 has only one point of exit. It is safe to assume that all other unknown networks should be reached over the link to Router1. The easiest way to do this is by adding a default route: To add a default route set destination 0.0.0.0/0 or leave it blank:
/ip route add gateway=172.16.1.1

As we have seen from the example setup, there are different groups of routes, based on their origin and properties.
Routing Information

RouterOS routing information consists of two main parts:

    FIB (Forwarding Information Base), is used to make packet forwarding decisions. It contains a copy of the necessary routing information.
    RIB (Routing Information Base) contains all learned prefixes from routing protocols (connected, static, BGP, RIP, OSPF).



Routing Information Base

Routing Information Base is a database that lists entries for particular network destinations and their gateways (address of the next device along the path or simply next-hop). One such entry in the routing table is called a route.

A hop occurs when a packet is passed from one network segment to another.

By default, all routes are organized in one "main" routing table. It is possible to make more than one routing table which we will discuss further in this article, but for now, for sake of simplicity, we will consider that there is only one "main" routing table.

RIB table contains complete routing information, including static routes and policy routing rules configured by the user, routing information learned from dynamic routing protocols (RIP, OSPF, BGP), and information about connected networks.

Its purpose is not just to store routes, but also to filter routing information to calculate the best route for each destination prefix, to build and update the Forwarding Information Base, and to distribute routes between different routing protocols.
Connected Routes

Connected routes represent the network on which hosts can be directly reached (direct attachment to Layer2 broadcast domain). These routes are created automatically for each IP network that has at least one enabled interface attached to it (as specified in the /ip address or /ipv6 address configuration). RIB tracks the status of connected routes but does not modify them. For each connected route there is one IP address item such that:

    address part of the dst-address of the connected route is equal to a network of IP address item.
    netmask part of dst-address of the connected route is equal to the netmask part of the address of the IP address item.
    gateway of the connected route is equal to the actual-interface of the IP address item (same as an interface, except for bridge interface ports) and represents an interface where directly connected hosts from the particular Layer3 network can be reached.

The preferred source is not used anymore for connected routes. FIB chooses the source address based on the out-interface. This allows making setups that in ROS v6 and older were considered invalid. See examples for more details.
Default Route

A default route is used when the destination cannot be resolved by any other route in the routing table. In RouterOS dst-address of the default route is 0.0.0.0/0 (for IPv4) and ::/0 (for IPv6) routes. If the routing table contains an active default route, then the routing table lookup in this table will never fail.

Typically home router routing table contains only connected networks and one default route to forward all outgoing traffic to the ISP's gateway:
[admin@TempTest] /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - static, r - ri
p, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY, Distance
#      DST-ADDRESS     GATEWAY      D
   DAd 0.0.0.0/0       10.155.125.1 1
   DAC 10.155.125.0/24 ether12      0
   DAC 192.168.1.0/24  vlan2        0
Hardware Offloaded Route

Devices with Layer 3 Hardware Offloading (L3HW, otherwise known as IP switching or HW routing) allow offloading packet routing onto the switch chip. When L3HW is enabled, such routes will display H-flag:
[admin@MikroTik] > /ip/route print where static
Flags: A - ACTIVE; s - STATIC, y - COPY; H - HW-OFFLOADED
Columns: DST-ADDRESS, GATEWAY, DISTANCE
#     DST-ADDRESS       GATEWAY         D
0 AsH 0.0.0.0/0         172.16.2.1      1
1 AsH 10.0.0.0/8        10.155.121.254  1
2 AsH 192.168.3.0/24    172.16.2.1      1

By default, all the routes are participating to be hardware candidate routes. To further fine-tune which traffic to offload, there is an option for each IP or IPv6 static route to disable/enable suppress-hw-offload. 

For example, if we know that the majority of traffic flows to the network where servers are located, we can enable offloading only to that specific destination:
/ip route set [find where static && dst-address!="192.168.3.0/24"] suppress-hw-offload=yes

Now only the route to 192.168.3.0/24 has an H-flag, indicating that it will be the only one eligible to be selected for HW offloading:
[admin@MikroTik] > /ip/route print where static
Flags: A - ACTIVE; s - STATIC, y - COPY; H - HW-OFFLOADED
Columns: DST-ADDRESS, GATEWAY, DISTANCE
#     DST-ADDRESS       GATEWAY         D
0 As  0.0.0.0/0         172.16.2.1      1
1 As  10.0.0.0/8        10.155.121.254  1
2 AsH 192.168.3.0/24    172.16.2.1      1

H-flag does not indicate that the route is actually HW offloaded, it indicates only that route can be selected to be HW offloaded.
Multipath (ECMP) routes

To implement some setups, such as load balancing, it might be necessary to use more than one path to a given destination.


ECMP (Equal cost multi-path) routes have multiple gateways (next-hop) values. All reachable next-hops are copied to FIB and are used to forward packets.

These routes can be created manually, as well as dynamically by any of the dynamic routing protocols (OSPF, BGP, RIP). Multiple equally preferred routes to the same destination will have assigned + flag and grouped together automatically by RouterOS (see example below).
[admin@TempTest] /ip/route> print 
Flags: D - DYNAMIC; I - INACTIVE, A - ACTIVE; C - CONNECT, S - STATIC, m - MODEM; + - ECMP
Columns: DST-ADDRESS, GATEWAY, DISTANCE
#       DST-ADDRESS      GATEWAY       D
0   AS+ 192.168.2.0/24   10.155.125.1  1
1   AS+ 192.168.2.0/24   172.16.1.2    1

By default, ECMP uses Layer3 hash policy which hashes source IP and destination IP (for IPv4) or source IP, destination IP, flow label and IP protocol (for IPv6).

It is possible to change hashing policies in /ip/setting and /ipv6/settings to Layer4 hashing or inner Layer3 hashing.
L3	

srcIPv4, dstIPv4
	srcIPv6, dstIPv6, flow label, IP proto
L4	srcIPv4, dstIPv4, srcPort, dstPort, IP proto	srcIPv6, dstIPv6, srcPort, dstPort, IP Proto
L3-Inner	

    srcIPv4, dstIPv4 (if inner IPv4)
    srcIPv6, dstIPv6, flow label, IP proto (if inner IPv6)
    Same as L3 if inner is not present.

	

    srcIPv4, dstIPv4 (if inner IPv4)
    srcIPv6, dstIPv6, flow label, IP proto (if inner IPv6)
    Same as L3 if inner is not present.


Route Selection

There can be multiple routes with the same destination received from various routing protocols and from static configurations but only one (best) destination can be used for packet forwarding. To determine the best path, RIB runs a Route Selection algorithm that picks the best route from all candidate routes per destination.

Only routes that meet the following criteria can participate in the route selection process:

    Route is not disabled.
    If the type of route is unicast it must have at least one reachable next-hop. ( if a gateway is from a connected network and there is a connected route active, the gateway is considered as reachable) 
    Route should not be synthetic.


The candidate route with the lowest distance becomes an active route. If there is more than one candidate route with the same distance, the selection of the active route is arbitrary.
Nexthop Lookup


Nexthop lookup is a part of the route selection process. Its main purpose is to find a directly reachable gateway address (next-hop). Only after a valid next-hop is selected router knows which interface to use for packet forwarding.


Nexthop lookup becomes more complicated if routes have a gateway address that is several hops away from this router (e.g. iBGP, multihop eBGP). Such routes are installed in the FIB after the next-hop selection algorithm determines the address of the directly reachable gateway (immediate next-hop).


It is necessary to restrict the set of routes that can be used to look up immediate next-hops. Nexthop values of RIP or OSPF routes, for example, are supposed to be directly reachable and should be looked up only using connected routes. This is achieved using scope and target-scope properties.

Routes with a scope greater than the maximum accepted value are not used for next-hop lookup. Each route specifies the maximum accepted scope value for its nexthop in the target-scope property. The default value of this property allows nexthop lookup only through connected routes, with the exception of iBGP routes that have a larger default value and can lookup nexthop also through IGP and static routes.

There are changes in RouterOS v7 nexthop lookup.

Routes are processed in scope order, and updates to routes with a larger scope cannot affect the state of nexthop lookup for routes with a smaller scope.

Consider an example from v6:
/ip route add dst-address=10.0.1.0/24 gateway=10.0.0.1
    scope=50 target-scope=30 comment=A
/ip route add dst-address=10.0.2.0/24 gateway=10.0.0.1
    scope=30 target-scope=20 comment=B
/ip route add dst-address=10.0.0.0/24 scope=20 gateway=WHATEVER
    comment=C

Gateway 10.0.0.1 is recursively resolved through C using the smallest referring scope (scope 20 from route B), both routes are active. Now we change both A and B at the same time:
/ip route set A target-scope=10

Suddenly, applying an update to route A makes the gateway of route B inactive. This is because in v6 there is only one gateway object per address.

v7 keeps multiple gateway objects per address, one for each combination of scope and gateway check.

When target-scope or gateway check of a route is changed, ROS v7 will not affect other routes, as it does in v6. In v7 target-scope and gateway check are properties that are internally attached to the gateway, not to the route.

Scope values considered as invalid and fixed automatically:

    if gateway scope is set to 255 - RouterOS will internally fix this error by setting gateway scope to 254.
    if route scope is less than gateway scope - RouterOS will internally fix this error by setting route scope to "gateway scope + 1"

Used actual scope and target scope values can be seen in /routing/nexthop menu

Gateway check can be extended by setting check-gateway parameter. Gateway reachability can be checked by sending ARP probes, or ICMP messages or by checking active BFD sessions. The router periodically (every 10 seconds) checks the gateway by sending either an ICMP echo request (ping) or an ARP request (arp). If no response from the gateway is received for 10 seconds, the request times out. After two timeouts gateway is considered unreachable. After receiving a reply from the gateway it is considered reachable and the timeout counter is reset.


Route Storage

Routing information is stored to take as little memory as possible in a common case. These optimizations have non-obvious worst cases and impact on performance.

All routes and gateways are kept in a single hierarchy by the prefix/address.

    Dst [4]/0 1/0+4                             18  <-- number of prefixes
         ^  ^ ^ ^ ^
         |  | | | |
         |  | | | \- bytes taken by Route distinguisher or Interface Id
         |  | | \--- vrf/routing table
         |  | \----- AFI
         |  \------- netmask length of prefix
         \---------- bytes taken by prefix value

         [subject to change without notice]
    

Each of these 'Dst' corresponds to a unique 'dst-address' of route or address of the gateway. Each 'Dst' requires one or more 'T2Node' objects as well.

All routes with the same 'dst-address' are kept in Dst in a list sorted by route preference.
Note: WORST CASE: having a lot of routes with the same 'dst-address' is really slow! even if they are inactive! because updating a sorted list with tens of thousands of elements is slow!

Route order changes only when route attributes change. If the route becomes active/inactive, the order does not change.

Each Route has three copies of route attributes:

    private -- what is received from the peer, before passing in-filters.
    updated -- what is the result of applying in-filters.
    current -- what are the attributes currently used by the route.


Periodically (when needed), update attributes are calculated from private attributes. This happens when route update is received, or when in-filter is updated.

When the routing table is recalculated, current attributes are set to the value from updated attributes.

This means, that usually if there is no in-filter that changes route attributes, private, updated, and current share the same value.

Route attributes are kept in several groups:

    L1 Data - all flags, list of extra properties, as-path;
    L2 Data - nexthops, RIP, OSPF, BGP metrics, route tags, originators, etc.
    L3 Data - distance, scope, kernel type, MPLS stuff
    extra properties - communities, originator, aggregator-id, cluster-list, unknown


Having for example many different combinations of distance and scope route attributes will use more memory!

Matching communities or as-path using regexp will cache the result, to speed up filtering. Each as-path or community value has a cache for all regexp, which is filled on-demand with match results.
Note: WORST CASE: changing attributes in 'in-filter' will make the route program use more memory! Because 'private' and 'updated' attributes will be different! Having a lot of different regexps will make matching slow and use a lot of memory! Because each value will have a cache with thousands of entries!

Detailed info about used memory by routing protocols can be seen in /routing stats memory menu
Forwarding Information Base

FIB (Forwarding Information Base) contains a copy of the information that is necessary for packet forwarding:

    all active routes
    policy routing rules


Each route has dst-address property, that specifies all destination addresses this route can be used for. If several routes apply to a particular IP address, the most specific one (with the largest netmask) is used. This operation (finding the most specific route that matches the given address) is called ''routing table lookup''.

Only one Best route can be used for packet forwarding. In cases where the routing table contains several routes with the same dst-address, all equally best routes are combined into one ECMP route. The best route is installed into FIB and marked as ''active''.

When forwarding decision uses additional information, such as the source address of the packet, it is called policy routing. Policy routing is implemented as a list of policy routing rules, that select different routing tables based on the destination address, source address, source interface, and routing mark (which can be changed by firewall mangle rules) of the packet.
Routing table lookup

FIB uses the following information from the packet to determine its destination:

    source address
    destination address
    source interface
    routing mark


Possible routing decisions are:

    receive packet locally
    discard the packet (either silently or by sending an ICMP message to the sender of the packet)
    send the packet to a specific IP address on a specific interface


Run routing decision:

    check that the packet has to be locally delivered (the destination address is the address of the router)
    process implicit policy routing rules
    process policy routing rules added by a user
    process implicit catch-all rule that looks up the destination in the ''main'' routing table
    the returned result is "network unreachable"


The result of the routing decision can be:

    IP address of nexthop + interface
    point-to-point interface
    local delivery
    discard
    ICMP prohibited
    ICMP host unreachable
    ICMP network unreachable


Rules that do not match the current packet are ignored. If a rule has action:

    drop or unreachable, then it is returned as a result of the routing decision process.
    lookup then the destination address of the packet is looked up in the routing table that is specified in the rule. If the lookup fails (no route matches the destination address of the packet), then FIB proceeds to the next rule.
    lookup-only is similar to lookup except that lookup fails if none of the routes in the table matches the packet.

Otherwise:

    if the type of the route is blackhole, prohibit, or unreachable, then return this action as the routing decision result;
    if this is a connected route or route with an interface as the gateway value, then return this interface and the destination address of the packet as the routing decision result;
    if this route has an IP address as the value of the gateway, then return this address and associated interface as the routing decision result;
    if this route has multiple values of nexthop, then pick one of them in a round-robin fashion.


Show Routes

In RouterOS you have three menus to see the current state of routes in the routing table:

    /ip route - list IPv4 routes and basic properties
    /ipv6 route - list IPv6 routes and basic properties
    /routing route - list all routes with extended properties

/routing route menu currently is read-only. To add or remove routes/ip(ipv6) route menus should be used.


Example output
[admin@MikroTik] /ip/route> print
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - stati
c, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY, DIstance
#       DST-ADDRESS      GATEWAY      DI
0   XS   10.155.101.0/24  1.1.1.10 
1   XS                    11.11.11.10 
   D d   0.0.0.0/0        10.155.101.1 10
2   AS   0.0.0.0/0        10.155.101.1 1
3   AS + 1.1.1.0/24       10.155.101.1 10
4   AS + 1.1.1.0/24       10.155.101.2 10
5   AS   8.8.8.8          2.2.2.2      1
   DAC   10.155.101.0/24  ether12      0


|  ||| |   |                 |         |
|  ||| |   |                 |         \----Distance
|  ||| |   |                 \--Configured gateway
|  ||| |   \-- dst prefix
|  ||| \----- ECMP flag
|  ||\------- flag indicating which protocol have added the route (bgp, osf,static,connected etc.)
|  |\-------- route status flag (active, inactive, disabled)
|  \--------- shows if route is dynamic
\----------- console order number (shown only for static editable routes)
    

routing route output is very similar to ip route except that it shows routes from all address families in one menu and lists filtered routes as well.
[admin@MikroTik] /routing/route> print
Flags: X - disabled, I - inactive, F - filtered, U - unreachable, A - active; c - connect, s - static, 
r - rip, b - bgp, o - ospf, d - dhcp, v - vpn, a - ldp-address, l - ldp-mapping
Columns: DST-ADDRESS, GATEWAY, DIStance, SCOpe, TARget-scope, IMMEDIATE-GW
     DST-ADDRESS            GATEWAY      DIS SCO TAR IMMEDIATE-GW 
Xs   10.155.101.0/24 
Xs 
d    0.0.0.0/0              10.155.101.1 10  30  10  10.155.101.1%ether12
As   0.0.0.0/0              10.155.101.1 1   30  10  10.155.101.1%ether12
As   1.1.1.0/24             10.155.101.1 10  30  10  10.155.101.1%ether12
As   8.8.8.8                2.2.2.2      1   254 254 10.155.101.1%ether12
Ac   10.155.101.0/24        ether12      0   10      ether12 
Ic   2001:db8:2::/64        ether2       0   10 
Io   2001:db8:3::/64        ether12      110 20  10 
Ic   fe80::%ether2/64       ether2       0   10 
Ac   fe80::%ether12/64      ether12      0   10      ether12 
Ac   fe80::%bridge-main/64  bridge-main  0   10      bridge-main 
A    ether12                             0   250 
A    bridge-main                         0   250 
    

routing route print detail shows more advanced info useful for debugging
[admin@MikroTik] /routing route> print detail
Flags: X - disabled, I - inactive, F - filtered, U - unreachable, A - active;
c - connect, s - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn, a - ldp-address, l - ldp-ma>
+ - ecmp
Xs dst-address=10.155.101.0/24
Xs
d afi=ip4 contribution=best-candidate dst-address=0.0.0.0/0 gateway=10.155.101.1
immediate-gw=10.155.101.1%ether12 distance=10 scope=30 target-scope=10
belongs-to="DHCP route" mpls.in-label=0 .out-label=0 debug.fwp-ptr=0x201C2000

As afi=ip4 contribution=active dst-address=0.0.0.0/0 gateway=10.155.101.1
immediate-gw=10.155.101.1%ether12 distance=1 scope=30 target-scope=10
belongs-to="Static route" mpls.in-label=0 .out-label=0 debug.fwp-ptr=0x201C2000



    Creado por Edgars P., actualizado por última vez por Rihards Vārna el feb 03, 2025 5 min de lectura

    Summary
    IPv4 Settings
    IPv6 Settings

Summary

Several IPv4 and IPv6 related kernel and system-wide parameters are configurable.
IPv4 Settings

Sub-menu: /ip settings
accept-redirects (yes | no; Default: no)	Whether to accept ICMP redirect messages. Typically should be enabled on a host and disabled on routers.
accept-source-route (yes | no; Default: no)	Whether to accept packets with the SRR option. Typically should be enabled on the router.
allow-fast-path (yes | no; Default: yes)	Allows Fast Path.
arp-timeout (time interval; Default: 30s)	Sets Linux base_reachable_time (base_reachable_time_ms) on all interfaces that use ARP. The initial validity of the ARP entry is picked from the interval [timeout/2 - 3*timeout/2] (default from 15s to 45s) after the neighbor was found. Can use postfix ms, s, m, h, d for milliseconds, seconds, minutes, hours, or days. if no postfix is set then seconds (s) are used. The parameter means how long a valid ARP record will be considered complete if no one communicates with the specific MAC/IP during this time. The parameter does not represent a time when an ARP entry is removed from the ARP cache (see max-neighbor-entries setting).
icmp-errors-use-inbound-interface-address (yes | no; Default: no)	If enabled, the ICMP error message reply will be sent with the source address equal to primary address of the receiving interface that caused the error . This feature can be useful for complex network debugging.
icmp-rate-limit (integer [0..4294967295]; Default: 10)	Limit the maximum rates for sending ICMP packets whose type matches icmp-rate-mask to specific targets. 0 disables any limiting, other values indicate the minimum space between responses in milliseconds.
icmp-rate-mask ([0..FFFFFFFF]; Default: 0x1818)	Mask made of ICMP types for which rates are being limited. More info in Linux man pages
ip-forward (yes | no; Default: yes)	Enable/disable packet forwarding between interfaces. Resets all configuration parameters to defaults according to RFC1812 for routers.
ipv4-multipath-hash-policy(l3 | l4 | l3-inner; Default: l3)	

IPv4 Hash policy used for ECMP routing in /ip/settings menu

    l3 -- layer-3 hashing of src IP, dst IP
    l3-inner -- layer-3 hashing or inner layer-3 hashing if available
    l4 -- layer-4 hashing of src IP, dst IP, IP protocol, src port, dst port

rp-filter (loose | no | strict; Default: no)	Disables or enables source validation.

    no - No source validation.
    strict - Strict mode as defined in RFC3704 Strict Reverse Path. Each incoming packet is tested against the FIB and if the interface is not the best reverse path the packet check will fail. By default failed packets are discarded.
    loose - Loose mode as defined in RFC3704 Loose Reverse Path. Each incoming packet's source address is also tested against the FIB and if the source address is not reachable via any interface the packet check will fail.

The current recommended practice in RFC3704 is to enable strict mode to prevent IP spoofing from DDoS attacks. If using asymmetric routing or other complicated routing or VRRP, then the loose mode is recommended.

Warning: strict mode does not work with routing tables
secure-redirects (yes | no; Default: yes)	Accept ICMP redirect messages only for gateways, listed in the default gateway list.
send-redirects (yes | no; Default: yes)	Whether to send ICMP redirects. Recommended to be enabled on routers.

tcp-timestamps (disabled | enabled | random-offset; Default: random-offset)
	Parameter allows to enable/disable TCP timestamps or add random offset to TCP timestamp (default behavior). Disabling timestamps completely may help to reduce spikes of performance drops.
tcp-syncookies (yes | no; Default: no)	Send out syncookies when the syn backlog queue of a socket overflows. This is to prevent the common 'SYN flood attack'. syncookies seriously violate TCP protocol, and disallow the use of TCP extensions, which can result in serious degradation of some services (f.e. SMTP relaying), visible not by you, but to your clients and relays, contacting you.
max-neighbor-entries (integer [0..4294967295]; Default: )	

Sets Linux gc_thresh3. A maximum number of allowed neighbors in the ARP table. Since RouterOS version 7.1, the default value depends on the installed amount of RAM. It is possible to set a higher value than the default, but it increases the risk of out-of-memory condition.

The default values for certain RAM sizes:

    2048 for 64 MB,
    4096 for 128 MB,
    8192 for 256 MB,
    16384 for 512 MB or higher.

The ARP cache stores ARP entries, and if some of these entries are incomplete, they can stay in the cache for an indefinite period of time. This will only happen if the number of entries in the cache is less than one-fourth of the maximum number allowed. The reason for this is to prevent the unnecessary running of the garbage-collector when the ARP table is not close to being full.
route-cache (yes | no; Default: yes)	Disable or enable the Linux route cache. Note that disabling the route cache, will also disable the fast path.

Read-Only Properties
ipv4-fast-path-active (yes | no)	Indicates whether fast-path is active
ipv4-fast-path-bytes (integer)	Amount of fast-pathed bytes
ipv4-fast-path-packets (integer)	Amount of fast-pathed packets
ipv4-fasttrack-active (yes | no)	Indicates whether fasttrack is active
ipv4-fasttrack-bytes (integer)	Amount of fasttracked bytes
ipv4-fasttrack-packets (integer)	Amount of fasttracked packet.
IPv6 Settings

Sub-menu: /ipv6 settings

Changing /ipv6 settings will not dynamically remove the old SLAAC configuration present on your router. A reboot is required to apply the new settings.


accept-redirects (no | yes-if-forwarding-disabled; Default: yes-if-forwarding-disabled)	Whether to accept ICMP redirect messages. Typically should be enabled on the host and disabled on routers
accept-router-advertisements (no | yes | yes-if-forwarding-disabled; Default: yes-if-forwarding-disabled)	Accept router advertisement (RA) messages. If enabled, the router will be able to get the address using stateless address configuration
disable-ipv6 (yes | no; Default: no)	Enable/disable system wide IPv6 settings (prevents LL address generation)
forward (yes | no; Default: yes)	Enable/disable packet forwarding between interfaces
max-neighbor-entries (integer [0..4294967295]; Default: )	A maximum number or IPv6 neighbors. Since RouterOS version 7.1, the default value depends on the installed amount of RAM. It is possible to set a higher value than the default, but it increases the risk of out-of-memory condition.

The default values for certain RAM sizes:

    1024 for 64 MB,
    2048 for 128 MB,
    4096 for 256 MB,
    8192 for 512 MB,
    16384 for 1024 MB or higher.

multipath-hash-policy (l3 | l4 | l3-inner; Default: l3)	

IPv6 Hash policy used for ECMP routing in /ipv6/settings menu

    l3 -- layer-3 hashing of src IP, dst IP, flow label, IP protocol
    l3-inner -- layer-3 hashing or inner layer-3 hashing if available
    l4 -- layer-4 hashing of src IP, dst IP, IP protocol, src port, dst port

disabled-link-local-address (no | yes ; Default: no)	

Disable automatic link-local address generation for non-VPN interfaces. This can be used when manually configured link-local addresses are being used.
stale-neighbor-timeout (time ; Default: 60)	

Timeout after which stale IPv6/Neighbor entries should be purged.
min-neighbor-entries (integer ; Default: 4096)	

Minimal number of IPv6/Neighbor entries, for which device must allocate memory.
soft-max-neighbor-entries (integer ; Default: 8192)	

Expected maximum number of IPv6/Neighbor entries which system should handle.
max-neighbor-entries (integer ; Default: 16384)	

Maximum number of entries for IPv7/Neighbor list.
allow-fast-path (yes | no; Default: yes)	

Allows Fast Path.

Read-Only Properties
ipv6-fast-path-active (yes | no)	Indicates whether fast-path is active
ipv6-fast-path-bytes (integer)	Amount of fast-pathed bytes
ipv6-fast-path-packets (integer)	Amount of fast-pathed packets
ipv6-fasttrack-active (yes | no)	Indicates whether fasttrack is active
ipv6-fasttrack-bytes (integer)	Amount of fasttracked bytes
ipv6-fasttrack-packets (integer)	Amount of fasttracked packet.





