

    Creado por Usuario desconocido (emils), actualizado por última vez por GG el feb 09, 2024 14 min de lectura

In This Section:

        IP Addressing
        IPv6 Neighbor Discovery
        IP Pools
        IP Routing
        IP Settings


    Networking Models
        OSI Model
        TCP/IP Model
    Ethernet
    IP Networking
    ARP and Tying It All Together
        ARP Modes
            Enabled
            Disabled
            Reply Only
            Proxy ARP
                Local Proxy ARP
    TCP/IP
        TCP Session Establishment and Termination
            Connection establishment process
            Connection termination
        TCP Segments transmission (windowing)

Networking Models

Computer networks consist of many different components and protocols working together. To understand the concept of how node to node communication happens, let's get familiar to the OSI model and TCP/IP model. Both models help to visualize how communication between nodes is happening.
OSI Model

The Open Systems Interconnection (OSI) model is a 7-layer model that today is used as a teaching tool. The OSI model was originally conceived as a standard architecture for building network systems, but in real-world networks are much less defined than the OSI model suggests.


    Layer 7 (Application) - a protocol that defines the communication between the server and the client, for example, HTTP protocol. If the web browser wants to download an image, the protocol will organize and execute the request;
    Layer 6 (Presentation) - ensures data is received in a usable format. Encryption is done here (but in reality it may not be true, for example, IPSec);
    Layer 5 (Session) - responsible for setting up, managing and closing sessions between client and server;
    Layer 4 (Transport) - transport layers primary responsibility is assembly and reassembly, a data stream is divided into chunks (segments), assigned sequence numbers and encapsulated into protocol header (TCP, UDP, etc.);
    Layer 3 (Network) - responsible for logical device addressing, data is encapsulated within an IP header and now called "packet";
    Layer 2 (Data link) - Data is encapsulated within a custom header, either 802.3 (Ethernet) or 802.11 (wireless) and is called "frame", handles flow control;
    Layer 1 (Physical) - Communication media that sends and receives bits, electric signaling, and hardware interface;

TCP/IP Model

This model has the same purpose as the OSI model but fits better into modern network troubleshooting. Comparing to the OSI model, TCP/IP is a 4-layer model:

    Application layer (4) - includes application, presentation and session layers of the OSI model, which significantly simplifies network troubleshooting;
    Transport layer (3) - same as a transport layer in the OSI model (TCP, UDP protocols);
    Internet layer (2) - does the same as Network layer in the OSI model (include ARP, IP protocols);
    Link layer (1) - also called the Network Access layer. Includes both Layer1 and 2 of the OSI model, therefore its primary concern is physical data exchange between network nodes;



TCP/IP	OSI Model	Protocols
Application Layer	Application Layer	DNS, DHCP,HTTP,SSH etc.
Presentation Layer	JPEG,MPEG,PICT etc.
Session Layer	PAP, SCP, ZIP etc.
Transport Layer	Transport Layer	TCP, UDP
Internet Layer	Network Layer	ICMP, IGMP, IPv4, IPv6, IPSec
Link Layer	Data Link Layer	ARP, CDP, MPLS, PPP etc.
Physical Layer	Bluetooth, Ethernet, Wi-Fi etc.




Ethernet

The most commonly used link layer protocol (OSI Layer2) in computer networks is the Ethernet protocol. In order to communicate, each node has a unique assigned address, called MAC (Media Access Control address) sometimes it is also called an Ethernet address.

It is 48-bit long and typically fixed by the manufacturer (cannot be changed), but in recent years customization of MAC addresses is widely used, RouterOS also allows to set custom MAC address.

Most commonly used MAC format is 6 hexadecimal numbers separated by colons (D4:CA:6D:01:22:96)

RouterOS shows MAC address in a configuration for all Ethernet-like interfaces (Wireless, 60G, VPLS, etc.)
[admin@rack1_b32_CCR1036] /interface ethernet> print 
Flags: X - disabled, R - running, S - slave 
 #    NAME                  MTU MAC-ADDRESS       ARP             SWITCH               
 0 R  ether1               1500 D4:CA:6D:01:22:96 enabled        
 1 R  ether2               1500 D4:CA:6D:01:22:97 enabled        
 2 R  ether3               1500 D4:CA:6D:01:22:98 enabled        
 3    ether4               1500 D4:CA:6D:01:22:99 enabled        
 4    ether5               1500 D4:CA:6D:01:22:9A enabled        
 5    ether6               1500 D4:CA:6D:01:22:9B enabled        
 6    ether7               1500 D4:CA:6D:01:22:9C enabled        
 7 R  ether8               1500 D4:CA:6D:01:22:9D enabled        
 8    sfp-sfpplus1         1500 D4:CA:6D:01:22:94 enabled        
 9    sfp-sfpplus2         1500 D4:CA:6D:01:22:95 enabled 


There are three types of addresses:

    Unicast address is sent to all nodes within the collision domain, which typically is Ethernet cable between two nodes or in case of wireless all receivers that can detect wireless signals. Only remote node with matching MAC address will accept the frame (unless the promiscuous mode is enabled)

    One of the special addresses is broadcast address (FF:FF:FF:FF:FF:FF), a broadcast frame is accepted and forwarded over Layer2 network by all nodes

    Another special address is multicast. Frames with multicast addresses are received by all nodes configured to receive frames with this address.


IP Networking

Ethernet protocol is sufficient to get data between two nodes on an Ethernet network, but it is not used on its own. For Internet/Networking layer (OSI Layer 3) IP (Internet Protocol) is used to identify hosts with unique logical addresses.

Most of the current networks use IPv4 addresses, which are 32bit address written in dotted-decimal notation (192.168.88.1)

There can be multiple logical networks and to identify which network IP address belongs to, the netmask is used. Netmask typically is specified as a number of bits used to identify a logical network. The format can also be in decimal notation, for example, the 24-bit netmask can be written as 255.255.255.0

Let's take a closer look at 192.168.3.24/24:
11000000 10101000 00000011 00011000 => 192.168.3.24
11111111 11111111 11111111 00000000 => /24 or 255.255.255.0


As can be seen from the illustration above high 24 bits are masked, leaving us with a range of 0-255.

From this range, the first address is used to identify the network (in our example network address would be 192.168.3.0) and the last one is used for network broadcast (192.168.3.255). That leaves us with a range from 1 to 254 for host identification which is called unicast addresses.

The same as in Ethernet protocol there can be also special addresses:

    broadcast - address to send data to all possible destinations ("all-hosts broadcast"), which permits the sender to send the data only once, and all receivers receive a copy of it. In the IPv4 protocol, the address 255.255.255.255 is used for local broadcast. In addition, a directed (limited) broadcast can be made to network broadcast address;
    multicast - address associated with a group of interested receivers. In IPv4, addresses 224.0.0.0 through 239.255.255.255 are designated as multicast addresses. The sender sends a single datagram from its unicast address to the multicast group address and the intermediary routers take care of making copies and sending them to all receivers that have joined the corresponding multicast group;

In case of logical IP network, unicast, broadcast and multicast visualization would look a bit different

There are also address ranges reserved for a special purpose, for example, private address range, that should be used only in local networks and typically are dropped when forwarded to the internet:

    10.0.0.0/8 - start: 10.0.0.0; end: 10.255.255.255
    172.16.0.0/12 - start: 172.16.0.0; end:172.31.255.255
    192.168.0.0/16 - start: 192.168.0.0; end: 192.168.255.255

ARP and Tying It All Together

Even though IP packets are addressed using IP addresses, hardware addresses must be used to actually transport data from one host to another.

This brings us to Address Resolution Protocol (ARP) which is used for mapping the IP address of the host to the hardware address (MAC). ARP protocol is referenced in RFC 826.

Each network device has a table of currently used ARP entries. Normally the table is built dynamically, but to increase network security, it can be partially or completely built statically by means of adding static entries.

Address Resolution Protocol is a thing of the past. IPv6 completely eliminates use of the ARP.


When a host on the local area network wants to send an IP packet to another host in this network, it must look for the Ethernet MAC address of destination host in its ARP cache. If the destination host’s MAC address is not in the ARP table, then the ARP request is sent to find the device with a corresponding IP address. ARP sends a broadcast request message to all devices on the LAN by asking the devices with the specified IP address to reply with its MAC address. A device that recognizes the IP address as its own returns ARP response with its own MAC address:

Let's make a simple configuration and take a closer look at processes when Host A tries to ping Host C.

At first, we add IP addresses on Host A:
/ip address add address=10.155.101.225 interface=ether1

Host B:
/ip address add address=10.155.101.221 interface=ether1

Host C:
/ip address add address=10.155.101.217 interface=ether1

Now, let's run a packet sniffer that saves packet dump to the file and run the ping command on Host A:
/tool sniffer
  set file-name=arp.pcap filter-interface=ether1
  start 
/ping 10.155.101.217 count=1
  stop

Now you can download arp.pcap file from the router and open it in Wireshark for analyzing:


    Host A sends ARP message asking who has "10.155.101.217"
    Host C responds that 10.155.101.217 can be reached at 08:00:27:3C:79:3A MAC address
    Both Host A and Host C now have updated their ARP tables and now ICMP (ping) packets can be sent

If we look at ARP tables of both host we can see relevant entries, in RouterOS ARP table can be viewed by running command: /ip arp print
[admin@host_a] /ip arp> print 
Flags: X - disabled, I - invalid, H - DHCP, D - dynamic, P - published, 
C - complete 
 #    ADDRESS         MAC-ADDRESS       INTERFACE                          
 0 DC 10.155.101.217  08:00:27:3C:79:3A ether1  

 [admin@host_b] /ip arp> print 
Flags: X - disabled, I - invalid, H - DHCP, D - dynamic, P - published, 
C - complete 
 #    ADDRESS         MAC-ADDRESS       INTERFACE                     
 0 DC 10.155.101.225  08:00:27:85:69:B5 ether1  
ARP Modes

Now the example above demonstrated default behavior, where ARP is enabled on interfaces, but there might be scenarios where different ARP behavior is necessary. RouterOS allows configuring different ARP modes for interfaces that support ARP.
Enabled

ARPs will be discovered automatically and new dynamic entries will be added to the ARP table. This is a default mode for interfaces in RouterOS and illustrated in the example above.
Disabled

If the ARP feature is turned off on the interface, i.e., arp=disabled is used, ARP requests from clients are not answered by the router. Therefore, static ARP entry should be added to the clients as well. For example, the router's IP and MAC addresses should be added:
[admin@host_a] > /ip arp add mac-address=08:00:27:3C:79:3A address=10.155.101.217 interface=ether1
Reply Only

If the ARP property is set to reply-only on the interface, then the router only replies to ARP requests. Neighbour MAC addresses will be resolved using /ip arp statically, but there will be no need to add the router's MAC address to other hosts' ARP tables like in cases where ARP is disabled.
Proxy ARP

A router with properly configured proxy ARP feature acts as a transparent ARP proxy between directly connected networks. This behavior can be useful, for example, if you want to assign dial-in (PPP, PPPoE, PPTP) clients IP addresses from the same address space as used on the connected LAN.

Let's look at the example setup from the image above. Host A (172.16.1.2) on Subnet A wants to send packets to Host D (172.16.2.3) on Subnet B. Host A has a /16 subnet mask which means that Host A believes that it is directly connected to all 172.16.0.0/16 network (the same LAN). Since the Host A believes that is directly connected it sends an ARP request to the destination to clarify the MAC address of Host D. (in the case when Host A finds that destination IP address is not from the same subnet it sends a packet to the default gateway.). Host A broadcasts an ARP request on Subnet A.

Info from packet analyzer software:
 No.     Time   Source             Destination       Protocol  Info

 12   5.133205  00:1b:38:24:fc:13  ff:ff:ff:ff:ff:ff  ARP      Who has 173.16.2.3?  Tell 173.16.1.2


Packet details:

Ethernet II, Src: (00:1b:38:24:fc:13), Dst: (ff:ff:ff:ff:ff:ff)
    Destination: Broadcast (ff:ff:ff:ff:ff:ff)
    Source: (00:1b:38:24:fc:13)
    Type: ARP (0x0806)
Address Resolution Protocol (request)
    Hardware type: Ethernet (0x0001)
    Protocol type: IP (0x0800)
    Hardware size: 6
    Protocol size: 4
    Opcode: request (0x0001)
    [Is gratuitous: False]
    Sender MAC address: 00:1b:38:24:fc:13
    Sender IP address: 173.16.1.2
    Target MAC address: 00:00:00:00:00:00
    Target IP address: 173.16.2.3


With this ARP request, Host A (172.16.1.2) is asking Host D (172.16.2.3) to send its MAC address. The ARP request packet is then encapsulated in an Ethernet frame with the MAC address of Host A as the source address and a broadcast (FF:FF:FF:FF:FF:FF) as the destination address. Layer 2 broadcast means that frame will be sent to all hosts in the same layer 2 broadcast domain which includes the ether0 interface of the router, but does not reach Host D, because router by default does not forward layer 2 broadcasts.

Since the router knows that the target address (172.16.2.3) is on another subnet but it can reach Host D, it replies with its own MAC address to Host A.
No.     Time   Source            Destination         Protocol   Info

13   5.133378  00:0c:42:52:2e:cf  00:1b:38:24:fc:13   ARP        172.16.2.3 is at 00:0c:42:52:2e:cf

Packet details:

Ethernet II, Src: 00:0c:42:52:2e:cf, Dst: 00:1b:38:24:fc:13
   Destination: 00:1b:38:24:fc:13
   Source: 00:0c:42:52:2e:cf
   Type: ARP (0x0806)
Address Resolution Protocol (reply)
   Hardware type: Ethernet (0x0001)
   Protocol type: IP (0x0800)
   Hardware size: 6
   Protocol size: 4
   Opcode: reply (0x0002)
   [Is gratuitous: False]
   Sender MAC address: 00:0c:42:52:2e:cf
   Sender IP address: 172.16.1.254
   Target MAC address: 00:1b:38:24:fc:13
   Target IP address: 172.16.1.2


This is the Proxy ARP reply that the router sends to Host A. Router sends back unicast proxy ARP reply with its own MAC address as the source address and the MAC address of Host A as the destination address, by saying "send these packets to me, and I'll get it to where it needs to go."

When Host A receives ARP response it updates its ARP table, as shown:
C:\Users\And>arp -a
Interface: 173.16.2.1 --- 0x8
  Internet Address      Physical Address      Type
  173.16.1.254          00-0c-42-52-2e-cf    dynamic
  173.16.2.3            00-0c-42-52-2e-cf    dynamic
  173.16.2.2            00-0c-42-52-2e-cf    dynamic


After MAC table update, Host A forwards all the packets intended for Host D (172.16.2.3) directly to router interface ether0 (00:0c:42:52:2e:cf) and the router forwards packets to Host D. The ARP cache on the hosts in Subnet A is populated with the MAC address of the router for all the hosts on Subnet B. Hence, all packets destined to Subnet B are sent to the router. The router forwards those packets to the hosts in Subnet B.

Multiple IP addresses by the host are mapped to a single MAC address (the MAC address of this router) when proxy ARP is used.

Proxy ARP can be enabled on each interface individually with command arp=proxy-arp:
 [admin@MikroTik] /interface ethernet> set 1 arp=proxy-arp
 [admin@MikroTik] /interface ethernet> print
 Flags: X - disabled, R - running
   #    NAME                 MTU   MAC-ADDRESS         ARP
   0  R ether1              1500  00:30:4F:0B:7B:C1 enabled
   1  R ether2              1500  00:30:4F:06:62:12 proxy-arp
 [admin@MikroTik] interface ethernet>


Local Proxy ARP

if the arp property is set to local-proxy-arp on an interface, then the router performs proxy ARP to/from this interface only. I.e. for traffic that comes in and goes out of the same interface. In a normal LAN, the default behavior is for two network hosts to communicate directly with each other, without involving the router.

This is done to support (Ethernet) switch features, like RFC 3069, where the individual ports are NOT allowed to communicate with each other, but they are allowed to talk to the upstream router. As described in RFC 3069, it is possible to allow these hosts to communicate through the upstream router by proxy_arp'ing. Don't need to be used together with proxy_arp. This technology is known by different names:

    In RFC 3069 it is called VLAN Aggregation;
    Cisco and Allied Telesis call it Private VLAN;
    Hewlett-Packard calls it Source-Port filtering or port-isolation;
    Ericsson calls it MAC-Forced Forwarding (RFC Draft).

TCP/IP
TCP Session Establishment and Termination

TCP is a connection-oriented protocol. The difference between a connection-oriented protocol and a connection-less protocol is that a connection-oriented protocol does not send any data until a proper connection is established.

TCP uses a three-way handshake whenever the transmitting device tries to establish a connection to the remote node. As a result end-to-end virtual (logical) circuit is created where flow control and acknowledgment for reliable delivery are used. TCP has several message types used in connection establishment and termination process.
Connection establishment process

    The host A who needs to initialize a connection sends out an SYN (Synchronize) packet with a proposed initial sequence number to the destination "host B";
    When the host B receives an SYN message, it returns a packet with both SYN and ACK flags set in the TCP header (SYN-ACK);
    When the host A receives the SYN-ACK, it sends back the ACK (Acknowledgment) packet;
    Host B receives ACK and at this stage, the connection is ESTABLISHED;

Connection-oriented protocol services are often sending acknowledgments (ACKs) after successful delivery. After the packet with data is transmitted, the sender waits for acknowledgment from the receiver. If time expires and the sender did not receive ACK, a packet is retransmitted.
Connection termination

When the data transmission is complete and the host wants to terminate the connection, the termination process is initiated. Unlike TCP Connection establishment, which uses a three-way handshake, connection termination uses four-way massages. A connection is terminated when both sides have finished the shutdown procedure by sending a FIN (finish) and receiving an ACK (Acknowledgment).

    The host A, who needs to terminate the connection, sends a special message with the FIN flag, indicating that it has finished sending the data;
    The host B, who receives the FIN segment, does not terminate the connection but enters into a "passive close" (CLOSE_WAIT) state and sends the ACK for the FIN back to the host A. If host B does not have any data to transmit to the host A it will also send the FIN message. Now the host B enters into LAST_ACK state. At this point host B will no longer accept data from host A, but can continue to transmit data to host A.
    When the host A receives the last FIN from the host B, it enters into a (TIME_WAIT) state, and sends an ACK back to the host B;
    Host B gets the ACK from the host A and connection is terminated;

TCP Segments transmission (windowing)

Now that we know how the TCP connection is established we need to understand how data transmission is managed and maintained. In TCP/IP networks transmission between hosts is handled by TCP protocol.

Let’s think about what happens when data-grams are sent out faster than the receiving device can process. The receiver stores them in memory called a buffer. But since buffer space is not unlimited, when its capacity is exceeded receiver starts to drop the frames. All dropped frames must be re-transmitted again which is the reason for low transmission performance.

To address this problem, TCP uses a flow control protocol. The window mechanism is used to control the flow of the data. When a connection is established, the receiver specifies the window field in each TCP frame. Window size represents the amount of received data that the receiver is willing to store in the buffer. Window size (in bytes) is sent together with acknowledgments to the sender. So the size of the window controls how much information can be transmitted from one host to another without receiving an acknowledgment. The sender will send only the amount of bytes specified in window size and then will wait for acknowledgments with updated window size.

If the receiving application can process data as quickly as it arrives from the sender, then the receiver will send a positive window advertisement (increase the size of the window) with each acknowledgment. It works until the sender becomes faster than the receiver and incoming data will eventually fill the receiver's buffer, causing the receiver to advertise acknowledgment with a zero window. A sender that receives a zero window advertisement must stop transmit until it receives a positive window.  Let's take a look at the illustrated windowing process:





    The "host A" starts to transmit with a window size of 1000, one 1000byte frame is transmitted;
    Receiver "host B" returns ACK with window size to increase to 2000;
    The host A receives ACK and transmits two frames (1000 bytes each);
    After that, the receiver advertises an initial window size to 3000. Now sender transmits three frames and waits for an acknowledgement;
    The first three segments fill the receiver's buffer faster than the receiving application can process the data, so the advertised window size reaches zero indicating that it is necessary to wait before further transmission is possible;
    The size of the window and how fast to increase or decrease the window size is available in various TCP congestion avoidance algorithms such as Reno, Vegas, Tahoe, etc;






    Creado por Māris B., actualizado por última vez por Mārtiņš S. el ene 22, 2025 12 min de lectura

    Overview
    IPv4 Addressing
        Private Address Range
        Other Reserved Address Ranges
        Adding IP Address
    IPv6 Addressing
        Address Types
            Unicast Addresses
                Link-local Address
                Unique Local Address
                Special Purpose Address
                Compatibility Address
            Multicast Address
            Anycast Address
        Interface Identifier
            EUI-64
        Configuring IPv6 Address
        SLAAC IPv6 Address
        Properties
        Read-only properties
        Frequently asked questions

Overview

IP addresses serve for general host identification purposes in IP networks (RFC 791). A typical (IPv4) address consists of four octets. For proper addressing the router also needs the network mask value, id est which bits of the complete IP address refer to the address of the host, and which - to the address of the network. The network address value is calculated by binary AND operation from a network mask and IP address values. It's also possible to specify an IP address followed by a slash "/" and the number of bits that form the network address.

In most cases, it is enough to specify the address, the netmask, and the interface arguments. The network prefix and the broadcast address are calculated automatically.

It is possible to add multiple IP addresses to an interface or to leave the interface without any addresses assigned to it. In the case of bridging or PPPoE connection, the physical interface may not have any address assigned, yet be perfectly usable. Configuring an IP address to a physical interface included in a bridge would mean actually setting it on the bridge interface itself.

You can use /ip address print detail to see which interface the address belongs to.
IPv4 Addressing

IPv4 uses 4-byte addresses which are segmented in four 8-bit fields called octets. Each octet is converted to a decimal format and separated by a dot. For example:
11000000 10101000 00000011 00011000 => 192.168.3.24

The IPv4 network consists of three addresses:

    network address - a standard way to refer to an IPv4 address assigned to a network. For example, we could refer to the network 192.168.1.0 or 172.16.0.0 as a “Network Address.”
    broadcast address - a special address for each network that allows communication to all the hosts in that network. The broadcast address uses the highest address in the network range. for example, broadcast address if 192.168.1.0/24 network will be 192.168.1.255
    host address - any other address that is not a network address and broadcast address can be used as a host address. For example, 192.168.1.2 - 254 host addresses can be used from 192.168.1.0/24 address range

There are several types of IP addressing

    unicast - normally refers to a single sender or a single receiver, and can be used for both sending and receiving. Usually, a unicast address is associated with a single device or host, but it is not a one-to-one correspondence.
    broadcast - address to send data to all possible destinations ("all-hosts broadcast"), which permits the sender to send the data only once, and all receivers receive a copy of it. In the IPv4 protocol, the address 255.255.255.255 is used for local broadcast. In addition, a directed (limited) broadcast can be made by combining the network prefix with a host suffix composed entirely of binary 1s. For example, the destination address used for directed broadcast to devices on the 192.0.2.0/24 network is 192.0.2.255
    multicast - address associated with a group of interested receivers. In IPv4, addresses 224.0.0.0 through 239.255.255.255 are designated as multicast addresses. The sender sends a single datagram from its unicast address to the multicast group address and the intermediary routers take care of making copies and sending them to all receivers that have joined the corresponding multicast group.

Private Address Range

The following IP address ranges are reserved (RFC 6890) for private addressing. These addresses are not routed in the global routing table and should be translated to global addresses with network address translation (NAT):

    10.0.0.0/8 - start: 10.0.0.0; end: 10.255.255.255
    172.16.0.0/12 - start: 172.16.0.0; end:172.31.255.255
    192.168.0.0/16 - start: 192.168.0.0; end: 192.168.255.255

Other Reserved Address Ranges

    198.18.0.0/15 - benchmarking
    192.88.99.0/24 - 6to4 relay anycast address range
    192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24 - documentation
    169.254.0.0/16 - auto-configuration address range

Adding IP Address

Consider a setup where two routers are directly connected with the cable and we do not want to waste address space:

R1 configuration:
/ip address
add address=10.1.1.1/32 interface=ether1 network=172.16.1.1

R2 configuration:
/ip address
add address=172.16.1.1/32 interface=ether1 network=10.1.1.1
IPv6 Addressing

Internet Protocol version 6 (IPv6) is the newer version of the Internet Protocol (IP). It was initially expected to replace IPv4 in a short enough time, but for now, it seems that these two versions will coexist on the Internet in foreseeable future. Nevertheless, IPv6 becomes more important, as the date of the unallocated IPv4 address pool's exhaustion approaches.

The two main benefits of IPv6 over IPv4 are:

    much larger address space;
    support of stateless and stateful address auto-configuration;
    built-in security;
    new header format (faster forwarding).

IPv6 uses 16 bytes addresses compared to 4-byte addresses in IPv4. IPv6 address syntax and types are described in RFC 4291.

There are multiple IPv6 address types, that can be recognized by their prefix. RouterOS distinguishes the following:

    multicast (with prefix ff00::/8)
    link-local (with prefix fe80::/10)
    unique local addresses (with prefix fc00::/7)
    loopback (the address::1/128)
    unspecified (the address::/128)
    other (all other addresses, including the obsoleted site-local addresses, and RFC 4193 unique local addresses; they all are treated as global unicast).


One difference between IPv6 and IPv4 addresses is that IPv6 automatically generates a link-local IPv6 address for each active interface that has IPv6 support.

IPv6 addresses are represented a little bit differently than IPv4 addresses. For IPv6, the 128-bit address is divided into eight 16-bit blocks, and each 16-bit block is converted to a 4-digit hexadecimal number and separated by colons. The resulting representation is called colon-hexadecimal.

In the example below IPv6 address in binary format is converted to a colon-hexadecimal representation
0010000000000001 0000010001110000 0001111100001001 0000000100110001
0000000000000000 0000000000000000 0000000000000000 0000000000001001
2001:0470:1f09:0131:0000:0000:0000:0009

The IPv6 address can be further simplified by removing leading zeros in each block:
2001:470:1f09:131:0:0:0:9

As you can see IPv6 addresses can have long sequences of zeros. This contiguous sequence can be compressed to ::
2001:470:1f09:131::9

Zero compression can only be used once. Otherwise, you could not determine the number of 0 bits represented by each instance of a double-colon


IPv6 prefix is written in address/prefix-length format. Compared to IPv4 decimal representation of a network mask cannot be used. Prefix examples:
2001:470:1f09:131::/64
2001:db8:1234::/48
2607:f580::/32
2000::/3
Address Types

Several IPv6 address types exist:

    Unicast
    Anycast
    Multicast

As you can see there are no Broadcast addresses in the IPv6 network, compared to the IPv4 broadcast functionality was completely replaced with multicast.
Unicast Addresses

Packets addressed to a unicast address are delivered only to a single interface. To this group belong:

    globally unique addresses and can be used to connect to addresses with global scope anywhere;
    link-local addresses;
    unique local addresses (ULA RFC4193)
    site-local addresses (FEC0::/48) - deprecated;
    special-purpose addresses;
    compatibility addresses;

A global unicast address can be automatically assigned to the node by Stateless Address auto-configuration.
Link-local Address

A link-local address is required on every IPv6-enabled interface, applications may rely on the existence of a link-local address even when there is no IPv6 routing, that is why the link-local address is generated automatically for every active interface using its interface identifier (calculated EUI-64 from MAC address if present). The address prefix is always FE80::/64 and IPv6 router never forwards link-local traffic beyond the link.

These addresses are comparable to the auto-configuration addresses 169.254.0.0/16 of IPv4.

A link-local address is also required for IPv6 Neighbor Discovery processes.

If the interface is set as a bridge port, an interface-specific link-local address is removed leaving only the bridge link-local address
Unique Local Address

Unique Local Address (ULA) is reserved for local use in the home and enterprise environments not routed in public address space and is equivalent to IPv4 private address ranges.

The reserved address range is fc00::/7


Special Purpose Address
Unspecified address (::/128)	Never assigned to an interface or used as a destination address, used only to indicate the absence of an address. Equivalent to IPv4 0.0.0.0 address.
loopback address (::1/128)	Used to identify a loopback interface, enabling a node to send packets to itself. It is equivalent to the IPv4 loopback address of 127.0.0.1.
2002::/16	This prefix is used for 6to4 addressing. Here, an address from the IPv4 network 192.88.99.0/24 is also used.
2001:db8::/32	Address range reserved for documentation. These should never be seen as the source or destination.
2001:0010::/28	Orchid fixed term experiment. Should not be seen as a source or destination
2001:0002::/48	Used for benchmarking, should not be seen as source or destination
2001:0000::/32	Teredo
Compatibility Address
IPv4 compatible address	used by dual-stack nodes that are communicating with IPv6 over an IPv4 infrastructure. When the IPv4-compatible address is used as an IPv6 destination, IPv6 traffic is automatically encapsulated with an IPv4 header and sent to the destination by using the IPv4 infrastructure. The address is written in the following format ::w.x.y.z, where w.x.y.z is the dotted decimal representation of a public IPv4 address.
IPv4 mapped address	used to represent an IPv4-only node to an IPv6 node. It is used only for internal representation. The IPv4-mapped address is never used as a source or destination address for an IPv6 packet. The IPv6 protocol does not support the use of IPv4-mapped addresses. The address is written in the following format: ::ffff:w.x.y.z, where w.x.y.z is the dotted-decimal representation of a public IPv4 address.
Multicast Address

The most important multicast aspects are:

    traffic is sent to a single address but is processed by multiple hosts;
    group membership is dynamic, allowing hosts to join and leave the group at any time;
    in IPv6, Multicast Listener Discovery (MLD) messages are used to determine group membership on a network segment, also known as a link or subnet;
    a host can send traffic to the group's address without belonging to the corresponding group.


A single IPv6 multicast address identifies each multicast group. Each group's reserved IPv6 address is shared by all host members of the group who listen and receive any IPv6 messages sent to the group's address.

The multicast address consists of the following parts:

    The first 8 bits in the multicast address are always 1111 1111 (which is FF in hexadecimal format).
    The flag uses the 9th to 12th bit and shows if this multicast address is predefined (well-known) or not. If it is well-known, all bits are 0s.
    Scope ID indicates to which scope multicast address belongs, for example, Scope ID=2 is link-local scope.
    The group ID is used to specify a multicast group. There are predefined group IDs, such as Group ID=1 - all nodes. Therefore, if the multicast address is ff02::1, that means Scope ID=2 and Group ID=1, indicating all nodes in link-local scope. This is analogous to broadcast on IPv4.


Here is the table of reserved IPV6 addresses for multicast:
FF02::1	The all-nodes address is used to reach all nodes on the same link.
FF02::2	The all-routers address is used to reach all routers on the same link.
FF02::5	The all-Open Shortest Path First (OSPF) router address is used to reach all OSPF routers on the same link.
FF02::6	The all-OSPF-designated router's address is used to reach all OSPF-designated routers on the same link.
FF02::1:FFXX:XXXX	The solicited-node address is used in the address resolution process to resolve the IPv6 address of a link-local node to its link-layer address. The last 24 bits (XX:XXXX) of the solicited-node address are the last 24 bits of an IPv6 unicast address.



The following table is a partial list of IPv6 multicast addresses that are reserved for IPv6 multicasting and registered with the Internet Assigned Numbers Authority (IANA). For a complete list of assigned addresses read IANA document.

Multicast addresses can be used to discover nodes in a network. For example, discover all nodes
mrz@bumba:/media/aaa/ver$ ping6 ff02::1%eth0
PING ff02::1%eth0(ff02::1) 56 data bytes
64 bytes from fe80::21a:4dff:fe5d:8e56: icmp_seq=1 ttl=64 time=0.037 ms
64 bytes from fe80::20c:42ff:fe0d:2c38: icmp_seq=1 ttl=64 time=4.03 ms (DUP!)
64 bytes from fe80::20c:42ff:fe28:7945: icmp_seq=1 ttl=64 time=5.59 ms (DUP!)
64 bytes from fe80::20c:42ff:fe49:fce5: icmp_seq=1 ttl=64 time=5.60 ms (DUP!)
64 bytes from fe80::20c:42ff:fe21:f1ec: icmp_seq=1 ttl=64 time=5.88 ms (DUP!)
64 bytes from fe80::20c:42ff:fe72:a1b0: icmp_seq=1 ttl=64 time=6.70 ms (DUP!)

discover all routers
mrz@bumba:/media/aaa/ver$ ping6 ff02::2%eth0
PING ff02::2%eth0(ff02::2) 56 data bytes
64 bytes from fe80::20c:42ff:fe28:7945: icmp_seq=1 ttl=64 time=0.672 ms
64 bytes from fe80::20c:42ff:fe0d:2c38: icmp_seq=1 ttl=64 time=1.44 ms (DUP!)

Anycast Address

An anycast address is a new type of address incorporated in IPv6.

Anycasting is a new networking paradigm supporting service-oriented Addresses where an identical address can be assigned to multiple nodes providing a specific service. An anycast packet (i.e., one with an anycast destination address) is delivered to one of these nodes with the same anycast address.

An anycast address is not assigned a specific address range. It is assigned from the unicast address range.
Interface Identifier

The last 64 bits of an IPv6 address are the interface identifier that is unique to the 64-bit prefix of the IPv6 address. There are several ways how to determine interface identifier:

    EUI-64;
    randomly generated to provide a level of anonymity;
    manually configured.

EUI-64

Traditional interface identifiers for network adapters are 48-bit MAC addresses. This address consists of a 24-bit manufacturer ID and a 24-bit board ID.

IEEE EUI-64 is a new standard for network interface addresses. The company ID is still 24 bits in length, but the extension ID is 40 bits, creating a much larger address space for network adapters.

To create a EUI-64 address from the interface MAC address:

    0xFFFE is inserted into the MAC address between the manufacturer ID and the board ID.
    The seventh bit of the first byte is reversed.


Let's make an example with the following MAC address 00:0C:42:28:79:45.

The image above illustrates the conversion process. When the result is converted to colon-hexadecimal notation, we get the interface identifier 20C:42FF:FE28:7945. As a result, the corresponding link-local address is
FE80::20C:42FF:FE28:7945/64

In RouterOS, if the EUI-64 parameter of an address is configured, the last 64 bits of that address will be automatically generated and updated using interface identifier. The last bits must be configured to be zero for this case. Example:
[admin@MikroTik] > ipv6 address add address=fc00:3::/64 interface=ether3 eui-64=yes
[admin@MikroTik] > ipv6 address print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
#    ADDRESS                                     INTERFACE                  ADVERTISE
...
5  G fc00:3::20c:42ff:fe1d:3d4/64                ether3                     yes
[admin@MikroTik] > interface ethernet set ether3 mac-address=10:00:00:00:00:01
[admin@MikroTik] > ipv6 address print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
#    ADDRESS                                     INTERFACE                  ADVERTISE
...
5  G fc00:3::1200:ff:fe00:1/64                   ether3                     yes
Configuring IPv6 Address

This example shows how to set up simple addressing with global IPv6 addresses between two routers.

R1 configuration:
/ipv6 address
add address=2001:DB8::1/64 interface=ether1 advertise=no

R2 configuration:
/ipv6 address
add address=2001:DB8::2/64 interface=ether1 advertise=no

Check the address list:
[admin@R1] /ipv6 address> print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
#    ADDRESS                                     FROM-POOL INTERFACE     ADVERTISE
0  G 2001:db8::1/64                                        ether1        no
3 DL fe80::219:d1ff:fe39:3535/64                           ether1        no


Notice that our added address has a G flag indicating that this address can be globally routed. We also have a link-local address on the interface which is created automatically for every IPv6-capable interface.

Test connectivity:
[admin@R1] /ipv6 address> /ping 2001:DB8::2
HOST                                     SIZE TTL TIME  STATUS
2001:db8::2                 56  64 12ms  echo reply
2001:db8::2                 56  64 0ms   echo reply
    sent=2 received=2 packet-loss=0% min-rtt=0ms avg-rtt=6ms max-rtt=12ms
SLAAC IPv6 Address

If under IPv6/Settings menu "accept-router-advertisements" option is enabled and the router receives a Router Advertisement packet, then the SLAAC IPv6 address will be automatically assigned to the interface on which the advertisements were received. This address will have DG flags meaning that the address is dynamic and global. Such addresses will show valid and lifetime parameters.
[admin@R1] /ipv6/address/print detail where dynamic && global 
Flags: X - disabled, I - invalid, D - dynamic; G - global, L - link-local 
 0 DG address=2001:db8::::ba69:f4ff:fe84:545/64 from-pool="" interface=ether1 
      actual-interface=test_fp eui-64=no advertise=no no-dad=no valid=4w2d 
      preferred=1w 

If SLAAC addresses are accepted, then also dynamic route toward the Internet will be generated. It will also contain a few limitations if specified on the advertisement packet. For example, hop-limit and MTU. If multiple addresses are received on the same interface, then the lowest of the MTU values per interface will be used.
[admin@R1] /routing/route/print detail where slaac 
Flags: X - disabled, F - filtered, U - unreachable, A - active; 
c - connect, s - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn, m - modem, a - ldp-address, l - ldp-mapping, g - slaac, y - bgp-mpls-vpn; 
H - hw-offloaded; + - ecmp, B - blackhole 
 Ag + afi=ip6 contribution=active dst-address=::/0 routing-table=main 
       pref-src="" gateway=fe80::ba69:f4ff:fe84:7b2%ether1
       immediate-gw=fe80::ba69:f4ff:fe84:7b2%ether1 distance=1 scope=30 
       target-scope=10 belongs-to="slaac" mtu=1400 hoplimit=10 
       debug.fwp-ptr=0x201C2C00 
Properties
address (Address/Netmask; Default: )	Ipv6 address. Allowed netmask range is 0..128. Address can also be constructed from the pool if from-pool property is specified.
For example if address is set to ::1/64 then address will be constructed as follows <prefix_from_pool>::1/64
advertise (yes | no; Default: no)	Whether to enable stateless address configuration. The prefix of that address is automatically advertised three times to hosts using ICMPv6 protocol. The option is set by default for addresses with prefix length 64. If address is removed or changed, then old prefix will be deprecated by automatically advertising the old prefix with lifetime set to "0s" three times to hosts using ICMPv6 protocol
comment comment (string; Default: )	Descriptive name of an item
disabled (yes | no; Default: no)	Whether address is disabled or not. By default it is not disabled
eui-64 (yes | no; Default: no)	Whether to calculate EUI-64 address and use it as last 64 bits of the IPv6 address. 
from-pool (string; Default: )	Name of the pool from which prefix will be taken to construct IPv6 address taking last part of the address from address property.
no-dad (yes | no; Default: no)	If enabled (yes) - disables Duplicate Address Detection (DAD) for IPv6 addresses on an interface. This can be useful in scenarios where you want to assign static IPv6 addresses to devices and avoid the delay caused by DAD.
interface (string; Default: )	Name of an interface on which Ipv6 address is set.
auto-link-local (yes | no; Default: yes)	If newly created address is manual link-local address this setting allows to override dynamically created IPv6 link-local address.
Read-only properties
actual-interface (string)	Actual interface on which address is set up. For example, if address was configured on ethernet interface and ethernet interface was added to bridge, then actual interface is bridge not ethernet.
dynamic (yes | no)	Whether address is dynamically created
global (yes | no)	Whether address is global
invalid (yes | no)	Whether address is invalid
link-local (yes | no)	Whether address is link local
deprecated (yes | no)	Whether address is deprecated
slave (yes | no)	Whether address belongs to an interface which is a slave port to some other master interface
Frequently asked questions

Q: Does RouterOS support NAT64?
A: No, currently NAT64 is not implemented in RouterOS






    Creado por Usuario desconocido (olga), actualizado por última vez por Gļebs K. el mar 10, 2025 9 min de lectura

    Summary
    Node description
    Stateless address autoconfiguration
        Address states
    Neighbor discovery
        Properties
    Prefix
        Properties
    Neighbors List
    Examples
        Stateless autoconfiguration example

Summary

Standards: RFC 2462, RFC 2461, RFC 4861

RouterOS has IPv6 Neighbor Discovery and stateless address autoconfiguration support using Router Advertisement Daemon (RADVD).
Node description

Node is a device that implements IPv6. In IPv6 networks nodes are divided into two types:

    Routers - a node that forwards IPv6 packets not explicitly addressed to itself.
    Hosts - any node that is not a router.

Routers and hosts are strictly separated, meaning that routers cannot be hosts and hosts cannot be routers at the same time.
Stateless address autoconfiguration

There are several types of autoconfiguration:

    stateless - address configuration is done by receiving Router Advertisement messages. These messages include stateless address prefixes and require that host is not using stateful address configuration protocol.
    stateful - address configuration is done by using the stateful address configuration protocol (DHCPv6). The stateful protocol is used if RA messages do not include address prefixes.
    both - RA messages include stateless address prefixes and require that hosts use a stateful address configuration protocol.

A highly useful feature of IPv6 is the ability to automatically configure itself without the use of a stateful configuration protocol like DHCP ( See example).

Address autoconfiguration can only be performed on multicast-capable interfaces.


It is called stateless address autoconfiguration since there is no need to manage the state on the router side. It is a very simple, robust, and effective autoconfiguration mechanism.

RouterOS uses RADVD to periodically advertise information about the link to all nodes on the same link. The information is carried by ICMPv6 "router advertisement" packet, and includes the following fields:

    IPv6 subnet prefix
    Default router link-local address
    Other parameters that may be optional: are link MTU, default hop limit, and router lifetime.

Then host catches the advertisement, and configures the global IPv6 address and the default router. Global IPv6 address is generated from the advertised subnet prefix and EUI-64 interface identifier.

Optionally, the host can ask for an advertisement from the router by sending an ICMPv6 "router solicitation" packet. On Linux rtsol utility transmits the router solicitation packet. If you are running a mobile node, you may want to transmit router solicitations periodically.
Address states

When an auto-configuration address is assigned it can be in one of the following states:

    tentative - in this state host verifies that the address is unique. Verification occurs through duplicate address detection.
    preferred - at this state address is verified as unique and the node can send and receive unicast traffic to and from a preferred address. The period of time of the preferred state is included in the RA message.
    deprecated - the address is still valid, but is not used for new connections.
    invalid - node can no longer send or receive unicast traffic. An address enters the invalid state after the valid lifetime expires.

The image above illustrates the relation between states and lifetimes. 
Neighbor discovery

Sub-menu: /ipv6 nd

In this submenu, IPv6 Neighbor Discovery (ND) protocol is configured.

Neighbor Discovery (ND) is a set of messages and processes that determine relationships between neighboring nodes. ND, compared to IPv4, replaces Address Resolution Protocol (ARP), Internet Control Message Protocol (ICMP) Router Discovery, and ICMP Redirect and provides additional functionality.

ND is used by hosts to:

    Discover neighboring routers.
    Discover addresses, address prefixes, and other configuration parameters.

ND is used by routers to:

    Advertise their presence, host configuration parameters, and on-link prefixes.
    Inform hosts of a better next-hop address to forward packets to a specific destination.

ND is used by nodes to:

    Both resolve the link-layer address of a neighboring node to which an IPv6 packet is being forwarded and determine when the link-layer address of a neighboring node has changed.
    Determine whether IPv6 packets can be sent to and received from a neighbor.

Properties
advertise-dns (yes | no; Default: yes)	Option to redistribute DNS server information using RADVD. You will need a running client-side software with Router Advertisement DNS support to take advantage of the advertised DNS information. Read more >>
advertise-mac-address (yes | no; Default: yes)	When set, the link-layer address of the outgoing interface is included in the RA.
comment (string; Default: )	Descriptive name of an item
dns-servers (unspecified | ipv6 addresses; Default: unspecified)	Specify a single IPv6 address or list of addresses that will be provided to hosts for DNS server configuration.
disabled (yes | no; Default: no)	Whether an item is disabled or not. By default, entry is enabled.
hop-limit (unspecified | integer[0..255]; Default: unspecified)	The default value that should be placed in the Hop Count field of the IP header for outgoing (unicast) IP packets.
interface (all | string; Default: )	The interface on which to run neighbor discovery.

    all - run ND on all running interfaces.

managed-address-configuration (yes | no; Default: no)	The flag indicates whether hosts should use stateful autoconfiguration (DHCPv6) to obtain addresses.
mtu (unspecified | integer[0..4294967295]; Default: unspecified)	The MTU option is used in router advertisement messages to ensure that all nodes on a link use the same MTU value in those cases where the link MTU is not well known.

    unspecified - do not send the MTU option.

other-configuration (yes | no; Default: no)	The flag indicates whether hosts should use stateful autoconfiguration to obtain additional information (excluding addresses).
pref64-prefixes (unspecified | ipv6 prefixes; Default: unspecified)	Specify IPv6 prefix or list of prefixes within /32, /40. /48, /56, /64, or /96 subnet that will be provided to hosts as NAT64 prefixes.
ra-delay (time; Default: 3s)	The minimum time allowed between sending multicast router advertisements from the interface.
ra-interval (time[3s..20m50s]-time[4s..30m]; Default: 3m20s-10m)	The min-max interval allowed between sending unsolicited multicast router advertisements from the interface.
ra-preference (low | medium | high; Default: medium)	Specify the router preference that is communicated to IPv6 hosts through router advertisements. The preference value in the router advertisements enables IPv6 hosts to select a default router to reach a remote destination
ra-lifetime (none | time; Default: 30m)	Sets the RA lifetime. A Lifetime of 0 indicates that the router is not a default router.(see Section 6.2.3 of RFC 4861)
reachable-time (unspecified | time[0..1h]; Default: unspecified)	The time that a node assumes a neighbor is reachable after having received a reachability confirmation. Used by the Neighbor Unreachability Detection algorithm (see Section 7.3 of RFC 2461)
retransmit-interval (unspecified | time; Default: unspecified)	The time between retransmitted Neighbor Solicitation messages. Used by address resolution and the Neighbor Unreachability Detection algorithm (see Sections 7.2 and 7.3 of RFC 2461)

If ND is automatically generated by LTE configuration, then the maximum lifetime for RA will be capped at 1 hour.
Prefix

Sub-menu: /ipv6 nd prefix

Prefix information sent in RA messages used by stateless address auto-configuration.

Note: The autoconfiguration process applies only to hosts and not routers.
Properties
6to4-interface (none | string; Default: )	If this option is specified, this prefix will be combined with the IPv4 address of the interface name to produce a valid 6to4 prefix. The first 16 bits of this prefix will be replaced by 2002 and the next 32 bits of this prefix will be replaced by the IPv4 address assigned to the interface name at configuration time. The remaining 80 bits of the prefix (including the SLA ID) will be advertised as specified in the configuration file.
autonomous (yes | no; Default: yes)	When set, indicates that this prefix can be used for autonomous address configuration. Otherwise, prefix information is silently ignored.
comment (string; Default: )	Descriptive name of an item
disabled (yes | no; Default: no)	Whether an item is disabled or not. By default, entry is enabled.
on-link (yes | no; Default: yes)	When set, indicates that this prefix can be used for on-link determination. When not set the advertisement makes no statement about the on-link or off-link properties of the prefix. For instance, the prefix might be used for address configuration with some of the addresses belonging to the prefix being on-link and others being off-link.
preferred-lifetime (infinity | time; Default: 1w)	Timeframe (relative to the time the packet is sent) after which generated address becomes "deprecated". Deprecated is used only for already existing connections and is usable until valid lifetime expires. Read more >>
prefix (ipv6 prefix; Default: ::/64)	A prefix from which stateless address autoconfiguration generates the valid address.
valid-lifetime (infinity | time; Default: 4w2d)	The length of time (relative to the time the packet is sent) an address remains in the valid state. The valid lifetime must be greater than or equal to the preferred lifetime. Read more >>
interface (string; Default: )	Interface name on which stateless auto-configuration will be running.
Neighbors List

Sub-menu: /ipv6 neighbor

List of all discovered nodes by IPv6 neighbor discovery protocol (neighbor cache) or manually added by configuration.
address (ipv6 address; Default: )	IPv6 address of the neighbour.
interface (string; Default: )	interface name to which this neighbour is attached.
mac-address (MAC; Default: 00:00:00:00:00:00)	MAC address of the device to be added.

Read-only Properties
address (ipv6 address)	IPv6 address of the node.
interface (string)	The interface on which the node was detected.
mac-address (string)	Mac address of the discovered node.
router (yes | no)	Whether the discovered node is a router
status (noarp | incomplete | stale | reachable | delay | probe | failed)	Status of the cached entry:

    noarp - the neighbor entry is valid. No attempts to validate this entry will be made but it can be removed when its lifetime expires

    incomplete - address resolution is in progress and the link-layer address of the neighbor has not yet been determined;

    reachable - the neighbor is known to have been reachable recently (within tens of seconds ago);

    stale - the neighbor is no longer known to be reachable but until traffic is sent to the neighbor, no attempt should be made to verify its reachability;

    delay - the neighbor is no longer known to be reachable, and traffic has recently been sent to the neighbor, probes are delayed for a short period in order to give upper layer protocol a chance to provide reachability confirmation;

    probe - the neighbor is no longer known to be reachable, and unicast Neighbor Solicitation probes are being sent to verify reachability.
    failed - the router was unable to resolve the neighbor’s MAC address using neighbor discovery protocol.

The default maximum number of neighbor entries depends on the installed amount of RAM. It can be adjusted with the command "/ipv6 settings set max-neighbor-entries=x", see more details on IPv6 Settings.
Examples
Stateless autoconfiguration example


[admin@MikroTik] > ipv6 address print
Flags: X - disabled, I - invalid, D - dynamic, G - global, L - link-local
# ADDRESS INTERFACE ADVERTISE
0 G 2001:db8::1/64 ether1 yes

As an example, the advertise flag is enabled which indicates that dynamic/ipv6 nd prefixentry is added.


[admin@MikroTik] > ipv6 nd prefix print 
Flags: X - disabled, I - invalid, D - dynamic 
0 D prefix=2001:db8::/64 interface=ether1 on-link=yes autonomous=yes
 valid-lifetime=4w2d preferred-lifetime=1w


On a host that is directly attached to the router, we see that an address was added. The address consists of the prefix part (first 64 bits) that takes the prefix from the prefix advertisement, and the host part (last 64 bits) that is automatically generated from the local MAC address:
atis@atis-desktop:~$ ip -6 addr
 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 
inet6 ::1/128 scope host 
valid_lft forever preferred_lft forever 
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qlen 1000 
inet6 2001:db8::21a:4dff:fe56:1f4d/64 scope global dynamic
 valid_lft 2588363sec preferred_lft 601163sec 
inet6 fe80::21a:4dff:fe56:1f4d/64 scope link 
valid_lft forever preferred_lft forever


The host has received the 2001:db8::/64 prefix from the router and configured an address with it.

There is also an option to redistribute DNS server information using RADVD:


[admin@MikroTik] > ip dns set server=2001:db8::2 
[admin@MikroTik] > ip dns print servers: 2001:db8::2
 ... 
[admin@MikroTik] > ipv6 nd set [f] advertise-dns=yes


You will need a running client-side software with Router Advertisement DNS support to take advantage of the advertised DNS information.

On Ubuntu/Debian Linux distributions you can install rdnssd package which is capable of receiving the advertised DNS addresses.
mrz@bumba:/$ sudo apt-get install rdnssd


mrz@bumba:/$ cat /etc/resolv.conf 
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
 # DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
 nameserver 2001:db8::2 

mrz@bumba:/$ ping6 www.mikrotik.com 
PING www.mikrotik.com(2a02:610:7501:1000::2) 56 data bytes
 64 bytes from 2a02:610:7501:1000::2: icmp_seq=1 ttl=61 time=2.11 ms
 64 bytes from 2a02:610:7501:1000::2: icmp_seq=2 ttl=61 time=1.33 ms 
^C
 --- www.mikrotik.com ping statistics --- 
2 packets transmitted, 2 received, 0% packet loss, time 1001ms 
rtt min/avg/max/mdev = 1.334/1.725/2.117/0.393 ms 
mrz@bumba:/$




    Creado por Usuario desconocido (emils), actualizado por última vez por GG el feb 28, 2024 2 min de lectura

    Summary
    IPv4 Pool
        Example
        Used addresses
    IPv6 Pool
        Example
        Used addresses

Summary

IP pools are used to define range of IP addresses that can be used by various RouterOS utilities, for example, DHCP server, Point-to-Point servers and more. Separate lists for IPv4 and IPv6 are available. Whenever possible, the same IP address is given out to each client (OWNER/INFO pair).
IPv4 Pool

Sub-menu: /ip pool
comment (string; Default: )	Short description of the pool

name (string; Default: )
	Unique identifier of the pool
next-pool (string; Default: )	When IP address acquisition is performed a pool that has no free addresses, and the next-pool property is set, then IP address will be acquired from next-pool
ranges (IP; Default: )	IP address list of non-overlapping IP address ranges in the form of: from1-to1,from2-to2,...,fromN-toN. For example, 10.0.0.1-10.0.0.27,10.0.0.32-10.0.0.47
Example

To define a pool named "my-pool" with the 10.0.0.1-10.0.0.126 address range excluding gateway's address 10.0.0.1 and server's address 10.0.0.100, and the other pool dhcp-pool, with the 10.0.0.200-10.0.0.250 address range:
[admin@MikroTik] ip pool> add name=my-pool ranges=10.0.0.2-10.0.0.99,10.0.0.101-10.0.0.126
[admin@MikroTik] ip pool> add name=dhcp-pool ranges=10.0.0.200-10.0.0.250
[admin@MikroTik] ip pool> print
  # NAME                                        RANGES
  0 ip-pool                                     10.0.0.2-10.0.0.99
                                                10.0.0.101-10.0.0.126
  1 dhcp-pool                                   10.0.0.200-10.0.0.250
Used addresses

Sub-menu: /ip pool used

Here you can see all used IP addresses from IP pools.


Read-only properties
address (IP)	IP address that is assigned to client from the pool

info (string)
	For DHCP MAC address from leases menu and for PPP connections username of PPP type client
owner (string)	Service which is using this IP address
pool (string)	

Name of the IP pool
IPv6 Pool

Sub-menu: /ipv6 pool


name (string; Default: )	Descriptive name of the pool.
prefix (IPv6/0..128; Default: )	Ipv6 address prefix
prefix-length (integer [1..128]; Default: )	The option represents the prefix size that will be given out to the client.

Read-only properties
dynamic (yes | no)	Whether the pool is dynamic.
expire-time (time)	Expire time is set to dynamic pools added by DHCPv6 client.
Example

The example will create a pool of "2001::/60" to give out /62 prefixes:
[admin@test-host] /ipv6 pool> add
name: test prefix: 2001::/60
prefix-length: 62
[admin@test-host] /ipv6 pool> print
# NAME PREFIX PREFIX-LENGTH
0 test 2001::/60 62bits
Used addresses

Sub-menu: /ipv6 pool used

Read-only properties
info (string)	Shows DUID related information received from the client (value in hex). Can contain also a raw timestamp in hex.
owner (string)	What reserved the prefix ("DHCP", etc.)
pool (string)	Name of the pool.
prefix (IPv6/0..128)	IPv6 prefix that is assigned to the client from the pool.





    Creado por Normunds R., actualizado por última vez por Māris B. el jul 21, 2024 15 min de lectura

    Overview
    How Routing Works
    Routing Information
        Routing Information Base
            Connected Routes
            Default Route
            Hardware Offloaded Route
            Multipath (ECMP) routes
            Route Selection
            Nexthop Lookup
            Route Storage
        Forwarding Information Base
            Routing table lookup
    Show Routes

Overview

Routing is the process of selecting paths across the networks to move packets from one host to another. 
How Routing Works

Let's look at a basic configuration example to illustrate how routing is used to forward packets between two local networks and to the Internet.

In this setup, we have several networks:

    two client networks (192.168.2.0/24 and 192.168.1.0/24);
    one network to connect routers (172.16.1.0/30), usually called backbone;
    the last network (10.1.1.0/24) connects our gateway router (Router1) to the internet. 


 Router 2:
/ip address
add address=172.16.1.2/30 interface=ether1
add address=192.168.2.1/24 interface=bridge2


Router1 (gateway) where ether1 connects to the internet:
/ip address
add address=10.1.1.2/24 interface=ether1
add address=172.16.1.1/30 interface=ether2
add address=192.168.1.1/24 interface=bridge1

If we look, for example, at the Router1 routing table, we can see that the router knows only about directly connected networks. At this point, when the Client from LAN1 tries to reach the client from LAN2 (192.168.2.0/24), a packet will be dropped on the router, because the destination is unknown for the particular router:
[admin@MikroTik] > /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - static, r - ri
p, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY, Distance
    DST-ADDRESS    GATEWAY D
DAC 10.1.1.0/24    ether1  0
DAC 172.16.1.0/30  ether2  0
DAC 192.168.1.0/24 bridge1 0

To fix this we need to add a route that tells the router what is the next device in the network to reach the destination.  In our example next hop is Router2, so we need to add a route with the gateway that points to the Router's 2 connected address. This type of route is known as a static route:
[admin@MikroTik] > /ip route add dst-address=192.168.2.0/24 gateway=172.16.1.2
[admin@MikroTik] > /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - static, r - ri
p, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY,       Distance
        DST-ADDRESS    GATEWAY       D
    DAC 10.1.1.0/24    ether1        0
    DAC 172.16.1.0/30  ether2        0
    DAC 192.168.1.0/24 bridge1       0
0   AS  192.168.2.0/24 172.16.1.2    

At this point packet from LAN1 will be successfully forwarded to LAN2, but we are not over yet. Router2 does not know how to reach LAN1, so any packet from LAN2 will be dropped on Router2.

If we look again at the network diagram, we can clearly see that Router2 has only one point of exit. It is safe to assume that all other unknown networks should be reached over the link to Router1. The easiest way to do this is by adding a default route: To add a default route set destination 0.0.0.0/0 or leave it blank:
/ip route add gateway=172.16.1.1

As we have seen from the example setup, there are different groups of routes, based on their origin and properties.
Routing Information

RouterOS routing information consists of two main parts:

    FIB (Forwarding Information Base), is used to make packet forwarding decisions. It contains a copy of the necessary routing information.
    RIB (Routing Information Base) contains all learned prefixes from routing protocols (connected, static, BGP, RIP, OSPF).



Routing Information Base

Routing Information Base is a database that lists entries for particular network destinations and their gateways (address of the next device along the path or simply next-hop). One such entry in the routing table is called a route.

A hop occurs when a packet is passed from one network segment to another.

By default, all routes are organized in one "main" routing table. It is possible to make more than one routing table which we will discuss further in this article, but for now, for sake of simplicity, we will consider that there is only one "main" routing table.

RIB table contains complete routing information, including static routes and policy routing rules configured by the user, routing information learned from dynamic routing protocols (RIP, OSPF, BGP), and information about connected networks.

Its purpose is not just to store routes, but also to filter routing information to calculate the best route for each destination prefix, to build and update the Forwarding Information Base, and to distribute routes between different routing protocols.
Connected Routes

Connected routes represent the network on which hosts can be directly reached (direct attachment to Layer2 broadcast domain). These routes are created automatically for each IP network that has at least one enabled interface attached to it (as specified in the /ip address or /ipv6 address configuration). RIB tracks the status of connected routes but does not modify them. For each connected route there is one IP address item such that:

    address part of the dst-address of the connected route is equal to a network of IP address item.
    netmask part of dst-address of the connected route is equal to the netmask part of the address of the IP address item.
    gateway of the connected route is equal to the actual-interface of the IP address item (same as an interface, except for bridge interface ports) and represents an interface where directly connected hosts from the particular Layer3 network can be reached.

The preferred source is not used anymore for connected routes. FIB chooses the source address based on the out-interface. This allows making setups that in ROS v6 and older were considered invalid. See examples for more details.
Default Route

A default route is used when the destination cannot be resolved by any other route in the routing table. In RouterOS dst-address of the default route is 0.0.0.0/0 (for IPv4) and ::/0 (for IPv6) routes. If the routing table contains an active default route, then the routing table lookup in this table will never fail.

Typically home router routing table contains only connected networks and one default route to forward all outgoing traffic to the ISP's gateway:
[admin@TempTest] /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - static, r - ri
p, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY, Distance
#      DST-ADDRESS     GATEWAY      D
   DAd 0.0.0.0/0       10.155.125.1 1
   DAC 10.155.125.0/24 ether12      0
   DAC 192.168.1.0/24  vlan2        0
Hardware Offloaded Route

Devices with Layer 3 Hardware Offloading (L3HW, otherwise known as IP switching or HW routing) allow offloading packet routing onto the switch chip. When L3HW is enabled, such routes will display H-flag:
[admin@MikroTik] > /ip/route print where static
Flags: A - ACTIVE; s - STATIC, y - COPY; H - HW-OFFLOADED
Columns: DST-ADDRESS, GATEWAY, DISTANCE
#     DST-ADDRESS       GATEWAY         D
0 AsH 0.0.0.0/0         172.16.2.1      1
1 AsH 10.0.0.0/8        10.155.121.254  1
2 AsH 192.168.3.0/24    172.16.2.1      1

By default, all the routes are participating to be hardware candidate routes. To further fine-tune which traffic to offload, there is an option for each IP or IPv6 static route to disable/enable suppress-hw-offload. 

For example, if we know that the majority of traffic flows to the network where servers are located, we can enable offloading only to that specific destination:
/ip route set [find where static && dst-address!="192.168.3.0/24"] suppress-hw-offload=yes

Now only the route to 192.168.3.0/24 has an H-flag, indicating that it will be the only one eligible to be selected for HW offloading:
[admin@MikroTik] > /ip/route print where static
Flags: A - ACTIVE; s - STATIC, y - COPY; H - HW-OFFLOADED
Columns: DST-ADDRESS, GATEWAY, DISTANCE
#     DST-ADDRESS       GATEWAY         D
0 As  0.0.0.0/0         172.16.2.1      1
1 As  10.0.0.0/8        10.155.121.254  1
2 AsH 192.168.3.0/24    172.16.2.1      1

H-flag does not indicate that the route is actually HW offloaded, it indicates only that route can be selected to be HW offloaded.
Multipath (ECMP) routes

To implement some setups, such as load balancing, it might be necessary to use more than one path to a given destination.


ECMP (Equal cost multi-path) routes have multiple gateways (next-hop) values. All reachable next-hops are copied to FIB and are used to forward packets.

These routes can be created manually, as well as dynamically by any of the dynamic routing protocols (OSPF, BGP, RIP). Multiple equally preferred routes to the same destination will have assigned + flag and grouped together automatically by RouterOS (see example below).
[admin@TempTest] /ip/route> print 
Flags: D - DYNAMIC; I - INACTIVE, A - ACTIVE; C - CONNECT, S - STATIC, m - MODEM; + - ECMP
Columns: DST-ADDRESS, GATEWAY, DISTANCE
#       DST-ADDRESS      GATEWAY       D
0   AS+ 192.168.2.0/24   10.155.125.1  1
1   AS+ 192.168.2.0/24   172.16.1.2    1

By default, ECMP uses Layer3 hash policy which hashes source IP and destination IP (for IPv4) or source IP, destination IP, flow label and IP protocol (for IPv6).

It is possible to change hashing policies in /ip/setting and /ipv6/settings to Layer4 hashing or inner Layer3 hashing.
L3	

srcIPv4, dstIPv4
	srcIPv6, dstIPv6, flow label, IP proto
L4	srcIPv4, dstIPv4, srcPort, dstPort, IP proto	srcIPv6, dstIPv6, srcPort, dstPort, IP Proto
L3-Inner	

    srcIPv4, dstIPv4 (if inner IPv4)
    srcIPv6, dstIPv6, flow label, IP proto (if inner IPv6)
    Same as L3 if inner is not present.

	

    srcIPv4, dstIPv4 (if inner IPv4)
    srcIPv6, dstIPv6, flow label, IP proto (if inner IPv6)
    Same as L3 if inner is not present.


Route Selection

There can be multiple routes with the same destination received from various routing protocols and from static configurations but only one (best) destination can be used for packet forwarding. To determine the best path, RIB runs a Route Selection algorithm that picks the best route from all candidate routes per destination.

Only routes that meet the following criteria can participate in the route selection process:

    Route is not disabled.
    If the type of route is unicast it must have at least one reachable next-hop. ( if a gateway is from a connected network and there is a connected route active, the gateway is considered as reachable) 
    Route should not be synthetic.


The candidate route with the lowest distance becomes an active route. If there is more than one candidate route with the same distance, the selection of the active route is arbitrary.
Nexthop Lookup


Nexthop lookup is a part of the route selection process. Its main purpose is to find a directly reachable gateway address (next-hop). Only after a valid next-hop is selected router knows which interface to use for packet forwarding.


Nexthop lookup becomes more complicated if routes have a gateway address that is several hops away from this router (e.g. iBGP, multihop eBGP). Such routes are installed in the FIB after the next-hop selection algorithm determines the address of the directly reachable gateway (immediate next-hop).


It is necessary to restrict the set of routes that can be used to look up immediate next-hops. Nexthop values of RIP or OSPF routes, for example, are supposed to be directly reachable and should be looked up only using connected routes. This is achieved using scope and target-scope properties.

Routes with a scope greater than the maximum accepted value are not used for next-hop lookup. Each route specifies the maximum accepted scope value for its nexthop in the target-scope property. The default value of this property allows nexthop lookup only through connected routes, with the exception of iBGP routes that have a larger default value and can lookup nexthop also through IGP and static routes.

There are changes in RouterOS v7 nexthop lookup.

Routes are processed in scope order, and updates to routes with a larger scope cannot affect the state of nexthop lookup for routes with a smaller scope.

Consider an example from v6:
/ip route add dst-address=10.0.1.0/24 gateway=10.0.0.1
    scope=50 target-scope=30 comment=A
/ip route add dst-address=10.0.2.0/24 gateway=10.0.0.1
    scope=30 target-scope=20 comment=B
/ip route add dst-address=10.0.0.0/24 scope=20 gateway=WHATEVER
    comment=C

Gateway 10.0.0.1 is recursively resolved through C using the smallest referring scope (scope 20 from route B), both routes are active. Now we change both A and B at the same time:
/ip route set A target-scope=10

Suddenly, applying an update to route A makes the gateway of route B inactive. This is because in v6 there is only one gateway object per address.

v7 keeps multiple gateway objects per address, one for each combination of scope and gateway check.

When target-scope or gateway check of a route is changed, ROS v7 will not affect other routes, as it does in v6. In v7 target-scope and gateway check are properties that are internally attached to the gateway, not to the route.

Scope values considered as invalid and fixed automatically:

    if gateway scope is set to 255 - RouterOS will internally fix this error by setting gateway scope to 254.
    if route scope is less than gateway scope - RouterOS will internally fix this error by setting route scope to "gateway scope + 1"

Used actual scope and target scope values can be seen in /routing/nexthop menu

Gateway check can be extended by setting check-gateway parameter. Gateway reachability can be checked by sending ARP probes, or ICMP messages or by checking active BFD sessions. The router periodically (every 10 seconds) checks the gateway by sending either an ICMP echo request (ping) or an ARP request (arp). If no response from the gateway is received for 10 seconds, the request times out. After two timeouts gateway is considered unreachable. After receiving a reply from the gateway it is considered reachable and the timeout counter is reset.


Route Storage

Routing information is stored to take as little memory as possible in a common case. These optimizations have non-obvious worst cases and impact on performance.

All routes and gateways are kept in a single hierarchy by the prefix/address.

    Dst [4]/0 1/0+4                             18  <-- number of prefixes
         ^  ^ ^ ^ ^
         |  | | | |
         |  | | | \- bytes taken by Route distinguisher or Interface Id
         |  | | \--- vrf/routing table
         |  | \----- AFI
         |  \------- netmask length of prefix
         \---------- bytes taken by prefix value

         [subject to change without notice]
    

Each of these 'Dst' corresponds to a unique 'dst-address' of route or address of the gateway. Each 'Dst' requires one or more 'T2Node' objects as well.

All routes with the same 'dst-address' are kept in Dst in a list sorted by route preference.
Note: WORST CASE: having a lot of routes with the same 'dst-address' is really slow! even if they are inactive! because updating a sorted list with tens of thousands of elements is slow!

Route order changes only when route attributes change. If the route becomes active/inactive, the order does not change.

Each Route has three copies of route attributes:

    private -- what is received from the peer, before passing in-filters.
    updated -- what is the result of applying in-filters.
    current -- what are the attributes currently used by the route.


Periodically (when needed), update attributes are calculated from private attributes. This happens when route update is received, or when in-filter is updated.

When the routing table is recalculated, current attributes are set to the value from updated attributes.

This means, that usually if there is no in-filter that changes route attributes, private, updated, and current share the same value.

Route attributes are kept in several groups:

    L1 Data - all flags, list of extra properties, as-path;
    L2 Data - nexthops, RIP, OSPF, BGP metrics, route tags, originators, etc.
    L3 Data - distance, scope, kernel type, MPLS stuff
    extra properties - communities, originator, aggregator-id, cluster-list, unknown


Having for example many different combinations of distance and scope route attributes will use more memory!

Matching communities or as-path using regexp will cache the result, to speed up filtering. Each as-path or community value has a cache for all regexp, which is filled on-demand with match results.
Note: WORST CASE: changing attributes in 'in-filter' will make the route program use more memory! Because 'private' and 'updated' attributes will be different! Having a lot of different regexps will make matching slow and use a lot of memory! Because each value will have a cache with thousands of entries!

Detailed info about used memory by routing protocols can be seen in /routing stats memory menu
Forwarding Information Base

FIB (Forwarding Information Base) contains a copy of the information that is necessary for packet forwarding:

    all active routes
    policy routing rules


Each route has dst-address property, that specifies all destination addresses this route can be used for. If several routes apply to a particular IP address, the most specific one (with the largest netmask) is used. This operation (finding the most specific route that matches the given address) is called ''routing table lookup''.

Only one Best route can be used for packet forwarding. In cases where the routing table contains several routes with the same dst-address, all equally best routes are combined into one ECMP route. The best route is installed into FIB and marked as ''active''.

When forwarding decision uses additional information, such as the source address of the packet, it is called policy routing. Policy routing is implemented as a list of policy routing rules, that select different routing tables based on the destination address, source address, source interface, and routing mark (which can be changed by firewall mangle rules) of the packet.
Routing table lookup

FIB uses the following information from the packet to determine its destination:

    source address
    destination address
    source interface
    routing mark


Possible routing decisions are:

    receive packet locally
    discard the packet (either silently or by sending an ICMP message to the sender of the packet)
    send the packet to a specific IP address on a specific interface


Run routing decision:

    check that the packet has to be locally delivered (the destination address is the address of the router)
    process implicit policy routing rules
    process policy routing rules added by a user
    process implicit catch-all rule that looks up the destination in the ''main'' routing table
    the returned result is "network unreachable"


The result of the routing decision can be:

    IP address of nexthop + interface
    point-to-point interface
    local delivery
    discard
    ICMP prohibited
    ICMP host unreachable
    ICMP network unreachable


Rules that do not match the current packet are ignored. If a rule has action:

    drop or unreachable, then it is returned as a result of the routing decision process.
    lookup then the destination address of the packet is looked up in the routing table that is specified in the rule. If the lookup fails (no route matches the destination address of the packet), then FIB proceeds to the next rule.
    lookup-only is similar to lookup except that lookup fails if none of the routes in the table matches the packet.

Otherwise:

    if the type of the route is blackhole, prohibit, or unreachable, then return this action as the routing decision result;
    if this is a connected route or route with an interface as the gateway value, then return this interface and the destination address of the packet as the routing decision result;
    if this route has an IP address as the value of the gateway, then return this address and associated interface as the routing decision result;
    if this route has multiple values of nexthop, then pick one of them in a round-robin fashion.


Show Routes

In RouterOS you have three menus to see the current state of routes in the routing table:

    /ip route - list IPv4 routes and basic properties
    /ipv6 route - list IPv6 routes and basic properties
    /routing route - list all routes with extended properties

/routing route menu currently is read-only. To add or remove routes/ip(ipv6) route menus should be used.


Example output
[admin@MikroTik] /ip/route> print
Flags: D - dynamic; X - disabled, I - inactive, A - active; C - connect, S - stati
c, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn
Columns: DST-ADDRESS, GATEWAY, DIstance
#       DST-ADDRESS      GATEWAY      DI
0   XS   10.155.101.0/24  1.1.1.10 
1   XS                    11.11.11.10 
   D d   0.0.0.0/0        10.155.101.1 10
2   AS   0.0.0.0/0        10.155.101.1 1
3   AS + 1.1.1.0/24       10.155.101.1 10
4   AS + 1.1.1.0/24       10.155.101.2 10
5   AS   8.8.8.8          2.2.2.2      1
   DAC   10.155.101.0/24  ether12      0


|  ||| |   |                 |         |
|  ||| |   |                 |         \----Distance
|  ||| |   |                 \--Configured gateway
|  ||| |   \-- dst prefix
|  ||| \----- ECMP flag
|  ||\------- flag indicating which protocol have added the route (bgp, osf,static,connected etc.)
|  |\-------- route status flag (active, inactive, disabled)
|  \--------- shows if route is dynamic
\----------- console order number (shown only for static editable routes)
    

routing route output is very similar to ip route except that it shows routes from all address families in one menu and lists filtered routes as well.
[admin@MikroTik] /routing/route> print
Flags: X - disabled, I - inactive, F - filtered, U - unreachable, A - active; c - connect, s - static, 
r - rip, b - bgp, o - ospf, d - dhcp, v - vpn, a - ldp-address, l - ldp-mapping
Columns: DST-ADDRESS, GATEWAY, DIStance, SCOpe, TARget-scope, IMMEDIATE-GW
     DST-ADDRESS            GATEWAY      DIS SCO TAR IMMEDIATE-GW 
Xs   10.155.101.0/24 
Xs 
d    0.0.0.0/0              10.155.101.1 10  30  10  10.155.101.1%ether12
As   0.0.0.0/0              10.155.101.1 1   30  10  10.155.101.1%ether12
As   1.1.1.0/24             10.155.101.1 10  30  10  10.155.101.1%ether12
As   8.8.8.8                2.2.2.2      1   254 254 10.155.101.1%ether12
Ac   10.155.101.0/24        ether12      0   10      ether12 
Ic   2001:db8:2::/64        ether2       0   10 
Io   2001:db8:3::/64        ether12      110 20  10 
Ic   fe80::%ether2/64       ether2       0   10 
Ac   fe80::%ether12/64      ether12      0   10      ether12 
Ac   fe80::%bridge-main/64  bridge-main  0   10      bridge-main 
A    ether12                             0   250 
A    bridge-main                         0   250 
    

routing route print detail shows more advanced info useful for debugging
[admin@MikroTik] /routing route> print detail
Flags: X - disabled, I - inactive, F - filtered, U - unreachable, A - active;
c - connect, s - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn, a - ldp-address, l - ldp-ma>
+ - ecmp
Xs dst-address=10.155.101.0/24
Xs
d afi=ip4 contribution=best-candidate dst-address=0.0.0.0/0 gateway=10.155.101.1
immediate-gw=10.155.101.1%ether12 distance=10 scope=30 target-scope=10
belongs-to="DHCP route" mpls.in-label=0 .out-label=0 debug.fwp-ptr=0x201C2000

As afi=ip4 contribution=active dst-address=0.0.0.0/0 gateway=10.155.101.1
immediate-gw=10.155.101.1%ether12 distance=1 scope=30 target-scope=10
belongs-to="Static route" mpls.in-label=0 .out-label=0 debug.fwp-ptr=0x201C2000




    Creado por Edgars P., actualizado por última vez por Rihards Vārna el feb 03, 2025 5 min de lectura

    Summary
    IPv4 Settings
    IPv6 Settings

Summary

Several IPv4 and IPv6 related kernel and system-wide parameters are configurable.
IPv4 Settings

Sub-menu: /ip settings
accept-redirects (yes | no; Default: no)	Whether to accept ICMP redirect messages. Typically should be enabled on a host and disabled on routers.
accept-source-route (yes | no; Default: no)	Whether to accept packets with the SRR option. Typically should be enabled on the router.
allow-fast-path (yes | no; Default: yes)	Allows Fast Path.
arp-timeout (time interval; Default: 30s)	Sets Linux base_reachable_time (base_reachable_time_ms) on all interfaces that use ARP. The initial validity of the ARP entry is picked from the interval [timeout/2 - 3*timeout/2] (default from 15s to 45s) after the neighbor was found. Can use postfix ms, s, m, h, d for milliseconds, seconds, minutes, hours, or days. if no postfix is set then seconds (s) are used. The parameter means how long a valid ARP record will be considered complete if no one communicates with the specific MAC/IP during this time. The parameter does not represent a time when an ARP entry is removed from the ARP cache (see max-neighbor-entries setting).
icmp-errors-use-inbound-interface-address (yes | no; Default: no)	If enabled, the ICMP error message reply will be sent with the source address equal to primary address of the receiving interface that caused the error . This feature can be useful for complex network debugging.
icmp-rate-limit (integer [0..4294967295]; Default: 10)	Limit the maximum rates for sending ICMP packets whose type matches icmp-rate-mask to specific targets. 0 disables any limiting, other values indicate the minimum space between responses in milliseconds.
icmp-rate-mask ([0..FFFFFFFF]; Default: 0x1818)	Mask made of ICMP types for which rates are being limited. More info in Linux man pages
ip-forward (yes | no; Default: yes)	Enable/disable packet forwarding between interfaces. Resets all configuration parameters to defaults according to RFC1812 for routers.
ipv4-multipath-hash-policy(l3 | l4 | l3-inner; Default: l3)	

IPv4 Hash policy used for ECMP routing in /ip/settings menu

    l3 -- layer-3 hashing of src IP, dst IP
    l3-inner -- layer-3 hashing or inner layer-3 hashing if available
    l4 -- layer-4 hashing of src IP, dst IP, IP protocol, src port, dst port

rp-filter (loose | no | strict; Default: no)	Disables or enables source validation.

    no - No source validation.
    strict - Strict mode as defined in RFC3704 Strict Reverse Path. Each incoming packet is tested against the FIB and if the interface is not the best reverse path the packet check will fail. By default failed packets are discarded.
    loose - Loose mode as defined in RFC3704 Loose Reverse Path. Each incoming packet's source address is also tested against the FIB and if the source address is not reachable via any interface the packet check will fail.

The current recommended practice in RFC3704 is to enable strict mode to prevent IP spoofing from DDoS attacks. If using asymmetric routing or other complicated routing or VRRP, then the loose mode is recommended.

Warning: strict mode does not work with routing tables
secure-redirects (yes | no; Default: yes)	Accept ICMP redirect messages only for gateways, listed in the default gateway list.
send-redirects (yes | no; Default: yes)	Whether to send ICMP redirects. Recommended to be enabled on routers.

tcp-timestamps (disabled | enabled | random-offset; Default: random-offset)
	Parameter allows to enable/disable TCP timestamps or add random offset to TCP timestamp (default behavior). Disabling timestamps completely may help to reduce spikes of performance drops.
tcp-syncookies (yes | no; Default: no)	Send out syncookies when the syn backlog queue of a socket overflows. This is to prevent the common 'SYN flood attack'. syncookies seriously violate TCP protocol, and disallow the use of TCP extensions, which can result in serious degradation of some services (f.e. SMTP relaying), visible not by you, but to your clients and relays, contacting you.
max-neighbor-entries (integer [0..4294967295]; Default: )	

Sets Linux gc_thresh3. A maximum number of allowed neighbors in the ARP table. Since RouterOS version 7.1, the default value depends on the installed amount of RAM. It is possible to set a higher value than the default, but it increases the risk of out-of-memory condition.

The default values for certain RAM sizes:

    2048 for 64 MB,
    4096 for 128 MB,
    8192 for 256 MB,
    16384 for 512 MB or higher.

The ARP cache stores ARP entries, and if some of these entries are incomplete, they can stay in the cache for an indefinite period of time. This will only happen if the number of entries in the cache is less than one-fourth of the maximum number allowed. The reason for this is to prevent the unnecessary running of the garbage-collector when the ARP table is not close to being full.
route-cache (yes | no; Default: yes)	Disable or enable the Linux route cache. Note that disabling the route cache, will also disable the fast path.

Read-Only Properties
ipv4-fast-path-active (yes | no)	Indicates whether fast-path is active
ipv4-fast-path-bytes (integer)	Amount of fast-pathed bytes
ipv4-fast-path-packets (integer)	Amount of fast-pathed packets
ipv4-fasttrack-active (yes | no)	Indicates whether fasttrack is active
ipv4-fasttrack-bytes (integer)	Amount of fasttracked bytes
ipv4-fasttrack-packets (integer)	Amount of fasttracked packet.
IPv6 Settings

Sub-menu: /ipv6 settings

Changing /ipv6 settings will not dynamically remove the old SLAAC configuration present on your router. A reboot is required to apply the new settings.


accept-redirects (no | yes-if-forwarding-disabled; Default: yes-if-forwarding-disabled)	Whether to accept ICMP redirect messages. Typically should be enabled on the host and disabled on routers
accept-router-advertisements (no | yes | yes-if-forwarding-disabled; Default: yes-if-forwarding-disabled)	Accept router advertisement (RA) messages. If enabled, the router will be able to get the address using stateless address configuration
disable-ipv6 (yes | no; Default: no)	Enable/disable system wide IPv6 settings (prevents LL address generation)
forward (yes | no; Default: yes)	Enable/disable packet forwarding between interfaces
max-neighbor-entries (integer [0..4294967295]; Default: )	A maximum number or IPv6 neighbors. Since RouterOS version 7.1, the default value depends on the installed amount of RAM. It is possible to set a higher value than the default, but it increases the risk of out-of-memory condition.

The default values for certain RAM sizes:

    1024 for 64 MB,
    2048 for 128 MB,
    4096 for 256 MB,
    8192 for 512 MB,
    16384 for 1024 MB or higher.

multipath-hash-policy (l3 | l4 | l3-inner; Default: l3)	

IPv6 Hash policy used for ECMP routing in /ipv6/settings menu

    l3 -- layer-3 hashing of src IP, dst IP, flow label, IP protocol
    l3-inner -- layer-3 hashing or inner layer-3 hashing if available
    l4 -- layer-4 hashing of src IP, dst IP, IP protocol, src port, dst port

disabled-link-local-address (no | yes ; Default: no)	

Disable automatic link-local address generation for non-VPN interfaces. This can be used when manually configured link-local addresses are being used.
stale-neighbor-timeout (time ; Default: 60)	

Timeout after which stale IPv6/Neighbor entries should be purged.
min-neighbor-entries (integer ; Default: 4096)	

Minimal number of IPv6/Neighbor entries, for which device must allocate memory.
soft-max-neighbor-entries (integer ; Default: 8192)	

Expected maximum number of IPv6/Neighbor entries which system should handle.
max-neighbor-entries (integer ; Default: 16384)	

Maximum number of entries for IPv7/Neighbor list.
allow-fast-path (yes | no; Default: yes)	

Allows Fast Path.

Read-Only Properties
ipv6-fast-path-active (yes | no)	Indicates whether fast-path is active
ipv6-fast-path-bytes (integer)	Amount of fast-pathed bytes
ipv6-fast-path-packets (integer)	Amount of fast-pathed packets
ipv6-fasttrack-active (yes | no)	Indicates whether fasttrack is active
ipv6-fasttrack-bytes (integer)	Amount of fasttracked bytes
ipv6-fasttrack-packets (integer)	Amount of fasttracked packet.

    Sin etiquetas 





    Creado por Normunds R., actualizado por última vez por GG el feb 29, 2024 1 min de lectura

In This Section:

        API
        Branding
        Command Line Interface
        MAC server
        MikroTik mobile app
        Quick Set
        REST API
        RoMON
        Serial Console
        SSH
        TR-069
        WebFig
        WinBox
        FlashFig


After successful RouterOS software installation (if it was needed) it is time to access the router for the first time. There are various ways how to connect to it:

    Command Line Interface (CLI) via Telnet, SSH, serial cable or keyboard and monitor if the router has VGA card.
    Web interface (WebFig)
    WinBox configuration utility
    Using mobile utility (MikroTik mobile app)

Normally you connect to the router by IP addresses with any telnet or SSH client software (a simple text-mode telnet client is usually called telnet and is distributed together with almost any OS).

If no IP or MAC connectivity is available, some devices allow connection through a serial port (DB9 or RJ45, depending on the model);

    Accessing devices over serial console
	
	
	

    Creado por Māris B., actualizado por última vez por Toms Filatovs el feb 27, 2025 10 min de lectura

    Summary
    Protocol
        API words
            Command word
            Attribute word
            API attribute word
            Query word
            Reply word
        API sentences
    Initial login
    Tags
    Command description
        Queries
        OID
        !trap
            message
            category
    Command examples
        /system/package/getall
        /user/active/listen
        /cancel, simultaneous commands
    Example client
    See also
        API examples

Summary

Application Programmable Interface (API) allows users to create custom software solutions to communicate with RouterOS to gather information, adjust the configuration, and manage the router. API closely follows syntax from the command-line interface (CLI). It can be used to create translated or custom configuration tools to aid ease of use in running and managing routers with RouterOS.

API service must be enabled before trying to establish the API connection. By default, API uses TCP:8728 and TCP:8729 (secure). 

API-SSL service is capable of working in two modes - with and without a certificate. In the case no certificate is used in /ip service settings then an anonymous Diffie-Hellman cipher has to be used to establish a connection. If a certificate is in use, a TLS session can be established.
Protocol

Communication with the router is done by sending sentences and receiving one or more sentences in return. A sentence is a sequence of words terminated by zero-length words. Word is part of a sentence encoded in a certain way - encoded length and data. Communication happens by sending sentences to the router and receiving replies to sent sentences. Each sentence sent to the router using API should contain a command as a first word followed by words in no particular order, the end of the sentence is marked by a zero-length word. When the router receives a full sentence (command word, no or more attribute words, and zero-length word) it is evaluated and executed, then a reply is formed and returned.
API words

Words are part of a sentence. Each word has to be encoded in a certain way - the length of the word followed by the word content. The length of the word should be given as a count of bytes that are going to be sent.

The length of the word is encoded as follows:
0 <= len <= 0x7F	1	len, lowest byte
0x80 <= len <= 0x3FFF	2	len | 0x8000, two lower bytes
0x4000 <= len <= 0x1FFFFF	3	len | 0xC00000, three lower bytes
0x200000 <= len <= 0xFFFFFFF	4	len | 0xE0000000
len >= 0x10000000	5	0xF0 and len as four bytes


    Each word is encoded as length, followed by that many bytes of content;
    Words are grouped into sentences. The end of a sentence is terminated by a zero-length word;
    The scheme allows encoding of length up to 0x7FFFFFFFFF, only four-byte length is supported;
    len bytes are sent most significant first (network order);
    If the first byte of the word is >= 0xF8, then it is a reserved control byte. After receiving an unknown control byte API client cannot proceed, because it does not know how to interpret the following bytes;
    Currently, control bytes are not used;

In general, words can be described like this <<encoded word length><word content>>. Word content can be separated into 5 parts: command word, attribute word, API attribute word. query word, and reply word
Command word

The first word in the sentence has to be a command followed by attribute words and a zero-length word or terminating word. The name of the command word should begin with '/'. Names of commands closely follow CLI, with spaces replaced with '/'. Some commands are specific to API;

Command word structure in the strict order:

    encoded length
    content prefix /
    CLI converted command


API-specific commands:

login
cancel

Command word content examples:

/login

/user/active/listen

/interface/vlan/remove

/system/reboot

Attribute word

Each command word has its list of attribute words depending on content.

Attribute word structure consists of 5 parts in this order:

    encoded length
    content prefix equals sign - =
    attribute name
    separating equals sign - =
    value of an attribute if there is one. It is possible that the attribute does not have a value


Value can hold multiple equal signs in the value of an attribute word since the way the word is encoded.

Value can be empty.

Examples without encoded length prefix:

=address=10.0.0.1

=name=iu=c3Eeg

=disable-running-check=yes

Order of attribute words and API parameters is not important and should not be relied on
API attribute word

API attribute word structure is in the strict order:

    encoded length
    content prefix with the dot.
    attribute name
    name postfixed with equals =sign
    attribute value

Currently, the only such API attribute is the tag.

If the sentence contains an API attribute word tag then each returned sentence in reply from the router to that tagged sentence will be tagged with the same tag.
Query word

Sentences can have additional query parameters that restrict their scope. A detailed explanation is in the query section.

Example of a sentence using query word attributes:

/interface/print
?type=ether
?type=vlan
?#|!


    Query words begin with '?'.
    Currently, only the print command handles query words.

The order of query words is significant
Reply word

It is only sent by the router in response to the full sentence received from the client.

    The first word of reply begins with '!';
    Each sentence sent generates at least one reply (if a connection does not get terminated);
    The last reply for every sentence is the reply that has the first word !done;
    Errors and exceptional conditions begin with !trap;
    Data replies begin with !re;
    Replies of commands which do not have any data to reply with, begin with !empty (introduced in RouterOS 7.18);
    If the API connection is closed, RouterOS sends !fatal with a reason as a reply and then closes the connection;

API sentences

API sentence is the main object of communication using API.

    Empty sentences are ignored.
    A sentence is processed after receiving zero length word.
    There is a limit on the number and size of sentences that the client can send before it has logged in.
    Order of attribute words should not be relied on. As order and count are changeable by .proplist attribute.
    The sentence structure is as follows:
        The first word should contain a command word;
        Should contain zero-length word to terminate the sentence;
        Can contain none or several attribute words. There is no particular order in what attribute words have to be sent in the sentence, order is not important for attribute words;
        Can contain none or several query words. The order of query words in the sentence is important.

Zero-length word terminates the sentence. If it is not provided router will not start to evaluate sent words and will consider all the input as part of the same sentence.
Initial login

Note: that each command and response ends with an empty word.

Login method post-v6.43:
/login
=name=admin
=password=
 !done


    Now the client sends a username and password in the first message.
    Password is sent in plain text.
    in case of an error, the reply contains =message=error message.
    In case of a successful login, the client can start to issue commands.

Tags

    It is possible to run several commands simultaneously, without waiting for the previous one to complete. If the API client is doing this and needs to differentiate command responses, it can use the 'tag' API parameter in command sentences.
    If you include the 'tag' parameter with a non-empty value in the command sentence, then the 'tag' parameter with the same value will be included in all responses generated by this command.
    If you do not include the 'tag' parameter or its value is empty, then all responses for this command will not have a 'tag' parameter.

Command description

    /cancel
        optional argument: =tag=tag of command to cancel, without it, cancels all running commands
        does not cancel itself
        all canceled commands are interrupted and in the usual case generate '!trap' and '!done' responses
        please note that /cancel is separate command and can have its own unique '.tag' parameter, that is not related to '=tag' argument of this command

    listen
        listen command is available where console print command is available, but it does not have the expected effect everywhere (i.e. may not work)
        "!re" sentences are generated as something changes in a particular item list
        when an item is deleted or disappears in any other way, the '!re' sentence includes the value '=.dead=yes'
        This command does not terminate. To terminate it, use /cancel command.

    getall
        getall command is available where console print command is available (getall is an alias for print).
        replies contain =.id=Item internal number property.

    print
        API print command differs from the console counterpart in the following ways:
            where an argument is not supported. Items can be filtered using query words (see below).
            .proplist argument is a comma-separated list of property names that should be included for the returned items.
                returned items may have additional properties.
                order of returned properties is not defined.
                if a list contains duplicate entries, handling of such entries is not defined.
                if a property is present in ".proplist", but absent from the item, then that item does not have this property value (?name will evaluate to false for that item).
                if ".proplist" is absent, all properties are included as requested by the print command, even those that have slow access time (such as file contents and performance counters). Thus the use of .proplist is encouraged. The omission of .proplist may have a high-performance penalty if the "=detail=" argument is set.

Queries

The print command accepts query words that limit the set of returned sentences. 

    Query words begin with '?'.
    The order of query words is significant. A query is evaluated starting from the first word.
    A query is evaluated for each item in the list. If the query succeeds, the item is processed, if a query fails, the item is ignored.
    A query is evaluated using a stack of boolean values. Initially, the stack contains an infinite amount of 'true' values. At the end of the evaluation, if the stack contains at least one 'false' value, the query fails.
    Query words operate according to the following rules:

?name	pushes 'true' if an item has a value of property name, 'false' if it does not.
?-name	pushes 'true' if an item does not have a value of property name, 'false' otherwise.
?name=x
?=name=x	pushes 'true' if the property name has a value equal to x, 'false' otherwise.
?<name=x	pushes 'true' if the property name has a value less than x, 'false' otherwise.
?>name=x	pushes 'true' if the property name has a value greater than x, 'false' otherwise.
?#operations	applies operations to the values in the stack.

    operation string is evaluated from left to right.
    the sequence of decimal digits followed by any other character or end of the word is interpreted as a stack index. top value has an index 0.
    an index that is followed by a character pushes a copy of the value at that index.
    an index that is followed by the end of the word replaces all values with the value at that index.
    ! character replaces the top value with the opposite.
    & pops two values and pushes the result of logical 'and' operation.
    | pops two values and pushes the result of logical 'or' operation.
    . after an index does nothing.
    . after another character pushes a copy of the top value.


Regular expressions are not supported in API, so do not try to send a query with the ~ symbol


Examples:

    Get all ethernet and VLAN interfaces:

/interface/print
?type=ether
?type=vlan
?#|

    Get all routes that have a non-empty comment:

/ip/route/print
?>comment=

    Forum thread with a detailed explanation of the use of queries

OID

The print command can return OID values for properties that are available in SNMP. 

In the console, OID values can be seen by running the 'print oid' command. In API, these properties have a name that ends with ".oid", and can be retrieved by adding their name to the value of '.proplist'. An example:


/system/resource/print
=.proplist=uptime,cpu-load,uptime.oid,cpu-load.oid
 !re
=uptime=01:22:53
=cpu-load=0
=uptime.oid=.1.3.6.1.2.1.1.3.0
=cpu-load.oid=.1.3.6.1.2.1.25.3.3.1.2.1

 !done


!trap

When for some reason API sentence fails trap is sent in return accompanied by a message attribute and on some occasions category argument.
message

When an API sentence fails, some generic message or message from the used internal process is returned to give more details about the failure
<<< /ip/address/add 
<<< =address=192.168.88.1 
<<< =interface=asdf <<< 

>>> !trap 
>>> =category=1 
>>> =message=input does not match any value of interface


category

if it is a general error, it is categorized and the error category is returned. possible values for this attribute are

    0 - missing item or command
    1 - argument value failure
    2 - execution of command interrupted
    3 - scripting related failure
    4 - a general failure
    5 - API related failure
    6 - TTY related failure
    7 - value generated with :return command

Command examples
/system/package/getall
/system/package/getall

 !re
=.id=*5802
=disabled=no
=name=routeros-x86
=version=3.0beta2
=build-time=oct/18/2006 16:24:41
=scheduled=

 !re
=.id=*5805
=disabled=no
=name=system
=version=3.0beta2
=build-time=oct/18/2006 17:20:46
=scheduled=

... more !re sentences ...
 !re
=.id=*5902
=disabled=no
=name=advanced-tools
=version=3.0beta2
=build-time=oct/18/2006 17:20:49
=scheduled=

 !done

/user/active/listen
/user/active/listen

 !re
=.id=*68
=radius=no
=when=oct/24/2006 08:40:42
=name=admin
=address=0.0.0.0
=via=console

 !re
=.id=*68
=.dead=yes

... more !re sentences ...
/cancel, simultaneous commands
/login

 !done
=ret=856780b7411eefd3abadee2058c149a3

/login
=name=admin
=response=005062f7a5ef124d34675bf3e81f56c556

 !done
-- first start listening for interface changes (tag is 2)
/interface/listen
.tag=2
-- disable interface (tag is 3)
/interface/set
=disabled=yes
=.id=ether1
.tag=3
-- this is done for disable command (tag 3)
 !done
.tag=3

-- enable interface (tag is 4)
/interface/set
=disabled=no
=.id=ether1
.tag=4
-- this update is generated by a change made by the first set command (tag 3)
 !re
=.id=*1
=disabled=yes
=dynamic=no
=running=no
=name=ether1
=mtu=1500
=type=ether
.tag=2

-- this is done for enable command (tag 4)
 !done
.tag=4

-- get interface list (tag is 5)
/interface/getall
.tag=5

-- this update is generated by a change made by the second set command (tag 4)
 !re
=.id=*1
=disabled=no
=dynamic=no
=running=yes
=name=ether1
=mtu=1500
=type=ether
.tag=2

-- these are replies to getall command (tag 5)
 !re
=.id=*1
=disabled=no
=dynamic=no
=running=yes
=name=ether1
=mtu=1500
=type=ether
.tag=5

 !re
=.id=*2
=disabled=no
=dynamic=no
=running=yes
=name=ether2
=mtu=1500
=type=ether
.tag=5

-- here interface getall ends (tag 5)
 !done
.tag=5

-- stop listening - request to cancel command with tag 2, cancel itself uses tag 7
/cancel
=tag=2
.tag=7

-- listen command is interrupted (tag 2)
 !trap
=category=2
=message=interrupted
.tag=2

-- cancel command is finished (tag 7)
 !done
.tag=7

-- listen command is finished (tag 2)
 !done
.tag=2
Example client

A simple API client in Python3

Example output:
debian@localhost:~/api-test$ ./api.py 10.0.0.1 admin ''
<<< /login
<<< 
>>> !done
>>> =ret=93b438ec9b80057c06dd9fe67d56aa9a
>>> 
<<< /login
<<< =name=admin
<<< =response=00e134102a9d330dd7b1849fedfea3cb57
<<< 
>>> !done
>>> 
/user/getall

<<< /user/getall
<<< 
>>> !re
>>> =.id=*1
>>> =disabled=no
>>> =name=admin
>>> =group=full
>>> =address=0.0.0.0/0
>>> =netmask=0.0.0.0
>>> 
>>> !done
>>> 
See also
API examples

API implementations in different languages, provided by different sources. They are not ordered in any particular order.

    in Python3 by MikroTik
    in .NET (C#) high-level API solution forum thread additional info by danikf
    in PHP by boen_robot
    in C by Håkon Nessjøen
    in Java by Gideon LeGrange
    in Erlang by Valery Comtihon
    in GO by André Luiz dos Santos
    in Python3 by Arturs Laizans
    in Python3 by Jakub Gocławski
    in Python3 by Arseniy Kuznetsov
    in C++17 by Ayman Al-Qadhi






    Creado por Māris B., actualizado por última vez por GG el mar 06, 2024 3 min de lectura

A simple Python3 example client.

    usage: api.py ip-address username password secure
    i.e. api.py 10.0.0.1 Admin Badpassword123 True
    after that, type words from the keyboard, terminating them with a new line
    Since an empty word terminates a sentence, you should press enter twice after the last word before a sentence will be sent to the router.


#!/usr/bin/python3
# -*- coding: latin-1 -*-
import sys, posix, time, binascii, socket, select, ssl
import hashlib

class ApiRos:
	"Routeros api"
	def __init__(self, sk):
		self.sk = sk
		self.currenttag = 0

	def login(self, username, pwd):
		for repl, attrs in self.talk(["/login", "=name=" + username, "=password=" + pwd]):
			if repl == '!trap':
				return False
			elif '=ret' in attrs.keys():
				#for repl, attrs in self.talk(["/login"]):
				chal = binascii.unhexlify((attrs['=ret']).encode(sys.stdout.encoding))
				md = hashlib.md5()
				md.update(b'\x00')
				md.update(pwd.encode(sys.stdout.encoding))
				md.update(chal)
				for repl2, attrs2 in self.talk(["/login", "=name=" + username, "=response=00" 
					+ binascii.hexlify(md.digest()).decode(sys.stdout.encoding) ]):
					if repl2 == '!trap':
						return False
		return True

	def talk(self, words):
		if self.writeSentence(words) == 0: return
		r = []
		while 1:
			i = self.readSentence();
			if len(i) == 0: continue
			reply = i[0]
			attrs = {}
			for w in i[1:]:
				j = w.find('=', 1)
				if (j == -1):
					attrs[w] = ''
				else:
					attrs[w[:j]] = w[j+1:]
			r.append((reply, attrs))
			if reply == '!done': return r

	def writeSentence(self, words):
		ret = 0
		for w in words:
			self.writeWord(w)
			ret += 1
		self.writeWord('')
		return ret

	def readSentence(self):
		r = []
		while 1:
			w = self.readWord()
			if w == '': return r
			r.append(w)

	def writeWord(self, w):
		print(("<<< " + w))
		self.writeLen(len(w))
		self.writeStr(w)

	def readWord(self):
		ret = self.readStr(self.readLen())
		print((">>> " + ret))
		return ret

	def writeLen(self, l):
		if l < 0x80:
			self.writeByte((l).to_bytes(1, sys.byteorder))
		elif l < 0x4000:
			l |= 0x8000
			tmp = (l >> 8) & 0xFF
			self.writeByte(((l >> 8) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte((l & 0xFF).to_bytes(1, sys.byteorder))
		elif l < 0x200000:
			l |= 0xC00000
			self.writeByte(((l >> 16) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte(((l >> 8) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte((l & 0xFF).to_bytes(1, sys.byteorder))
		elif l < 0x10000000:
			l |= 0xE0000000
			self.writeByte(((l >> 24) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte(((l >> 16) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte(((l >> 8) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte((l & 0xFF).to_bytes(1, sys.byteorder))
		else:
			self.writeByte((0xF0).to_bytes(1, sys.byteorder))
			self.writeByte(((l >> 24) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte(((l >> 16) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte(((l >> 8) & 0xFF).to_bytes(1, sys.byteorder))
			self.writeByte((l & 0xFF).to_bytes(1, sys.byteorder))

	def readLen(self):
		c = ord(self.readStr(1))
		# print (">rl> %i" % c)
		if (c & 0x80) == 0x00:
			pass
		elif (c & 0xC0) == 0x80:
			c &= ~0xC0
			c <<= 8
			c += ord(self.readStr(1))
		elif (c & 0xE0) == 0xC0:
			c &= ~0xE0
			c <<= 8
			c += ord(self.readStr(1))
			c <<= 8
			c += ord(self.readStr(1))
		elif (c & 0xF0) == 0xE0:
			c &= ~0xF0
			c <<= 8
			c += ord(self.readStr(1))
			c <<= 8
			c += ord(self.readStr(1))
			c <<= 8
			c += ord(self.readStr(1))
		elif (c & 0xF8) == 0xF0:
			c = ord(self.readStr(1))
			c <<= 8
			c += ord(self.readStr(1))
			c <<= 8
			c += ord(self.readStr(1))
			c <<= 8
			c += ord(self.readStr(1))
		return c

	def writeStr(self, str):
		n = 0;
		while n < len(str):
			r = self.sk.send(bytes(str[n:], 'UTF-8'))
			if r == 0: raise RuntimeError("connection closed by remote end")
			n += r

	def writeByte(self, str):
		n = 0;
		while n < len(str):
			r = self.sk.send(str[n:])
			if r == 0: raise RuntimeError("connection closed by remote end")
			n += r

	def readStr(self, length):
		ret = ''
		# print ("length: %i" % length)
		while len(ret) < length:
			s = self.sk.recv(length - len(ret))
			if s == b'': raise RuntimeError("connection closed by remote end")
			# print (b">>>" + s)
			# atgriezt kaa byte ja nav ascii chars
			if s >= (128).to_bytes(1, "big") :
				return s
			# print((">>> " + s.decode(sys.stdout.encoding, 'ignore')))
			ret += s.decode(sys.stdout.encoding, "replace")
		return ret

def open_socket(dst, port, secure=False):
	s = None
	res = socket.getaddrinfo(dst, port, socket.AF_UNSPEC, socket.SOCK_STREAM)
	af, socktype, proto, canonname, sockaddr = res[0]
	skt = socket.socket(af, socktype, proto)
	if secure:
		s = ssl.wrap_socket(skt, ssl_version=ssl.PROTOCOL_TLSv1_2, ciphers="ECDHE-RSA-AES256-GCM-SHA384") #ADH-AES128-SHA256
	else:
		s = skt
	s.connect(sockaddr)
	return s

def main():
	s = None
	dst = sys.argv[1]
	user = "admin"
	passw = ""
	secure = False
	port = 0

	# use default username and pasword if not specified      
	arg_nr = len(sys.argv)
    if arg_nr > 2: user = sys.argv[2] 
    if arg_nr > 3: passw = sys.argv[3]
    if arg_nr > 4: secure = sys.argv[4]

	if (port==0):
		port = 8729 if secure else 8728

	s = open_socket(dst, port, secure)
	if s is None:
		print ('could not open socket')
		sys.exit(1)

	apiros = ApiRos(s);
	if not apiros.login(user, passw):
		return

	inputsentence = []

	while 1:
		r = select.select([s, sys.stdin], [], [], None)
		if s in r[0]:
			# something to read in socket, read sentence
			x = apiros.readSentence()

		if sys.stdin in r[0]:
			# read line from input and strip off newline
			l = sys.stdin.readline()
			l = l[:-1]

			# if empty line, send sentence and start with new
			# otherwise append to input sentence
			if l == '':
				apiros.writeSentence(inputsentence)
				inputsentence = []
			else:
				inputsentence.append(l)

if __name__ == '__main__':
	main()

    Sin etiquetas 





    Creado por Normunds R., actualizado por última vez por Serhii T. el ene 22, 2025 3 min de lectura

RouterOS allows slight system customization with the help of a branding package (modify default configuration, LCD logo, WebFig homepage, etc.).

This is a special system package, which you can generate from within your mikrotik.com account, in the account section "Branding maker". The resulting file will have a .dpk extension and can be installed by all the same means as an .npk package.

To install the package on a router, branding package has to upload to it and then a router has to reboot, Netinstall tool can be used for the same effect.

The generated package can be installed in any RouterOS version.

Note that specific branding features are available starting from specific RouterOS versions.
Options

Options that can be configured using a branding package:

    Router name - branding package name, device identity and platform name in RouterOS, can only be one word, don't use spaces or special characters;
    Company URL - value that appears in the console when you connect to RouterOS device;
    Manual URL - documentation link, which can be opened in WebFig;
    ASCII Logo - a text logo that is shown when logging into the command line interface, i.e. Telnet, SSH, WinBox Terminal. A logo can be created in the branding maker or copied from any other plaintext editor. A logo height cannot be larger than 8 lines, width is not limited, but note that in a narrow terminal window a logo might be distorted.
    Hide "Mikrotik" from SNMP information - MikroTik name will be hidden in SNMP information;
    Do not run script on install - do not run Default configuration script on branding package install;
    Hide Default configuration prompt - hide Default configuration prompt after configuration reset (available starting from RouterOS 7.15)
    Hide default caps-mode-script - hide default caps-mode-script (available starting from RouterOS 7.15)

Custom files

Custom files such as the WebFig login page, WebFig logo, hotspot, skins, Default configuration, LCD logo, Custom files and CAPs mode script can be included in the branding package.
WebFig login page

The WebFig login page is a customized default RouterOS login interface that appears when accessing the router's IP address. This page can be customized to meet branding or functional requirements.

    Customization Files:
        /index2.html: Main template for the login page.
        /assets/style.css:  MikroTik RouterOS stylesheet.
        /assets/script.js is responsible for handling the login functionality and contains code that gives the button interactivity.

    Required Elements for the script.js:
        Form for Login:
        <form id="login">
        Username Field:
        <input id="name" data-defaultuser="admin">
            The admin value can be changed to another username or left blank.
        Password Field:
        <input id="password">
        Error Display Section:
        <div id="error">
    Here is an example of a user-customized login page with a "Show Password" button, achieved using a modified index2.html along with additional css and js files.
    The HTML file must be named "index2.html" and should use properly nested HTML to ensure compatibility with all browsers.
    The uploaded images or JavaScript files must reference to the same path as the index file, no custom folder names can be used.

WebFig logo

RouterOS WebFig page (configuration page) logo. To overwrite the MikroTik logo on the WebFig login page, upload your custom logo named "mikrotik_logo.png".
hotspot

Hotspot login page logo. The file must be named "logobottom.png".
skins

A skin file with name "your_file_name.json". To apply a particular skin to a specific user group, you don't need to log into the router. You can do it with branding by uploading a Default configuration file.
Default configuration

A RouterOS default configuration file that will override RouterOS default configuration. This configuration will persist even after a RouterOS reset. Factory passwords can be reapplied using the read-only variables $defconfPassword and $defconfWifiPassword (access to factory passwords is available starting RouterOS 7.10).
LCD logo

LCD logo will be displayed on devices equipped with LCD screen. A Logo size cannot be larger than 160px width and 72px height. CCR1xxx series has white (0xffffff) background, 2011 series have black (0x000000) background.
Custom files 

Custom files will be copied into a folder named "branding" and will be accessible from within RouterOS.
CAPs mode script

A RouterOS CAPs mode script that will override RouterOS default CAPs mode script. It is possible to reapply the factory passwords by utilizing the read-only variables $defconfPassword and $defconfWifiPassword (available starting from RouterOS 7.15).

If a Default configuration or CAPs mode script execution takes more than 2 minutes, a script will fail, and LOG will contain "runtime limit exceeded" or in rare cases "std failure: timeout" error.




    Creado por Normunds R., actualizado por última vez el ene 03, 2025 13 min de lectura

    Login Options
    Banner and Messages
    Command Prompt
    Hierarchy
    Item Names and Numbers
        Item Names
        Item Numbers
    General Commands
    Input Modes
    Quick Typing
    Console Search
    Internal Chat System
    List of Keys

The console is used for accessing the MikroTik Router's configuration and management features using text terminals, either remotely using a serial port, telnet, SSH, console screen within WinBox, or directly using monitor and keyboard. The console is also used for writing scripts. This manual describes the general console operation principles. Please consult the Scripting Manual on some advanced console commands and on how to write scripts.
Login Options

Console login options enable or disable various console features like color, terminal detection, and many other.

Additional login parameters can be appended to the login name after the '+' sign.

    login_name ::= user_name [ '+' parameters ]
    parameters ::= parameter [ parameters ]
    parameter ::= [ number ] 'a'..'z'
    number ::= '0'..'9' [ number ]
  

If the parameter is not present, then the default value is used. If the number is not present then the implicit value of the parameter is used.

Example: admin+ct80w - will disable console colors, disable auto detection and then set terminal width to 80.
"w"	auto	auto	Set terminal width
"h"	auto	auto	Set terminal height
"c"	on	off	disable/enable console colors
"t"	off	off	Disable auto-detection of terminal capabilities
"e"	on	off	Enables "dumb" terminal mode
Banner and Messages

The login process will display the MikroTik banner and short help after validating the user name and password.
  MMM      MMM       KKK                          TTTTTTTTTTT      KKK
  MMMM    MMMM       KKK                          TTTTTTTTTTT      KKK
  MMM MMMM MMM  III  KKK  KKK  RRRRRR     OOOOOO      TTT     III  KKK  KKK
  MMM  MM  MMM  III  KKKKK     RRR  RRR  OOO  OOO     TTT     III  KKKKK
  MMM      MMM  III  KKK KKK   RRRRRR    OOO  OOO     TTT     III  KKK KKK
  MMM      MMM  III  KKK  KKK  RRR  RRR   OOOOOO      TTT     III  KKK  KKK

  MikroTik RouterOS 6.22 (c) 1999-2014       https://www.mikrotik.com/

[?]             Gives the list of available commands
command [?]     Gives help on the command and list of arguments

[Tab]           Completes the command/word. If the input is ambiguous,
                a second [Tab] gives possible options

/               Move up to base level
..              Move up one level
/command        Use command at the base level


After the banner can be printed other important information, like /system note set by another admin, the last few critical log messages, demo version upgrade reminder, and default configuration description.

For example, the demo license prompt and last critical messages are printed
UPGRADE NOW FOR FULL SUPPORT
----------------------------
FULL SUPPORT benefits:
- receive technical support
- one year feature support
- one year online upgrades
    (avoid re-installation and re-configuring your router)
To upgrade, register your license "software ID"
on our account server www.mikrotik.com

Current installation "software ID": ABCD-456

Please press "Enter" to continue!


dec/10/2007 10:40:06 system,error,critical login failure for user root from 10.0.0.1 via telnet
dec/10/2007 10:40:07 system,error,critical login failure for user root from 10.0.0.1 via telnet
dec/10/2007 10:40:09 system,error,critical login failure for user test from 10.0.0.1 via telnet
Command Prompt

At the end of the successful login sequence, the login process prints a banner that shows the command prompt, and hands over control to the user.

Default command prompt consists of user name, system identity, and current command path />

For example, change the current path from the root to the interface then go back to the root
  [admin@MikroTik] > interface [enter]
  [admin@MikroTik] /interface> / [enter]
  [admin@MikroTik] >

Use up arrow to recall previous commands (if this is a multiline command, then you can press F8 in order to expand it) from command history (commands that added sensitive data, like passwords, will not be available in the history), TAB key to automatically complete words in the command you are typing, ENTER key to execute the command, Control-C to interrupt currently running command and return to prompt and ? to display built-in help, in RouterOS v7, F1 has to be used instead.

The easiest way to log out of the console is to press Control-D at the command prompt while the command line is empty (You can cancel the current command and get an empty line with Control-C, so Control-C followed by Control-D will log you out in most cases).

It is possible to write commands that consist of multiple lines. When the entered line is not a complete command and more input is expected, the console shows a continuation prompt that lists all open parentheses, braces, brackets, and quotes, and also trailing backslash if the previous line ended with backslash-white-space.
    [admin@MikroTik] > {
    {... :put (\
    {(\... 1+2)}
    3

When you are editing such multiple line entries, the prompt shows the number of current lines and total line count instead of the usual username and system name.

line 2 of 3> :put (\

Sometimes commands ask for additional input from the user. For example, the command '/password' asks for old and new passwords. In such cases, the prompt shows the name of the requested value, followed by colon and space.
    [admin@MikroTik] > /password
    old password: ******
    new password: **********
    retype new password: **********
Hierarchy

The console allows the configuration of the router's settings using text commands. Since there is a lot of available commands, they are split into groups organized in a way of hierarchical menu levels. The name of a menu level reflects the configuration information accessible in the relevant section.

For example, you can issue the /ip route print command:
[admin@MikroTik] > /ip route print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; 
C - connect, S - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn 
 #     DST-ADDRESS        GATEWAY            DISTANCE
 0  XS 4.4.4.4            10.155.101.1      
   D o 0.0.0.0/0          10.155.101.1            110
 1  AS 0.0.0.0/0          10.155.101.1              1
   D b 1.0.4.0/24         10.155.101.1             20
   D b 1.0.4.0/24         10.155.101.1             20
   DAb 1.0.4.0/24         10.155.101.1             20
[admin@MikroTik] >

Instead of typing `/ip route` path before each command, the path can be typed only once to move into this particular branch of the menu hierarchy. Thus, the example above could also be executed like this:
[admin@MikroTik] > /ip route
[admin@MikroTik] /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; 
C - connect, S - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn 
 #     DST-ADDRESS        GATEWAY            DISTANCE
 0  XS 4.4.4.4            10.155.101.1      
   D o 0.0.0.0/0          10.155.101.1            110
 1  AS 0.0.0.0/0          10.155.101.1              1
   D b 1.0.4.0/24         10.155.101.1             20
   D b 1.0.4.0/24         10.155.101.1             20
   DAb 1.0.4.0/24         10.155.101.1             20
[admin@MikroTik] >

Each word in the path can be separated by space (as in the example above) or by "/"
[admin@MikroTik] > /ip/route/
[admin@MikroTik] /ip/route> print 
Flags: D - dynamic; X - disabled, I - inactive, A - active; 
C - connect, S - static, r - rip, b - bgp, o - ospf, d - dhcp, v - vpn 
 #     DST-ADDRESS        GATEWAY            DISTANCE
 0  XS 4.4.4.4            10.155.101.1      
   D o 0.0.0.0/0          10.155.101.1            110
 1  AS 0.0.0.0/0          10.155.101.1              1
   D b 1.0.4.0/24         10.155.101.1             20
   D b 1.0.4.0/24         10.155.101.1             20
   DAb 1.0.4.0/24         10.155.101.1             20
[admin@MikroTik] >

Notice that the prompt changes in order to reflect where you are located in the menu hierarchy at the moment. To move to the top level again, type " / "
[admin@MikroTik] > ip route
[admin@MikroTik] /ip/route> /
[admin@MikroTik] >

To move up one command level, type " .. "
[admin@MikroTik] /ip/route> ..
[admin@MikroTik] /ip>

You can also use / and .. to execute commands from other menu levels without changing the current level:
[admin@MikroTik] /ip/route> /ping 10.0.0.1
10.0.0.1 ping timeout
2 packets transmitted, 0 packets received, 100% packet loss
[admin@MikroTik] /ip/firewall/nat> .. service-port print
Flags: X - disabled, I - invalid
#   NAME                                                                PORTS
0   ftp                                                                 21
1   tftp                                                                69
2   irc                                                                 6667
3   h323
4   sip
5   pptp
[admin@MikroTik] /ip/firewall/nat>
Item Names and Numbers

Many of the command levels operate with arrays of items: interfaces, routes, users, etc. Such arrays are displayed in similarly-looking lists. All items in the list have an item number followed by flags and parameter values.

To change the properties of an item, you have to use the set command and specify the name or number of the item.
Item Names

Some lists have items with specific names assigned to each of them. Examples are interface or user levels. There you can use item names instead of item numbers.

You do not have to use the print command before accessing items by their names, which, as opposed to numbers, are not assigned by the console internally, but are properties of the items. Thus, they would not change on their own. However, there are all kinds of obscure situations possible when several users are changing the router's configuration at the same time. Generally, item names are more "stable" than the numbers, and also more informative, so you should prefer them to numbers when writing console scripts.
Item Numbers

Item numbers are assigned by the print command and are not constant - it is possible that two successive print commands will order items differently. But the results of the last print commands are memorized and, thus, once assigned, item numbers can be used even after add, remove and move operations (since version 3, move operation does not renumber items). Item numbers are assigned on a per session basis, they will remain the same until you quit the console or until the next print command is executed. Also, numbers are assigned separately for every item list, so /ip address print will not change the numbering of the interface list.

You can specify multiple items as targets to some commands. Almost everywhere, where you can write the number of items, you can also write a list of numbers.
[admin@MikroTik] > interface print
Flags: X - disabled, D - dynamic, R - running
  #    NAME                 TYPE             MTU
  0  R ether1               ether            1500
  1  R ether2               ether            1500
  2  R ether3               ether            1500
  3  R ether4               ether            1500
[admin@MikroTik] > interface set 0,1,2 mtu=1460
[admin@MikroTik] > interface print
Flags: X - disabled, D - dynamic, R - running
  #    NAME                 TYPE             MTU
  0  R ether1               ether            1460
  1  R ether2               ether            1460
  2  R ether3               ether            1460
  3  R ether4               ether            1500
[admin@MikroTik] >
General Commands

There are some commands that are common to nearly all menu levels, namely: print, set, remove, add, find, get, export, enable, disable, comment, move. These commands have similar behavior throughout different menu levels.
add	This command usually has all the same arguments as a set, except the item number argument. It adds a new item with the values you have specified, usually at the end of the item list, in places where the order of items is relevant. There are some required properties that you have to supply, such as the interface for a new address, while other properties are set to defaults unless you explicitly specify them.

Common Parameters

    copy-from - Copies an existing item. It takes default values of a new item's properties from another item. If you do not want to make an exact copy, you can specify new values for some properties. When copying items that have names, you will usually have to give a new name to a copy
    place-before - places a new item before an existing item with a specified position. Thus, you do not need to use the move command after adding an item to the list
    disabled - controls disabled/enabled state of the newly added item(-s)
    comment - holds the description of a newly created item

Return Values

    add command returns the internal number of items it has added

edit	This command is associated with the set command. It can be used to edit values of properties that contain a large amount of text, such as scripts, but it works with all editable properties. Depending on the capabilities of the terminal, either a full-screen editor or a single line editor is launched to edit the value of the specified property.
find	The find command has the same arguments as a set, plus the flag arguments like disabled or active that take values yes or no depending on the value of the respective flag. To see all flags and their names, look at the top of the print command's output. The find command returns internal numbers of all items that have the same values of arguments as specified.
move	Changes the order of items in the list. Parameters:

    the first argument specifies the item(-s) being moved.
    the second argument specifies the item before which to place all items being moved (they are placed at the end of the list if the second argument is omitted).

print	Shows all information that's accessible from a particular command level. Thus, /system clock print shows the system date and time, /ip route print shows all routes etc. If there\'s a list of items in the current level and they are not read-only, i.e. you can change/remove them (example of read-only item list is /system history, which shows a history of executed actions), then print command also assigns numbers that are used by all commands that operate with items in this list.

Common Parameters:

    append - 
    brief - forces the print command to use tabular output form
    count-only - shows the number of items
    detail - forces the print command to use property=value output form
    file - prints the contents of the specific sub-menu into a file on the router.
    follow - 
    follow-only - 
    follow-strict - 
    from - show only specified items, in the same order in which they are given.
    interval - updates the output from the print command for every interval of seconds.
    oid - prints the OID value for properties that are accessible from SNMP.
    proplist - comma-separated and ordered list of property names that should be included for the returned items.
    show-ids - 
    where - show only items that match specified criteria. The syntax of where the property is similar to the find command.
    without-paging - prints the output without stopping after each screenful.

remove	Removes specified item(-s) from a list.
set	Allows you to change values of general parameters or item parameters. The set command has arguments with names corresponding to values you can change. Use ? or double Tab to see a list of all arguments. If there is a list of items in this command level, then the set has one action argument that accepts the number of items (or list of numbers) you wish to set up. This command does not return anything.
Input Modes

It is possible to switch between several input modes:

    Normal mode - indicated by normal command prompt.
    Safe mode - safe mode is indicated by the word SAFE after the command prompt. In this mode, the configuration is saved to disk only after the safe mode is turned off. Safe mode can be turned on/off with Ctrl+X or F4. Read more >>
    Hot-lock mode - indicated by additional yellow >. Hot-lock mode autocompletes commands and can be turned on/off with F7

Quick Typing

There are two features in the console that help entering commands much quicker and easier - the [Tab] key completions, and abbreviations of command names. Completions work similarly to the bash shell in UNIX. If you press the [Tab] key after a part of a word, the console tries to find the command within the current context that begins with this word. If there is only one match, it is automatically appended, followed by a space:

/inte[Tab]_ becomes /interface _

If there is more than one match, but they all have a common beginning, which is longer than that what you have typed, then the word is completed to this common part, and no space is appended:

/interface set e[Tab]_ becomes /interface set ether_

If you've typed just the common part, pressing the tab key once has no effect. However, pressing it for the second time shows all possible completions in compact form:

[admin@MikroTik] > interface set e[Tab]_
[admin@MikroTik] > interface set ether[Tab]_
[admin@MikroTik] > interface set ether[Tab]_
ether1 ether5
[admin@MikroTik] > interface set ether_

The [Tab] key can be used almost in any context where the console might have a clue about possible values - command names, argument names, arguments that have only several possible values (like names of items in some lists or name of the protocol in firewall and NAT rules). You cannot complete numbers, IP addresses, and similar values.

Another way to press fewer keys while typing is to abbreviate command and argument names. You can type only the beginning of the command name, and, if it is not ambiguous, the console will accept it as a full name. So typing:

[admin@MikroTik] > pi 10.1 c 3 si 100

equals to:

[admin@MikroTik] > ping 10.0.0.1 count 3 size 100

It is possible to complete not only the beginning, but also any distinctive sub-string of a name: if there is no exact match, the console starts looking for words that have string being completed as first letters of a multiple word name, or that simply contain letters of this string in the same order. If a single such word is found, it is completed at the cursor position. For example:

[admin@MikroTik] > interface x[TAB]_
[admin@MikroTik] > interface export _

[admin@MikroTik] > interface mt[TAB]_
[admin@MikroTik] > interface monitor-traffic _

Console Search

Console search allows performing keyword search through the list of RouterOS menus and the history. The search prompt is accessible with the [Ctrl+r] shortcut. 
Internal Chat System

RouterOS console has a built-in internal chat system. This allows remotely located admins to talk to each other directly in RouterOS CLI. To start the conversation prefix the intended message with the # symbol, anyone who is logged in at the time of sending the message will see it.
[admin@MikroTik] > # ready to break internet?
[admin@MikroTik] > 
fake_admin: i was born ready
[admin@MikroTik] > 
[fake_admin@MikroTik] > 
admin: ready to break internet?
[fake_admin@MikroTik] > # i was born ready
[fake_admin@MikroTik] > 
List of Keys
Control-C	keyboard interrupt
Control-D	log out (if an input line is empty)
Control-K	clear from the cursor to the end of the line
Control-U	clear from the cursor to the beginning of the line
Control-X or F4	toggle safe mode
F7	toggle hot-lock mode
Control-R or F3	toggle console search
F6	toggle cellar
F1	show context-sensitive help.
Tab	perform line completion. When pressed a second time, show possible completions.
#	Send a message to an internal chat system
Delete	remove character at the cursor
Control-H or Backspace	removes character before cursor and moves the cursor back one position.
Control-\	split line at cursor. Insert newline at the cursor position. Display second of the two resulting lines.
Control-B or Left	move cursor backward one character
Control-F or Right	move cursor forward one character
Control-P or Up	go to the previous line. If this is the first line of input then recall previous input from history.
Control-N or Down	go to the next line. If this is the last line of input then recall the next input from the history
Control-A or Home	move the cursor to the beginning of the line. If the cursor is already at the beginning of the line, then go to the beginning of the first line of the current input
Control-E or End	move the cursor to the end of the line. If the cursor is already at the end of the line, then move it to the end of the last line of the current input
Control-L or F5	reset terminal and repaint screen



    Creado por Deniss M., actualizado por última vez por Dāvis Bleikšs el abr 10, 2025 3 min de lectura

MAC server section allows you to configure MAC Telnet Server, MAC WinBox Server and MAC Ping Server on RouterOS device.

MAC Telnet is used to provide access to a router that has no IP address set. It works just like IP telnet. MAC telnet is possible between two MikroTik RouterOS routers only.

MAC WinBox is used to provide WinBox access to the router via MAC address.

MAC Ping is used to allow MAC pings to the router's MAC address.

MAC-server settings are included in the "system" package.
MAC Telnet Server

It is possible to set MAC Telnet access to specific interfaces that are a part of the interface list:
[admin@device] /tool mac-server set allowed-interface-list=listBridge
[admin@device] /tool mac-server print
  allowed-interface-list: listBridge

In the example above, MAC Telnet is configured for the interface list "listBridge" and, as a result, MAC Telnet will only work via the interfaces that are members of the list (you can add multiple interfaces to the list).

To disable MAC Telnet access, issue the command (set "allowed-interface-list" to "none"):
[admin@device] /tool mac-server set allowed-interface-list=none
[admin@device] /tool mac-server print
  allowed-interface-list: none

You can check active MAC Telnet sessions (that the device accepted) with the command:
[admin@device] > tool mac-server sessions print
Columns: INTERFACE, SRC-ADDRESS, UPTIME
#  INTERFACE  SRC-ADDRESS        UPTIME
0  ether5     64:D1:54:FB:E3:E6  17s 
MAC Telnet Client

When MAC Telnet Server is enabled, you can use another RouterOS device to connect to the server using the mac-telnet client:
[admin@device2] > tool mac-telnet B8:69:F4:7F:F2:E7    
Login: admin
Password: 
Trying B8:69:F4:7F:F2:E7...
Connected to B8:69:F4:7F:F2:E7




  MMM      MMM       KKK                          TTTTTTTTTTT      KKK
  MMMM    MMMM       KKK                          TTTTTTTTTTT      KKK
  MMM MMMM MMM  III  KKK  KKK  RRRRRR     OOOOOO      TTT     III  KKK  KKK
  MMM  MM  MMM  III  KKKKK     RRR  RRR  OOO  OOO     TTT     III  KKKKK
  MMM      MMM  III  KKK KKK   RRRRRR    OOO  OOO     TTT     III  KKK KKK
  MMM      MMM  III  KKK  KKK  RRR  RRR   OOOOOO      TTT     III  KKK  KKK

  MikroTik RouterOS 7.1rc3 (c) 1999-2021       https://www.mikrotik.com/

Press F1 for help
  
[admin@device] > 

Change the MAC address accordingly (to your setup) and you should get into the server's CLI (as shown in the example above).
MAC Scan

Mac scan feature discovers all devices, which support MAC telnet protocol on the given network. The command requires you to select an interface that should be scanned:
[admin@Sw_Denissm] > tool mac-scan interface=all           
MAC-ADDRESS       ADDRESS                AGE
B8:69:F4:7F:F2:E7 192.168.69.1            26
2C:C8:1B:FD:F2:C3 192.168.69.3            56

In the example, above, all interfaces are chosen, and the scan will run infinitely unless stopped (by pressing "q").

You can also add a "duration" parameter that will dictate for how long the scan should go on:
[admin@Sw_Denissm] > tool mac-scan interface=all duration=1
MAC-ADDRESS       ADDRESS                AGE
B8:69:F4:7F:F2:E7 192.168.69.1            48
2C:C8:1B:FD:F2:C3 192.168.69.3            17

In the example above, we set the "duration" parameter to 1 second.
MAC WinBox Server

Same as with MAC Telnet, it is possible to set MAC WinBox access to specific interfaces that are a part of the interface list:
[admin@device] > tool mac-server mac-winbox set allowed-interface-list=listBridge 
[admin@device] > tool mac-server mac-winbox print                   
  allowed-interface-list: listBridge

In the example above, MAC WinBox access is configured for the interface list "listBridge" and, as a result, MAC WinBox will only work via the interfaces that are members of the list.

To disable MAC WinBox access, issue the command (set "allowed-interface-list" to "none"):
[admin@device] > tool mac-server mac-winbox set allowed-interface-list=none
[admin@device] > tool mac-server mac-winbox print                   
  allowed-interface-list: none
MAC Ping Server

MAC Ping Server can be either set to be "disabled" or "enabled":
[admin@device] > tool mac-server ping print
  enabled: yes

You can enable or disable MAC ping with the help of the commands (enable=yes → to enable the feature; enable=no → to disable the feature):
[admin@device] > tool mac-server ping set enabled=yes
[admin@device] > tool mac-server ping set enabled=no

When MAC Ping is enabled, other hosts on the same broadcast domain can use ping tool to ping the mac address. For example, you can issue the following command to check MAC ping results:
[admin@device] > /ping 00:0C:42:72:A1:B0
HOST                                    SIZE  TTL TIME  STATUS                                         
00:0C:42:72:A1:B0                       56        0ms  
00:0C:42:72:A1:B0                       56        0ms  
    sent=2 received=2 packet-loss=0% min-rtt=0ms avg-rtt=0ms max-rtt=0ms 
	
	